//
// PerformanceCustom.swift
//
// Generated by Konfig
// https://konfigthis.com
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Performance Custom Response Object */
public struct PerformanceCustom: Codable, JSONEncodable, Hashable {

    public var totalEquityTimeframe: [PastValue]?
    public var contributions: NetContributions?
    public var contributionTimeframe: [PastValue]?
    public var contributionTimeframeCumulative: [PastValue]?
    public var withdrawalTimeframe: [PastValue]?
    /** Current streak of cosecutive months where contributions were made */
    public var contributionStreak: Double?
    /** Number of months in the timeframe with contributions */
    public var contributionMonthsContributed: Double?
    /** Total months in timeframe */
    public var contributionTotalMonths: Double?
    public var dividends: [NetDividend]?
    /** Total dividends received over the timeframe */
    public var dividendIncome: Double?
    /** Average dividends received per month over the timeframe */
    public var monthlyDividends: Double?
    /** list of tickers which may not be supported or may not have accurate price data */
    public var badTickers: [String]?
    public var dividendTimeline: [MonthlyDividends]?
    /** commissions incurred during the timeframe */
    public var commissions: Double?
    /** forex fees incurred during the timeframe */
    public var forexFees: Double?
    /** other fees incurred during the timeframe */
    public var fees: Double?
    /** The return rate over the timeframe. Annualized if timeframe is longer than 1 year */
    public var rateOfReturn: Double?
    public var returnRateTimeframe: [SubPeriodReturnRate]?
    /** Whether the user has detailed mode enabled (more frequent data points for totalEquity and contribution timeframes) */
    public var detailedMode: Bool?

    public init(totalEquityTimeframe: [PastValue]? = nil, contributions: NetContributions? = nil, contributionTimeframe: [PastValue]? = nil, contributionTimeframeCumulative: [PastValue]? = nil, withdrawalTimeframe: [PastValue]? = nil, contributionStreak: Double? = nil, contributionMonthsContributed: Double? = nil, contributionTotalMonths: Double? = nil, dividends: [NetDividend]? = nil, dividendIncome: Double? = nil, monthlyDividends: Double? = nil, badTickers: [String]? = nil, dividendTimeline: [MonthlyDividends]? = nil, commissions: Double? = nil, forexFees: Double? = nil, fees: Double? = nil, rateOfReturn: Double? = nil, returnRateTimeframe: [SubPeriodReturnRate]? = nil, detailedMode: Bool? = nil) {
        self.totalEquityTimeframe = totalEquityTimeframe
        self.contributions = contributions
        self.contributionTimeframe = contributionTimeframe
        self.contributionTimeframeCumulative = contributionTimeframeCumulative
        self.withdrawalTimeframe = withdrawalTimeframe
        self.contributionStreak = contributionStreak
        self.contributionMonthsContributed = contributionMonthsContributed
        self.contributionTotalMonths = contributionTotalMonths
        self.dividends = dividends
        self.dividendIncome = dividendIncome
        self.monthlyDividends = monthlyDividends
        self.badTickers = badTickers
        self.dividendTimeline = dividendTimeline
        self.commissions = commissions
        self.forexFees = forexFees
        self.fees = fees
        self.rateOfReturn = rateOfReturn
        self.returnRateTimeframe = returnRateTimeframe
        self.detailedMode = detailedMode
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case totalEquityTimeframe
        case contributions
        case contributionTimeframe
        case contributionTimeframeCumulative
        case withdrawalTimeframe
        case contributionStreak
        case contributionMonthsContributed
        case contributionTotalMonths
        case dividends
        case dividendIncome
        case monthlyDividends
        case badTickers
        case dividendTimeline
        case commissions
        case forexFees
        case fees
        case rateOfReturn
        case returnRateTimeframe
        case detailedMode
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(totalEquityTimeframe, forKey: .totalEquityTimeframe)
        try container.encodeIfPresent(contributions, forKey: .contributions)
        try container.encodeIfPresent(contributionTimeframe, forKey: .contributionTimeframe)
        try container.encodeIfPresent(contributionTimeframeCumulative, forKey: .contributionTimeframeCumulative)
        try container.encodeIfPresent(withdrawalTimeframe, forKey: .withdrawalTimeframe)
        try container.encodeIfPresent(contributionStreak, forKey: .contributionStreak)
        try container.encodeIfPresent(contributionMonthsContributed, forKey: .contributionMonthsContributed)
        try container.encodeIfPresent(contributionTotalMonths, forKey: .contributionTotalMonths)
        try container.encodeIfPresent(dividends, forKey: .dividends)
        try container.encodeIfPresent(dividendIncome, forKey: .dividendIncome)
        try container.encodeIfPresent(monthlyDividends, forKey: .monthlyDividends)
        try container.encodeIfPresent(badTickers, forKey: .badTickers)
        try container.encodeIfPresent(dividendTimeline, forKey: .dividendTimeline)
        try container.encodeIfPresent(commissions, forKey: .commissions)
        try container.encodeIfPresent(forexFees, forKey: .forexFees)
        try container.encodeIfPresent(fees, forKey: .fees)
        try container.encodeIfPresent(rateOfReturn, forKey: .rateOfReturn)
        try container.encodeIfPresent(returnRateTimeframe, forKey: .returnRateTimeframe)
        try container.encodeIfPresent(detailedMode, forKey: .detailedMode)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        totalEquityTimeframe = try container.decodeIfPresent([PastValue].self, forKey: .totalEquityTimeframe)
        contributions = try container.decodeIfPresent(NetContributions.self, forKey: .contributions)
        contributionTimeframe = try container.decodeIfPresent([PastValue].self, forKey: .contributionTimeframe)
        contributionTimeframeCumulative = try container.decodeIfPresent([PastValue].self, forKey: .contributionTimeframeCumulative)
        withdrawalTimeframe = try container.decodeIfPresent([PastValue].self, forKey: .withdrawalTimeframe)
        contributionStreak = try container.decodeIfPresent(Double.self, forKey: .contributionStreak)
        contributionMonthsContributed = try container.decodeIfPresent(Double.self, forKey: .contributionMonthsContributed)
        contributionTotalMonths = try container.decodeIfPresent(Double.self, forKey: .contributionTotalMonths)
        dividends = try container.decodeIfPresent([NetDividend].self, forKey: .dividends)
        dividendIncome = try container.decodeIfPresent(Double.self, forKey: .dividendIncome)
        monthlyDividends = try container.decodeIfPresent(Double.self, forKey: .monthlyDividends)
        badTickers = try container.decodeIfPresent([String].self, forKey: .badTickers)
        dividendTimeline = try container.decodeIfPresent([MonthlyDividends].self, forKey: .dividendTimeline)
        commissions = try container.decodeIfPresent(Double.self, forKey: .commissions)
        forexFees = try container.decodeIfPresent(Double.self, forKey: .forexFees)
        fees = try container.decodeIfPresent(Double.self, forKey: .fees)
        rateOfReturn = try container.decodeIfPresent(Double.self, forKey: .rateOfReturn)
        returnRateTimeframe = try container.decodeIfPresent([SubPeriodReturnRate].self, forKey: .returnRateTimeframe)
        detailedMode = try container.decodeIfPresent(Bool.self, forKey: .detailedMode)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("totalEquityTimeframe")
        nonAdditionalPropertyKeys.insert("contributions")
        nonAdditionalPropertyKeys.insert("contributionTimeframe")
        nonAdditionalPropertyKeys.insert("contributionTimeframeCumulative")
        nonAdditionalPropertyKeys.insert("withdrawalTimeframe")
        nonAdditionalPropertyKeys.insert("contributionStreak")
        nonAdditionalPropertyKeys.insert("contributionMonthsContributed")
        nonAdditionalPropertyKeys.insert("contributionTotalMonths")
        nonAdditionalPropertyKeys.insert("dividends")
        nonAdditionalPropertyKeys.insert("dividendIncome")
        nonAdditionalPropertyKeys.insert("monthlyDividends")
        nonAdditionalPropertyKeys.insert("badTickers")
        nonAdditionalPropertyKeys.insert("dividendTimeline")
        nonAdditionalPropertyKeys.insert("commissions")
        nonAdditionalPropertyKeys.insert("forexFees")
        nonAdditionalPropertyKeys.insert("fees")
        nonAdditionalPropertyKeys.insert("rateOfReturn")
        nonAdditionalPropertyKeys.insert("returnRateTimeframe")
        nonAdditionalPropertyKeys.insert("detailedMode")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

