//
// UniversalActivity.swift
//
// Generated by Konfig
// https://konfigthis.com
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** A transaction or activity from an institution */
public struct UniversalActivity: Codable, JSONEncodable, Hashable {

    public var id: String?
    public var account: AccountSimple?
    public var amount: Double?
    public var currency: Currency?
    public var description: String?
    public var fee: Double?
    /** The forex conversion rate involved in the transaction if provided by the brokerage. Used in cases where securities of one currency are purchased in a different currency, and the forex conversion is automatic. In those cases, price, amount and fee will be in the top level currency (activity -> currency) */
    public var fxRate: Double?
    public var institution: String?
    /** If an option transaction, then it's type (BUY_TO_OPEN, SELL_TO_CLOSE, etc), otherwise empty string */
    public var optionType: String?
    public var price: Double?
    public var settlementDate: String?
    /** Reference ID from brokerage used to identify related transactions. For example if an order comprises of several transactions (buy, fee, fx), they can be grouped if they share the same external_reference_id */
    public var externalReferenceId: String?
    public var symbol: Symbol?
    public var optionSymbol: OptionsSymbol?
    public var tradeDate: String?
    /** Potential values include (but are not limited to) - DIVIDEND - BUY - SELL - CONTRIBUTION - WITHDRAWAL - EXTERNAL_ASSET_TRANSFER_IN - EXTERNAL_ASSET_TRANSFER_OUT - INTERNAL_CASH_TRANSFER_IN - INTERNAL_CASH_TRANSFER_OUT - INTERNAL_ASSET_TRANSFER_IN - INTERNAL_ASSET_TRANSFER_OUT - INTEREST - REBATE - GOV_GRANT - TAX - FEE - REI - FXT */
    public var type: String?
    /** Usually but not necessarily an integer */
    public var units: Double?

    public init(id: String? = nil, account: AccountSimple? = nil, amount: Double? = nil, currency: Currency? = nil, description: String? = nil, fee: Double? = nil, fxRate: Double? = nil, institution: String? = nil, optionType: String? = nil, price: Double? = nil, settlementDate: String? = nil, externalReferenceId: String? = nil, symbol: Symbol? = nil, optionSymbol: OptionsSymbol? = nil, tradeDate: String? = nil, type: String? = nil, units: Double? = nil) {
        self.id = id
        self.account = account
        self.amount = amount
        self.currency = currency
        self.description = description
        self.fee = fee
        self.fxRate = fxRate
        self.institution = institution
        self.optionType = optionType
        self.price = price
        self.settlementDate = settlementDate
        self.externalReferenceId = externalReferenceId
        self.symbol = symbol
        self.optionSymbol = optionSymbol
        self.tradeDate = tradeDate
        self.type = type
        self.units = units
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case account
        case amount
        case currency
        case description
        case fee
        case fxRate = "fx_rate"
        case institution
        case optionType = "option_type"
        case price
        case settlementDate = "settlement_date"
        case externalReferenceId = "external_reference_id"
        case symbol
        case optionSymbol = "option_symbol"
        case tradeDate = "trade_date"
        case type
        case units
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(account, forKey: .account)
        try container.encodeIfPresent(amount, forKey: .amount)
        try container.encodeIfPresent(currency, forKey: .currency)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encodeIfPresent(fee, forKey: .fee)
        try container.encodeIfPresent(fxRate, forKey: .fxRate)
        try container.encodeIfPresent(institution, forKey: .institution)
        try container.encodeIfPresent(optionType, forKey: .optionType)
        try container.encodeIfPresent(price, forKey: .price)
        try container.encodeIfPresent(settlementDate, forKey: .settlementDate)
        try container.encodeIfPresent(externalReferenceId, forKey: .externalReferenceId)
        try container.encodeIfPresent(symbol, forKey: .symbol)
        try container.encodeIfPresent(optionSymbol, forKey: .optionSymbol)
        try container.encodeIfPresent(tradeDate, forKey: .tradeDate)
        try container.encodeIfPresent(type, forKey: .type)
        try container.encodeIfPresent(units, forKey: .units)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        id = try container.decodeIfPresent(String.self, forKey: .id)
        account = try container.decodeIfPresent(AccountSimple.self, forKey: .account)
        amount = try container.decodeIfPresent(Double.self, forKey: .amount)
        currency = try container.decodeIfPresent(Currency.self, forKey: .currency)
        description = try container.decodeIfPresent(String.self, forKey: .description)
        fee = try container.decodeIfPresent(Double.self, forKey: .fee)
        fxRate = try container.decodeIfPresent(Double.self, forKey: .fxRate)
        institution = try container.decodeIfPresent(String.self, forKey: .institution)
        optionType = try container.decodeIfPresent(String.self, forKey: .optionType)
        price = try container.decodeIfPresent(Double.self, forKey: .price)
        settlementDate = try container.decodeIfPresent(String.self, forKey: .settlementDate)
        externalReferenceId = try container.decodeIfPresent(String.self, forKey: .externalReferenceId)
        symbol = try container.decodeIfPresent(Symbol.self, forKey: .symbol)
        optionSymbol = try container.decodeIfPresent(OptionsSymbol.self, forKey: .optionSymbol)
        tradeDate = try container.decodeIfPresent(String.self, forKey: .tradeDate)
        type = try container.decodeIfPresent(String.self, forKey: .type)
        units = try container.decodeIfPresent(Double.self, forKey: .units)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("id")
        nonAdditionalPropertyKeys.insert("account")
        nonAdditionalPropertyKeys.insert("amount")
        nonAdditionalPropertyKeys.insert("currency")
        nonAdditionalPropertyKeys.insert("description")
        nonAdditionalPropertyKeys.insert("fee")
        nonAdditionalPropertyKeys.insert("fx_rate")
        nonAdditionalPropertyKeys.insert("institution")
        nonAdditionalPropertyKeys.insert("option_type")
        nonAdditionalPropertyKeys.insert("price")
        nonAdditionalPropertyKeys.insert("settlement_date")
        nonAdditionalPropertyKeys.insert("external_reference_id")
        nonAdditionalPropertyKeys.insert("symbol")
        nonAdditionalPropertyKeys.insert("option_symbol")
        nonAdditionalPropertyKeys.insert("trade_date")
        nonAdditionalPropertyKeys.insert("type")
        nonAdditionalPropertyKeys.insert("units")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

