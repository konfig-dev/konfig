//
// StrategyOrderRecord.swift
//
// Generated by Konfig
// https://konfigthis.com
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Strategy order record */
public struct StrategyOrderRecord: Codable, JSONEncodable, Hashable {

    public enum Status: String, Codable, CaseIterable {
        case pending = "PENDING"
        case accepted = "ACCEPTED"
        case failed = "FAILED"
        case rejected = "REJECTED"
        case canceled = "CANCELED"
        case partialCanceled = "PARTIAL_CANCELED"
        case cancelPending = "CANCEL_PENDING"
        case executed = "EXECUTED"
        case partial = "PARTIAL"
        case replacePending = "REPLACE_PENDING"
        case replaced = "REPLACED"
        case stopped = "STOPPED"
        case suspended = "SUSPENDED"
        case expired = "EXPIRED"
        case queued = "QUEUED"
        case triggered = "TRIGGERED"
        case activated = "ACTIVATED"
        case pendingRiskReview = "PENDING_RISK_REVIEW"
        case contingentOrder = "CONTINGENT_ORDER"
    }
    public var strategy: OptionStrategy?
    public var status: Status?
    public var filledQuantity: Double?
    public var openQuantity: Double?
    public var closedQuantity: Double?
    public var orderType: OrderType?
    /** Trade time in force examples:   * FOK - Fill Or Kill   * Day - Day   * GTC - Good Til Canceled   * GTD - Good Til Date  */
    public var timeInForce: String?
    /** Trade Price if limit or stop limit order */
    public var limitPrice: Double?
    /** Trade Price if limit or stop limit order */
    public var executionPrice: Double?
    /** Time */
    public var timePlaced: String?
    /** Time */
    public var timeUpdated: String?

    public init(strategy: OptionStrategy? = nil, status: Status? = nil, filledQuantity: Double? = nil, openQuantity: Double? = nil, closedQuantity: Double? = nil, orderType: OrderType? = nil, timeInForce: String? = nil, limitPrice: Double? = nil, executionPrice: Double? = nil, timePlaced: String? = nil, timeUpdated: String? = nil) {
        self.strategy = strategy
        self.status = status
        self.filledQuantity = filledQuantity
        self.openQuantity = openQuantity
        self.closedQuantity = closedQuantity
        self.orderType = orderType
        self.timeInForce = timeInForce
        self.limitPrice = limitPrice
        self.executionPrice = executionPrice
        self.timePlaced = timePlaced
        self.timeUpdated = timeUpdated
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case strategy
        case status
        case filledQuantity = "filled_quantity"
        case openQuantity = "open_quantity"
        case closedQuantity = "closed_quantity"
        case orderType = "order_type"
        case timeInForce = "time_in_force"
        case limitPrice = "limit_price"
        case executionPrice = "execution_price"
        case timePlaced = "time_placed"
        case timeUpdated = "time_updated"
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(strategy, forKey: .strategy)
        try container.encodeIfPresent(status, forKey: .status)
        try container.encodeIfPresent(filledQuantity, forKey: .filledQuantity)
        try container.encodeIfPresent(openQuantity, forKey: .openQuantity)
        try container.encodeIfPresent(closedQuantity, forKey: .closedQuantity)
        try container.encodeIfPresent(orderType, forKey: .orderType)
        try container.encodeIfPresent(timeInForce, forKey: .timeInForce)
        try container.encodeIfPresent(limitPrice, forKey: .limitPrice)
        try container.encodeIfPresent(executionPrice, forKey: .executionPrice)
        try container.encodeIfPresent(timePlaced, forKey: .timePlaced)
        try container.encodeIfPresent(timeUpdated, forKey: .timeUpdated)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        strategy = try container.decodeIfPresent(OptionStrategy.self, forKey: .strategy)
        status = try container.decodeIfPresent(Status.self, forKey: .status)
        filledQuantity = try container.decodeIfPresent(Double.self, forKey: .filledQuantity)
        openQuantity = try container.decodeIfPresent(Double.self, forKey: .openQuantity)
        closedQuantity = try container.decodeIfPresent(Double.self, forKey: .closedQuantity)
        orderType = try container.decodeIfPresent(OrderType.self, forKey: .orderType)
        timeInForce = try container.decodeIfPresent(String.self, forKey: .timeInForce)
        limitPrice = try container.decodeIfPresent(Double.self, forKey: .limitPrice)
        executionPrice = try container.decodeIfPresent(Double.self, forKey: .executionPrice)
        timePlaced = try container.decodeIfPresent(String.self, forKey: .timePlaced)
        timeUpdated = try container.decodeIfPresent(String.self, forKey: .timeUpdated)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("strategy")
        nonAdditionalPropertyKeys.insert("status")
        nonAdditionalPropertyKeys.insert("filled_quantity")
        nonAdditionalPropertyKeys.insert("open_quantity")
        nonAdditionalPropertyKeys.insert("closed_quantity")
        nonAdditionalPropertyKeys.insert("order_type")
        nonAdditionalPropertyKeys.insert("time_in_force")
        nonAdditionalPropertyKeys.insert("limit_price")
        nonAdditionalPropertyKeys.insert("execution_price")
        nonAdditionalPropertyKeys.insert("time_placed")
        nonAdditionalPropertyKeys.insert("time_updated")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

