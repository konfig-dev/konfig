//
// StrategyQuotes.swift
//
// Generated by Konfig
// https://konfigthis.com
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct StrategyQuotes: Codable, JSONEncodable, Hashable {

    public var strategy: OptionStrategy?
    /** Trade Price if limit or stop limit order */
    public var openPrice: Double?
    /** Trade Price if limit or stop limit order */
    public var bidPrice: Double?
    /** Trade Price if limit or stop limit order */
    public var askPrice: Double?
    public var volatility: Double?
    public var greek: StrategyQuotesGreek?

    public init(strategy: OptionStrategy? = nil, openPrice: Double? = nil, bidPrice: Double? = nil, askPrice: Double? = nil, volatility: Double? = nil, greek: StrategyQuotesGreek? = nil) {
        self.strategy = strategy
        self.openPrice = openPrice
        self.bidPrice = bidPrice
        self.askPrice = askPrice
        self.volatility = volatility
        self.greek = greek
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case strategy
        case openPrice = "open_price"
        case bidPrice = "bid_price"
        case askPrice = "ask_price"
        case volatility
        case greek
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(strategy, forKey: .strategy)
        try container.encodeIfPresent(openPrice, forKey: .openPrice)
        try container.encodeIfPresent(bidPrice, forKey: .bidPrice)
        try container.encodeIfPresent(askPrice, forKey: .askPrice)
        try container.encodeIfPresent(volatility, forKey: .volatility)
        try container.encodeIfPresent(greek, forKey: .greek)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        strategy = try container.decodeIfPresent(OptionStrategy.self, forKey: .strategy)
        openPrice = try container.decodeIfPresent(Double.self, forKey: .openPrice)
        bidPrice = try container.decodeIfPresent(Double.self, forKey: .bidPrice)
        askPrice = try container.decodeIfPresent(Double.self, forKey: .askPrice)
        volatility = try container.decodeIfPresent(Double.self, forKey: .volatility)
        greek = try container.decodeIfPresent(StrategyQuotesGreek.self, forKey: .greek)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("strategy")
        nonAdditionalPropertyKeys.insert("open_price")
        nonAdditionalPropertyKeys.insert("bid_price")
        nonAdditionalPropertyKeys.insert("ask_price")
        nonAdditionalPropertyKeys.insert("volatility")
        nonAdditionalPropertyKeys.insert("greek")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

