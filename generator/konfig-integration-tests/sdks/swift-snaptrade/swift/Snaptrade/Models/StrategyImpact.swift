//
// StrategyImpact.swift
//
// Generated by Konfig
// https://konfigthis.com
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** The strategy impact */
public struct StrategyImpact: Codable, JSONEncodable, Hashable {

    public var estimatedCommissions: Double?
    public var buyingPowerEffect: Double?
    public var buyingPowerResult: Double?
    public var maintExcessEffect: Double?
    public var maintExcessResult: Double?
    public var tradeValueCalculation: String?
    public var legs: [StrategyImpactLegsInner]?
    public var side: String?
    public var effect: String?
    public var price: Double?
    public var strategy: String?

    public init(estimatedCommissions: Double? = nil, buyingPowerEffect: Double? = nil, buyingPowerResult: Double? = nil, maintExcessEffect: Double? = nil, maintExcessResult: Double? = nil, tradeValueCalculation: String? = nil, legs: [StrategyImpactLegsInner]? = nil, side: String? = nil, effect: String? = nil, price: Double? = nil, strategy: String? = nil) {
        self.estimatedCommissions = estimatedCommissions
        self.buyingPowerEffect = buyingPowerEffect
        self.buyingPowerResult = buyingPowerResult
        self.maintExcessEffect = maintExcessEffect
        self.maintExcessResult = maintExcessResult
        self.tradeValueCalculation = tradeValueCalculation
        self.legs = legs
        self.side = side
        self.effect = effect
        self.price = price
        self.strategy = strategy
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case estimatedCommissions
        case buyingPowerEffect
        case buyingPowerResult
        case maintExcessEffect
        case maintExcessResult
        case tradeValueCalculation
        case legs
        case side
        case effect
        case price
        case strategy
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(estimatedCommissions, forKey: .estimatedCommissions)
        try container.encodeIfPresent(buyingPowerEffect, forKey: .buyingPowerEffect)
        try container.encodeIfPresent(buyingPowerResult, forKey: .buyingPowerResult)
        try container.encodeIfPresent(maintExcessEffect, forKey: .maintExcessEffect)
        try container.encodeIfPresent(maintExcessResult, forKey: .maintExcessResult)
        try container.encodeIfPresent(tradeValueCalculation, forKey: .tradeValueCalculation)
        try container.encodeIfPresent(legs, forKey: .legs)
        try container.encodeIfPresent(side, forKey: .side)
        try container.encodeIfPresent(effect, forKey: .effect)
        try container.encodeIfPresent(price, forKey: .price)
        try container.encodeIfPresent(strategy, forKey: .strategy)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        estimatedCommissions = try container.decodeIfPresent(Double.self, forKey: .estimatedCommissions)
        buyingPowerEffect = try container.decodeIfPresent(Double.self, forKey: .buyingPowerEffect)
        buyingPowerResult = try container.decodeIfPresent(Double.self, forKey: .buyingPowerResult)
        maintExcessEffect = try container.decodeIfPresent(Double.self, forKey: .maintExcessEffect)
        maintExcessResult = try container.decodeIfPresent(Double.self, forKey: .maintExcessResult)
        tradeValueCalculation = try container.decodeIfPresent(String.self, forKey: .tradeValueCalculation)
        legs = try container.decodeIfPresent([StrategyImpactLegsInner].self, forKey: .legs)
        side = try container.decodeIfPresent(String.self, forKey: .side)
        effect = try container.decodeIfPresent(String.self, forKey: .effect)
        price = try container.decodeIfPresent(Double.self, forKey: .price)
        strategy = try container.decodeIfPresent(String.self, forKey: .strategy)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("estimatedCommissions")
        nonAdditionalPropertyKeys.insert("buyingPowerEffect")
        nonAdditionalPropertyKeys.insert("buyingPowerResult")
        nonAdditionalPropertyKeys.insert("maintExcessEffect")
        nonAdditionalPropertyKeys.insert("maintExcessResult")
        nonAdditionalPropertyKeys.insert("tradeValueCalculation")
        nonAdditionalPropertyKeys.insert("legs")
        nonAdditionalPropertyKeys.insert("side")
        nonAdditionalPropertyKeys.insert("effect")
        nonAdditionalPropertyKeys.insert("price")
        nonAdditionalPropertyKeys.insert("strategy")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

