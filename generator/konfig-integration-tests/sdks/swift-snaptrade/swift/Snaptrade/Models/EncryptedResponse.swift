//
// EncryptedResponse.swift
//
// Generated by Konfig
// https://konfigthis.com
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** This response consists of 2 different components that must be decrypted to obtain the decrypted message  * Decrypting the encryptedSharedKey    The encrypted shared key is a shared key that was randomly generated by SnapTrade and encrypted using the users SSH public key provided when registering the user   It is needed to decrypt the message in step 2.    To decrypt the shared key, the user should have access to their SSH private key stored locally in their device    An example Python code on how to decrypt the shared key is shown below    &#x60;&#x60;&#x60;   def decrypt_rsa_message(self, encrypted_message):       from Crypto.Cipher import PKCS1_OAEP       from Crypto.PublicKey import RSA       from base64 import b64decode        f &#x3D; open(&#39;private.pem&#39;, &#39;r&#39;)       private_key &#x3D; RSA.import_key(f.read())       cipher &#x3D; PKCS1_OAEP.new(private_key)        return cipher.decrypt(b64decode(encrypted_message.encode())).decode()   &#x60;&#x60;&#x60;  * Decrypting the encryptedMessageData     The data meant to be returned by an endpoint can be obtained by decrypting the encrypted message     An encrypted message is a message that is encrypted using AES - MODE OCB with the shared key obtained in step one    An example code to decrypt the encrypted message is shown below    &#x60;&#x60;&#x60;   def decrypt_aes_message(self, shared_key, encrypted_message):       from Crypto.Cipher import AES       from base64 import b64decode        encrypted_msg &#x3D; b64decode(encrypted_message[\&quot;encryptedMessage\&quot;].encode())       tag &#x3D; b64decode(encrypted_message[\&quot;tag\&quot;].encode())       nonce &#x3D; b64decode(encrypted_message[\&quot;nonce\&quot;].encode())       cipher &#x3D; AES.new(shared_key.encode(), AES.MODE_OCB, nonce&#x3D;nonce)        return cipher.decrypt_and_verify(encrypted_msg, tag).decode()   &#x60;&#x60;&#x60;  */
public struct EncryptedResponse: Codable, JSONEncodable, Hashable {

    public var encryptedSharedKey: String?
    public var encryptedMessageData: EncryptedResponseEncryptedMessageData?

    public init(encryptedSharedKey: String? = nil, encryptedMessageData: EncryptedResponseEncryptedMessageData? = nil) {
        self.encryptedSharedKey = encryptedSharedKey
        self.encryptedMessageData = encryptedMessageData
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case encryptedSharedKey
        case encryptedMessageData
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(encryptedSharedKey, forKey: .encryptedSharedKey)
        try container.encodeIfPresent(encryptedMessageData, forKey: .encryptedMessageData)
    }
}

