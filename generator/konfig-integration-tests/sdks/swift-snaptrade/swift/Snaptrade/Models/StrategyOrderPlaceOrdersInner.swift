//
// StrategyOrderPlaceOrdersInner.swift
//
// Generated by Konfig
// https://konfigthis.com
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct StrategyOrderPlaceOrdersInner: Codable, JSONEncodable, Hashable {

    public var id: Int?
    public var symbol: String?
    public var symbolId: Int?
    public var totalQuantity: Int?
    public var openQuantity: Int?
    public var filledQuantity: Int?
    public var canceledQuantity: Int?
    public var side: String?
    public var orderType: String?
    public var limitPrice: String?
    public var stopPrice: String?
    public var isAllOrNone: Bool?
    public var isAnonymous: Bool?
    public var icebergQuantity: String?
    public var minQuantity: String?
    public var avgExecPrice: Int?
    public var lastExecPrice: String?
    public var source: String?
    public var timeInForce: String?
    public var gtdDate: String?
    public var state: String?
    public var rejectionReason: String?
    public var chainId: Int?
    public var creationTime: String?
    public var updateTime: String?
    public var notes: String?
    public var primaryRoute: String?
    public var secondaryRoute: String?
    public var orderRoute: String?
    public var venueHoldingOrder: String?
    public var comissionCharged: Int?
    public var exchangeOrderId: String?
    public var isSignificantShareHolder: Bool?
    public var isInsider: Bool?
    public var isLimitOffsetInDollar: Bool?
    public var userId: Int?
    public var placementCommission: String?
    public var legs: [StrategyOrderPlaceOrdersInnerLegsInner]?
    public var strategyType: String?
    public var triggerStopPrice: String?
    public var orderGroupId: Int?
    public var orderClass: String?
    public var isCrossZero: Bool?

    public init(id: Int? = nil, symbol: String? = nil, symbolId: Int? = nil, totalQuantity: Int? = nil, openQuantity: Int? = nil, filledQuantity: Int? = nil, canceledQuantity: Int? = nil, side: String? = nil, orderType: String? = nil, limitPrice: String? = nil, stopPrice: String? = nil, isAllOrNone: Bool? = nil, isAnonymous: Bool? = nil, icebergQuantity: String? = nil, minQuantity: String? = nil, avgExecPrice: Int? = nil, lastExecPrice: String? = nil, source: String? = nil, timeInForce: String? = nil, gtdDate: String? = nil, state: String? = nil, rejectionReason: String? = nil, chainId: Int? = nil, creationTime: String? = nil, updateTime: String? = nil, notes: String? = nil, primaryRoute: String? = nil, secondaryRoute: String? = nil, orderRoute: String? = nil, venueHoldingOrder: String? = nil, comissionCharged: Int? = nil, exchangeOrderId: String? = nil, isSignificantShareHolder: Bool? = nil, isInsider: Bool? = nil, isLimitOffsetInDollar: Bool? = nil, userId: Int? = nil, placementCommission: String? = nil, legs: [StrategyOrderPlaceOrdersInnerLegsInner]? = nil, strategyType: String? = nil, triggerStopPrice: String? = nil, orderGroupId: Int? = nil, orderClass: String? = nil, isCrossZero: Bool? = nil) {
        self.id = id
        self.symbol = symbol
        self.symbolId = symbolId
        self.totalQuantity = totalQuantity
        self.openQuantity = openQuantity
        self.filledQuantity = filledQuantity
        self.canceledQuantity = canceledQuantity
        self.side = side
        self.orderType = orderType
        self.limitPrice = limitPrice
        self.stopPrice = stopPrice
        self.isAllOrNone = isAllOrNone
        self.isAnonymous = isAnonymous
        self.icebergQuantity = icebergQuantity
        self.minQuantity = minQuantity
        self.avgExecPrice = avgExecPrice
        self.lastExecPrice = lastExecPrice
        self.source = source
        self.timeInForce = timeInForce
        self.gtdDate = gtdDate
        self.state = state
        self.rejectionReason = rejectionReason
        self.chainId = chainId
        self.creationTime = creationTime
        self.updateTime = updateTime
        self.notes = notes
        self.primaryRoute = primaryRoute
        self.secondaryRoute = secondaryRoute
        self.orderRoute = orderRoute
        self.venueHoldingOrder = venueHoldingOrder
        self.comissionCharged = comissionCharged
        self.exchangeOrderId = exchangeOrderId
        self.isSignificantShareHolder = isSignificantShareHolder
        self.isInsider = isInsider
        self.isLimitOffsetInDollar = isLimitOffsetInDollar
        self.userId = userId
        self.placementCommission = placementCommission
        self.legs = legs
        self.strategyType = strategyType
        self.triggerStopPrice = triggerStopPrice
        self.orderGroupId = orderGroupId
        self.orderClass = orderClass
        self.isCrossZero = isCrossZero
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case symbol
        case symbolId
        case totalQuantity
        case openQuantity
        case filledQuantity
        case canceledQuantity
        case side
        case orderType
        case limitPrice
        case stopPrice
        case isAllOrNone
        case isAnonymous
        case icebergQuantity
        case minQuantity
        case avgExecPrice
        case lastExecPrice
        case source
        case timeInForce
        case gtdDate
        case state
        case rejectionReason
        case chainId
        case creationTime
        case updateTime
        case notes
        case primaryRoute
        case secondaryRoute
        case orderRoute
        case venueHoldingOrder
        case comissionCharged
        case exchangeOrderId
        case isSignificantShareHolder
        case isInsider
        case isLimitOffsetInDollar
        case userId
        case placementCommission
        case legs
        case strategyType
        case triggerStopPrice
        case orderGroupId
        case orderClass
        case isCrossZero
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(symbol, forKey: .symbol)
        try container.encodeIfPresent(symbolId, forKey: .symbolId)
        try container.encodeIfPresent(totalQuantity, forKey: .totalQuantity)
        try container.encodeIfPresent(openQuantity, forKey: .openQuantity)
        try container.encodeIfPresent(filledQuantity, forKey: .filledQuantity)
        try container.encodeIfPresent(canceledQuantity, forKey: .canceledQuantity)
        try container.encodeIfPresent(side, forKey: .side)
        try container.encodeIfPresent(orderType, forKey: .orderType)
        try container.encodeIfPresent(limitPrice, forKey: .limitPrice)
        try container.encodeIfPresent(stopPrice, forKey: .stopPrice)
        try container.encodeIfPresent(isAllOrNone, forKey: .isAllOrNone)
        try container.encodeIfPresent(isAnonymous, forKey: .isAnonymous)
        try container.encodeIfPresent(icebergQuantity, forKey: .icebergQuantity)
        try container.encodeIfPresent(minQuantity, forKey: .minQuantity)
        try container.encodeIfPresent(avgExecPrice, forKey: .avgExecPrice)
        try container.encodeIfPresent(lastExecPrice, forKey: .lastExecPrice)
        try container.encodeIfPresent(source, forKey: .source)
        try container.encodeIfPresent(timeInForce, forKey: .timeInForce)
        try container.encodeIfPresent(gtdDate, forKey: .gtdDate)
        try container.encodeIfPresent(state, forKey: .state)
        try container.encodeIfPresent(rejectionReason, forKey: .rejectionReason)
        try container.encodeIfPresent(chainId, forKey: .chainId)
        try container.encodeIfPresent(creationTime, forKey: .creationTime)
        try container.encodeIfPresent(updateTime, forKey: .updateTime)
        try container.encodeIfPresent(notes, forKey: .notes)
        try container.encodeIfPresent(primaryRoute, forKey: .primaryRoute)
        try container.encodeIfPresent(secondaryRoute, forKey: .secondaryRoute)
        try container.encodeIfPresent(orderRoute, forKey: .orderRoute)
        try container.encodeIfPresent(venueHoldingOrder, forKey: .venueHoldingOrder)
        try container.encodeIfPresent(comissionCharged, forKey: .comissionCharged)
        try container.encodeIfPresent(exchangeOrderId, forKey: .exchangeOrderId)
        try container.encodeIfPresent(isSignificantShareHolder, forKey: .isSignificantShareHolder)
        try container.encodeIfPresent(isInsider, forKey: .isInsider)
        try container.encodeIfPresent(isLimitOffsetInDollar, forKey: .isLimitOffsetInDollar)
        try container.encodeIfPresent(userId, forKey: .userId)
        try container.encodeIfPresent(placementCommission, forKey: .placementCommission)
        try container.encodeIfPresent(legs, forKey: .legs)
        try container.encodeIfPresent(strategyType, forKey: .strategyType)
        try container.encodeIfPresent(triggerStopPrice, forKey: .triggerStopPrice)
        try container.encodeIfPresent(orderGroupId, forKey: .orderGroupId)
        try container.encodeIfPresent(orderClass, forKey: .orderClass)
        try container.encodeIfPresent(isCrossZero, forKey: .isCrossZero)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        id = try container.decodeIfPresent(Int.self, forKey: .id)
        symbol = try container.decodeIfPresent(String.self, forKey: .symbol)
        symbolId = try container.decodeIfPresent(Int.self, forKey: .symbolId)
        totalQuantity = try container.decodeIfPresent(Int.self, forKey: .totalQuantity)
        openQuantity = try container.decodeIfPresent(Int.self, forKey: .openQuantity)
        filledQuantity = try container.decodeIfPresent(Int.self, forKey: .filledQuantity)
        canceledQuantity = try container.decodeIfPresent(Int.self, forKey: .canceledQuantity)
        side = try container.decodeIfPresent(String.self, forKey: .side)
        orderType = try container.decodeIfPresent(String.self, forKey: .orderType)
        limitPrice = try container.decodeIfPresent(String.self, forKey: .limitPrice)
        stopPrice = try container.decodeIfPresent(String.self, forKey: .stopPrice)
        isAllOrNone = try container.decodeIfPresent(Bool.self, forKey: .isAllOrNone)
        isAnonymous = try container.decodeIfPresent(Bool.self, forKey: .isAnonymous)
        icebergQuantity = try container.decodeIfPresent(String.self, forKey: .icebergQuantity)
        minQuantity = try container.decodeIfPresent(String.self, forKey: .minQuantity)
        avgExecPrice = try container.decodeIfPresent(Int.self, forKey: .avgExecPrice)
        lastExecPrice = try container.decodeIfPresent(String.self, forKey: .lastExecPrice)
        source = try container.decodeIfPresent(String.self, forKey: .source)
        timeInForce = try container.decodeIfPresent(String.self, forKey: .timeInForce)
        gtdDate = try container.decodeIfPresent(String.self, forKey: .gtdDate)
        state = try container.decodeIfPresent(String.self, forKey: .state)
        rejectionReason = try container.decodeIfPresent(String.self, forKey: .rejectionReason)
        chainId = try container.decodeIfPresent(Int.self, forKey: .chainId)
        creationTime = try container.decodeIfPresent(String.self, forKey: .creationTime)
        updateTime = try container.decodeIfPresent(String.self, forKey: .updateTime)
        notes = try container.decodeIfPresent(String.self, forKey: .notes)
        primaryRoute = try container.decodeIfPresent(String.self, forKey: .primaryRoute)
        secondaryRoute = try container.decodeIfPresent(String.self, forKey: .secondaryRoute)
        orderRoute = try container.decodeIfPresent(String.self, forKey: .orderRoute)
        venueHoldingOrder = try container.decodeIfPresent(String.self, forKey: .venueHoldingOrder)
        comissionCharged = try container.decodeIfPresent(Int.self, forKey: .comissionCharged)
        exchangeOrderId = try container.decodeIfPresent(String.self, forKey: .exchangeOrderId)
        isSignificantShareHolder = try container.decodeIfPresent(Bool.self, forKey: .isSignificantShareHolder)
        isInsider = try container.decodeIfPresent(Bool.self, forKey: .isInsider)
        isLimitOffsetInDollar = try container.decodeIfPresent(Bool.self, forKey: .isLimitOffsetInDollar)
        userId = try container.decodeIfPresent(Int.self, forKey: .userId)
        placementCommission = try container.decodeIfPresent(String.self, forKey: .placementCommission)
        legs = try container.decodeIfPresent([StrategyOrderPlaceOrdersInnerLegsInner].self, forKey: .legs)
        strategyType = try container.decodeIfPresent(String.self, forKey: .strategyType)
        triggerStopPrice = try container.decodeIfPresent(String.self, forKey: .triggerStopPrice)
        orderGroupId = try container.decodeIfPresent(Int.self, forKey: .orderGroupId)
        orderClass = try container.decodeIfPresent(String.self, forKey: .orderClass)
        isCrossZero = try container.decodeIfPresent(Bool.self, forKey: .isCrossZero)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("id")
        nonAdditionalPropertyKeys.insert("symbol")
        nonAdditionalPropertyKeys.insert("symbolId")
        nonAdditionalPropertyKeys.insert("totalQuantity")
        nonAdditionalPropertyKeys.insert("openQuantity")
        nonAdditionalPropertyKeys.insert("filledQuantity")
        nonAdditionalPropertyKeys.insert("canceledQuantity")
        nonAdditionalPropertyKeys.insert("side")
        nonAdditionalPropertyKeys.insert("orderType")
        nonAdditionalPropertyKeys.insert("limitPrice")
        nonAdditionalPropertyKeys.insert("stopPrice")
        nonAdditionalPropertyKeys.insert("isAllOrNone")
        nonAdditionalPropertyKeys.insert("isAnonymous")
        nonAdditionalPropertyKeys.insert("icebergQuantity")
        nonAdditionalPropertyKeys.insert("minQuantity")
        nonAdditionalPropertyKeys.insert("avgExecPrice")
        nonAdditionalPropertyKeys.insert("lastExecPrice")
        nonAdditionalPropertyKeys.insert("source")
        nonAdditionalPropertyKeys.insert("timeInForce")
        nonAdditionalPropertyKeys.insert("gtdDate")
        nonAdditionalPropertyKeys.insert("state")
        nonAdditionalPropertyKeys.insert("rejectionReason")
        nonAdditionalPropertyKeys.insert("chainId")
        nonAdditionalPropertyKeys.insert("creationTime")
        nonAdditionalPropertyKeys.insert("updateTime")
        nonAdditionalPropertyKeys.insert("notes")
        nonAdditionalPropertyKeys.insert("primaryRoute")
        nonAdditionalPropertyKeys.insert("secondaryRoute")
        nonAdditionalPropertyKeys.insert("orderRoute")
        nonAdditionalPropertyKeys.insert("venueHoldingOrder")
        nonAdditionalPropertyKeys.insert("comissionCharged")
        nonAdditionalPropertyKeys.insert("exchangeOrderId")
        nonAdditionalPropertyKeys.insert("isSignificantShareHolder")
        nonAdditionalPropertyKeys.insert("isInsider")
        nonAdditionalPropertyKeys.insert("isLimitOffsetInDollar")
        nonAdditionalPropertyKeys.insert("userId")
        nonAdditionalPropertyKeys.insert("placementCommission")
        nonAdditionalPropertyKeys.insert("legs")
        nonAdditionalPropertyKeys.insert("strategyType")
        nonAdditionalPropertyKeys.insert("triggerStopPrice")
        nonAdditionalPropertyKeys.insert("orderGroupId")
        nonAdditionalPropertyKeys.insert("orderClass")
        nonAdditionalPropertyKeys.insert("isCrossZero")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}

