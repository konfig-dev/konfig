{
  "openapi": "3.0.2",
  "info": {
    "title": "Humanloop API",
    "description": "The Humanloop API allows you to interact with Humanloop from your product or service.\n\nYou can do this through HTTP requests from any language or via our official Python or TypeScript SDK.\n\nTo install the official [Python SDK](https://pypi.org/project/humanloop/), run the following command:\n\n```bash\npip install humanloop\n```\n\nTo install the official [TypeScript SDK](https://www.npmjs.com/package/humanloop), run the following command:\n\n```bash\nnpm i humanloop\n```\n\n---\n\nGuides and further details about key concepts can be found in [our docs](https://docs.humanloop.com/).",
    "version": "4.0.1"
  },
  "servers": [
    {
      "url": "https://api.humanloop.com/v4",
      "description": "Production server"
    }
  ],
  "paths": {
    "/completion": {
      "post": {
        "tags": [
          "Completions"
        ],
        "summary": "Create",
        "description": "Create a completion by providing details of the model configuration in the request.",
        "operationId": "Completions_create",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CompletionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CompletionResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/completion-deployed": {
      "post": {
        "tags": [
          "Completions"
        ],
        "summary": "Completion Deployed",
        "description": "Create a completion using the project's active deployment.\n\nThe active deployment can be a specific model configuration or an experiment.",
        "operationId": "Completions_createDeployed",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CompletionDeployedRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CompletionResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/completion-experiment": {
      "post": {
        "tags": [
          "Completions"
        ],
        "summary": "Completion Experiment",
        "description": "Create a completion for a specific experiment.",
        "operationId": "Completions_createExperiment",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CompletionExperimentRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CompletionResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/completion-model-config": {
      "post": {
        "tags": [
          "Completions"
        ],
        "summary": "Completion Model Config",
        "description": "Create a completion for a specific model configuration.",
        "operationId": "Completions_createModelConfig",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CompletionModelConfigRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CompletionResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/chat": {
      "post": {
        "tags": [
          "Chats"
        ],
        "summary": "Chat",
        "description": "Get a chat response by providing details of the model configuration in the request.",
        "operationId": "Chats_create",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/chat-deployed": {
      "post": {
        "tags": [
          "Chats"
        ],
        "summary": "Chat Deployed",
        "description": "Get a chat response using the project's active deployment.\n\nThe active deployment can be a specific model configuration or an experiment.",
        "operationId": "Chats_createDeployed",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatDeployedRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/chat-experiment": {
      "post": {
        "tags": [
          "Chats"
        ],
        "summary": "Chat Experiment",
        "description": "Get a chat response for a specific experiment.",
        "operationId": "Chats_createExperiment",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatExperimentRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/chat-model-config": {
      "post": {
        "tags": [
          "Chats"
        ],
        "summary": "Chat Model Config",
        "description": "Get chat response for a specific model configuration.",
        "operationId": "Chats_createModelConfig",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatModelConfigRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/logs": {
      "get": {
        "tags": [
          "Logs"
        ],
        "summary": "Get Logs",
        "description": "Retrieve paginated logs from the server.\n\nSorting and filtering are supported through query params.\nSee docstring of get_sorted_filtered_project_data_from_query_params for more details.",
        "operationId": "Logs_list",
        "parameters": [
          {
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project Id"
            },
            "name": "project_id",
            "in": "query"
          },
          {
            "required": false,
            "schema": {
              "type": "string",
              "title": "Search"
            },
            "name": "search",
            "in": "query"
          },
          {
            "required": false,
            "schema": {
              "type": "string",
              "title": "Metadata Search"
            },
            "name": "metadata_search",
            "in": "query"
          },
          {
            "required": false,
            "schema": {
              "type": "string",
              "format": "date",
              "title": "Start Date"
            },
            "name": "start_date",
            "in": "query"
          },
          {
            "required": false,
            "schema": {
              "type": "string",
              "format": "date",
              "title": "End Date"
            },
            "name": "end_date",
            "in": "query"
          },
          {
            "required": false,
            "schema": {
              "type": "integer",
              "title": "Size",
              "default": 50
            },
            "name": "size",
            "in": "query"
          },
          {
            "required": false,
            "schema": {
              "type": "integer",
              "title": "Page",
              "default": 0
            },
            "name": "page",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedData_LogResponse_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "post": {
        "tags": [
          "Logs"
        ],
        "summary": "Log",
        "description": "Log a datapoint or array of datapoints to your Humanloop project.",
        "operationId": "Logs_log",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "anyOf": [
                  {
                    "items": {
                      "$ref": "#/components/schemas/LogRequest"
                    },
                    "type": "array"
                  },
                  {
                    "$ref": "#/components/schemas/LogRequest"
                  }
                ],
                "title": "Log Request"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "anyOf": [
                    {
                      "items": {
                        "$ref": "#/components/schemas/CreateLogResponse"
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/CreateLogResponse"
                    }
                  ],
                  "title": "Response Logs Log"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "delete": {
        "tags": [
          "Logs"
        ],
        "summary": "Delete Logs",
        "operationId": "Logs_delete",
        "parameters": [
          {
            "required": false,
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array",
              "title": "Id"
            },
            "name": "id",
            "in": "query"
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "patch": {
        "tags": [
          "Logs"
        ],
        "summary": "Update By Reference Id",
        "description": "Update a logged datapoint by its reference ID.\n\nThe `reference_id` query parameter must be provided, and refers to the\n`reference_id` of a previously-logged datapoint.",
        "operationId": "Logs_updateByRef",
        "parameters": [
          {
            "description": "A unique string to reference the datapoint. Identifies the logged datapoint created with the same `reference_id`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Log reference ID",
              "description": "A unique string to reference the datapoint. Identifies the logged datapoint created with the same `reference_id`."
            },
            "name": "reference_id",
            "in": "query"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateLogRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LogResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/logs/{id}": {
      "patch": {
        "tags": [
          "Logs"
        ],
        "summary": "Update",
        "description": "Update a logged datapoint in your Humanloop project.",
        "operationId": "Logs_update",
        "parameters": [
          {
            "description": "String ID of logged datapoint to return. Starts with `data_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Log ID",
              "description": "String ID of logged datapoint to return. Starts with `data_`."
            },
            "name": "id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateLogRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LogResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/feedback": {
      "post": {
        "tags": [
          "Feedback"
        ],
        "summary": "Feedback",
        "description": "Submit an array of feedback for existing `data_ids`",
        "operationId": "Feedback_feedback",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "anyOf": [
                  {
                    "items": {
                      "$ref": "#/components/schemas/FeedbackRequest"
                    },
                    "type": "array"
                  },
                  {
                    "$ref": "#/components/schemas/FeedbackRequest"
                  }
                ],
                "title": "Feedback Request"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "anyOf": [
                    {
                      "items": {
                        "$ref": "#/components/schemas/FeedbackResponse"
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/FeedbackResponse"
                    }
                  ],
                  "title": "Response Feedback Feedback"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/projects": {
      "get": {
        "tags": [
          "Projects"
        ],
        "summary": "List",
        "description": "Get a paginated list of projects.",
        "operationId": "Projects_list",
        "parameters": [
          {
            "description": "Page offset for pagination.",
            "required": false,
            "schema": {
              "type": "integer",
              "title": "Page index",
              "description": "Page offset for pagination.",
              "default": 0
            },
            "name": "page",
            "in": "query"
          },
          {
            "description": "Page size for pagination. Number of projects to fetch.",
            "required": false,
            "schema": {
              "type": "integer",
              "title": "Page size",
              "description": "Page size for pagination. Number of projects to fetch.",
              "default": 10
            },
            "name": "size",
            "in": "query"
          },
          {
            "description": "Case-insensitive filter for project name.",
            "required": false,
            "schema": {
              "type": "string",
              "title": "Project name filter",
              "description": "Case-insensitive filter for project name."
            },
            "name": "filter",
            "in": "query"
          },
          {
            "description": "Case-insensitive filter for users in the project. This filter matches against both email address and name of users.",
            "required": false,
            "schema": {
              "type": "string",
              "title": "User filter",
              "description": "Case-insensitive filter for users in the project. This filter matches against both email address and name of users."
            },
            "name": "user_filter",
            "in": "query"
          },
          {
            "description": "Field to sort projects by",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/ProjectSortBy"
                }
              ],
              "title": "Sort by",
              "description": "Field to sort projects by",
              "default": "created_at"
            },
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Direction to sort by.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/SortOrder"
                }
              ],
              "title": "Sort order",
              "description": "Direction to sort by.",
              "default": "desc"
            },
            "name": "order",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedData_ProjectResponse_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "post": {
        "tags": [
          "Projects"
        ],
        "summary": "Create",
        "description": "Create a new project.",
        "operationId": "Projects_create",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateProjectRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/projects/{id}": {
      "get": {
        "tags": [
          "Projects"
        ],
        "summary": "Get",
        "description": "Get a specific project.",
        "operationId": "Projects_get",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`."
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "delete": {
        "tags": [
          "Projects"
        ],
        "summary": "Delete",
        "description": "Delete a specific project.",
        "operationId": "Projects_delete",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`."
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "patch": {
        "tags": [
          "Projects"
        ],
        "summary": "Update",
        "description": "Update a specific project.\n\nSet the project's active model config/experiment by passing either\n`active_experiment_id` or `active_model_config_id`.\nThese will be set to the Default environment unless a list of environments\nare also passed in specifically detailing which environments to assign the\nactive config or experiment.\n\nSet the feedback labels to be treated as positive user feedback used in\ncalculating top-level project metrics by passing a list of labels in\n`positive_labels`.",
        "operationId": "Projects_update",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`."
            },
            "name": "id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateProjectRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/projects/{id}/configs": {
      "get": {
        "tags": [
          "Projects"
        ],
        "summary": "List Configs",
        "description": "Get an array of configs associated to your project.",
        "operationId": "Projects_listConfigs",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`."
            },
            "name": "id",
            "in": "path"
          },
          {
            "required": false,
            "schema": {
              "type": "boolean",
              "title": "Evaluation Aggregates"
            },
            "name": "evaluation_aggregates",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/ProjectConfigResponse"
                  },
                  "type": "array",
                  "title": "Response Projects Listconfigs"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/projects/{id}/active-config": {
      "get": {
        "tags": [
          "Projects"
        ],
        "summary": "Get Active Config",
        "description": "Retrieves a config to use to execute your model.\n\nA config will be selected based on the project's\nactive config/experiment settings.",
        "operationId": "Projects_getActiveConfig",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`."
            },
            "name": "id",
            "in": "path"
          },
          {
            "description": "Name for the environment. E.g. 'producton'. If not provided, will return the active config for the default environment.",
            "required": false,
            "schema": {
              "type": "string",
              "title": "Environment name",
              "description": "Name for the environment. E.g. 'producton'. If not provided, will return the active config for the default environment."
            },
            "name": "environment",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetModelConfigResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "delete": {
        "tags": [
          "Projects"
        ],
        "summary": "Deactivate Config",
        "description": "Remove the project's active config, if set.\n\nThis has no effect if the project does not have an active model config set.",
        "operationId": "Projects_deactivateConfig",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`."
            },
            "name": "id",
            "in": "path"
          },
          {
            "description": "Name for the environment. E.g. 'production'. If not provided, will delete the active config for the default environment.",
            "required": false,
            "schema": {
              "type": "string",
              "title": "Environment name",
              "description": "Name for the environment. E.g. 'production'. If not provided, will delete the active config for the default environment."
            },
            "name": "environment",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/projects/{id}/active-experiment": {
      "delete": {
        "tags": [
          "Projects"
        ],
        "summary": "Deactivate Experiment",
        "description": "Remove the project's active experiment, if set.\n\nThis has no effect if the project does not have an active experiment set.",
        "operationId": "Projects_deactivateExperiment",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`."
            },
            "name": "id",
            "in": "path"
          },
          {
            "description": "Name for the environment. E.g. 'producton'. If not provided, will return the experiment for the default environment.",
            "required": false,
            "schema": {
              "type": "string",
              "title": "Environment name",
              "description": "Name for the environment. E.g. 'producton'. If not provided, will return the experiment for the default environment."
            },
            "name": "environment",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/projects/{id}/feedback-types": {
      "post": {
        "tags": [
          "Projects"
        ],
        "summary": "Create Feedback Type",
        "operationId": "Projects_createFeedbackType",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`."
            },
            "name": "id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FeedbackTypeRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FeedbackTypeModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "patch": {
        "tags": [
          "Projects"
        ],
        "summary": "Update Feedback Types",
        "description": "Update feedback types.\n\nAllows enabling the available feedback types and setting status of\nfeedback types/categorical values.\n\nThis behaves like an upsert; any feedback categorical values that do not\nalready exist in the project will be created.",
        "operationId": "Projects_updateFeedbackTypes",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`."
            },
            "name": "id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/FeedbackTypeRequest"
                },
                "type": "array",
                "title": "Feedback Types"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FeedbackTypes"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/projects/{id}/export": {
      "post": {
        "tags": [
          "Projects"
        ],
        "summary": "Export",
        "description": "Export all logged datapoints associated to your project.\n\nResults are paginated and sorts the datapoints based on `created_at` in\ndescending order.",
        "operationId": "Projects_export",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`."
            },
            "name": "id",
            "in": "path"
          },
          {
            "description": "Page offset for pagination.",
            "required": false,
            "schema": {
              "type": "integer",
              "title": "Page index",
              "description": "Page offset for pagination.",
              "default": 0
            },
            "name": "page",
            "in": "query"
          },
          {
            "description": "Page size for pagination. Number of logs to export.",
            "required": false,
            "schema": {
              "type": "integer",
              "title": "Page size",
              "description": "Page size for pagination. Number of logs to export.",
              "default": 10
            },
            "name": "size",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedData_LogResponse_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/projects/{id}/deployed-configs": {
      "get": {
        "tags": [
          "Projects"
        ],
        "summary": "List Deployed Configs",
        "description": "Get an array of environments with the deployed configs associated to your project.",
        "operationId": "Projects_listDeployedConfigs",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`."
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/EnvironmentProjectConfigResponse"
                  },
                  "type": "array",
                  "title": "Response Projects Listdeployedconfigs"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/projects/{project_id}/deploy-config": {
      "patch": {
        "tags": [
          "Projects"
        ],
        "summary": "Deploy Config",
        "description": "Deploy a model config to an environment.\n\nIf the environment already has a model config deployed, it will be replaced.",
        "operationId": "Projects_deployConfig",
        "parameters": [
          {
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project Id"
            },
            "name": "project_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EnvironmentProjectConfigRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/EnvironmentProjectConfigResponse"
                  },
                  "type": "array",
                  "title": "Response Projects Deployconfig"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/projects/{project_id}/deployed-config/{environment_id}": {
      "delete": {
        "tags": [
          "Projects"
        ],
        "summary": "Delete Deployed Config",
        "description": "Remove the model config deployed to environment.\n\nThis has no effect if the project does not have an active model config set.",
        "operationId": "Projects_deleteDeployedConfig",
        "parameters": [
          {
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project Id"
            },
            "name": "project_id",
            "in": "path"
          },
          {
            "required": true,
            "schema": {
              "type": "string",
              "title": "Environment Id"
            },
            "name": "environment_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/model-configs": {
      "post": {
        "tags": [
          "Model Configs"
        ],
        "summary": "Register",
        "description": "Register a model config to a project and optionally add it to an\nexperiment.\n\nIf the project name provided does not exist, a new project will be created\nautomatically.\n\nIf an experiment name is provided, the specified experiment must already\nexist. Otherwise, an error will be raised.\n\nIf the model config is the first to be associated to the project, it will\nbe set as the active model config.",
        "operationId": "ModelConfigs_register",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ProjectModelConfigRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectConfigResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/model-configs/{id}": {
      "get": {
        "tags": [
          "Model Configs"
        ],
        "summary": "Get",
        "description": "Get a specific model config by ID.",
        "operationId": "ModelConfigs_get",
        "parameters": [
          {
            "description": "String ID of the model config. Starts with `config_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Model config ID",
              "description": "String ID of the model config. Starts with `config_`."
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelConfigResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/model-configs/{id}/export": {
      "post": {
        "tags": [
          "Model Configs"
        ],
        "summary": "Export by ID",
        "description": "Export a model config to a .prompt file by ID.",
        "operationId": "ModelConfigs_export",
        "parameters": [
          {
            "description": "String ID of the model config. Starts with `config_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Model config ID",
              "description": "String ID of the model config. Starts with `config_`."
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "title": "Response Modelconfigs Export"
                }
              },
              "text/prompt": {
                "schema": {
                  "type": "string"
                },
                "example": "---\nmodel: gpt-4\ntemperature: 0.3\nmax_tokens: -1\nprovider: openai\nendpoint: chat\ntools: []\n---\n\n<system>\n  You are a friendly assistant.\n</system>"
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/model-configs/serialize": {
      "post": {
        "tags": [
          "Model Configs"
        ],
        "summary": "Serialize",
        "description": "Serialize a model config to a .prompt file format.",
        "operationId": "ModelConfigs_serialize",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "anyOf": [
                  {
                    "$ref": "#/components/schemas/ModelConfigChatRequest"
                  },
                  {
                    "$ref": "#/components/schemas/ModelConfigCompletionRequest"
                  }
                ],
                "title": "Config Request"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "title": "Response Modelconfigs Serialize"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/model-configs/deserialize": {
      "post": {
        "tags": [
          "Model Configs"
        ],
        "summary": "Deserialize",
        "description": "Deserialize a model config from a .prompt file format.",
        "operationId": "ModelConfigs_deserialize",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_ModelConfigs_deserialize"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelConfigResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/projects/{project_id}/experiments": {
      "get": {
        "tags": [
          "Experiments"
        ],
        "summary": "List ",
        "description": "Get an array of experiments associated to your project.",
        "operationId": "Experiments_list",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`."
            },
            "name": "project_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/ExperimentResponse"
                  },
                  "type": "array",
                  "title": "Response Experiments List"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "post": {
        "tags": [
          "Experiments"
        ],
        "summary": "Create",
        "description": "Create an experiment for your project.\n\nYou can optionally specify IDs of your project's model configs to include\nin the experiment, along with a set of labels to consider as positive feedback\nand whether the experiment should be set as active.",
        "operationId": "Experiments_create",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`."
            },
            "name": "project_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateExperimentRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExperimentResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/experiments/{experiment_id}": {
      "delete": {
        "tags": [
          "Experiments"
        ],
        "summary": "Delete",
        "description": "Delete the experiment with the specified ID.",
        "operationId": "Experiments_delete",
        "parameters": [
          {
            "description": "String ID of experiment. Starts with `exp_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Experiment ID",
              "description": "String ID of experiment. Starts with `exp_`."
            },
            "name": "experiment_id",
            "in": "path"
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "patch": {
        "tags": [
          "Experiments"
        ],
        "summary": "Update",
        "description": "Update your experiment, including registering and de-registering\nmodel configs.",
        "operationId": "Experiments_update",
        "parameters": [
          {
            "description": "String ID of experiment. Starts with `exp_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Experiment ID",
              "description": "String ID of experiment. Starts with `exp_`."
            },
            "name": "experiment_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateExperimentRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExperimentResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/experiments/{experiment_id}/model-config": {
      "get": {
        "tags": [
          "Experiments"
        ],
        "summary": "Sample",
        "description": "Samples a model config from the experiment's active model configs.",
        "operationId": "Experiments_sample",
        "parameters": [
          {
            "description": "String ID of experiment. Starts with `exp_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Experiment ID",
              "description": "String ID of experiment. Starts with `exp_`."
            },
            "name": "experiment_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetModelConfigResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/sessions": {
      "get": {
        "tags": [
          "Sessions"
        ],
        "summary": "List ",
        "description": "Get a page of sessions.",
        "operationId": "Sessions_list",
        "parameters": [
          {
            "description": "String ID of project to return sessions for. Sessions that contain any datapoints associated to this project will be returned. Starts with `pr_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project ID",
              "description": "String ID of project to return sessions for. Sessions that contain any datapoints associated to this project will be returned. Starts with `pr_`."
            },
            "name": "project_id",
            "in": "query"
          },
          {
            "description": "Page to fetch. Starts from 1.",
            "required": false,
            "schema": {
              "type": "integer",
              "title": "Page number",
              "description": "Page to fetch. Starts from 1.",
              "default": 1
            },
            "name": "page",
            "in": "query"
          },
          {
            "description": "Number of sessions to retrieve.",
            "required": false,
            "schema": {
              "type": "integer",
              "title": "Page size",
              "description": "Number of sessions to retrieve.",
              "default": 10
            },
            "name": "size",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedData_SessionResponse_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "post": {
        "tags": [
          "Sessions"
        ],
        "summary": "Create",
        "description": "Create a new session.\n\nReturns a session ID that can be used to log datapoints to the session.",
        "operationId": "Sessions_create",
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateSessionResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/sessions/{id}": {
      "get": {
        "tags": [
          "Sessions"
        ],
        "summary": "Get",
        "description": "Get a session by ID.",
        "operationId": "Sessions_get",
        "parameters": [
          {
            "description": "String ID of session to return. Starts with `sesh_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Session ID",
              "description": "String ID of session to return. Starts with `sesh_`."
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SessionResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/evaluators": {
      "get": {
        "tags": [
          "Evaluators"
        ],
        "summary": "List",
        "description": "Get all evaluators within your organization.",
        "operationId": "Evaluators_list",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/EvaluatorResponse"
                  },
                  "type": "array",
                  "title": "Response Evaluators List"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "post": {
        "tags": [
          "Evaluators"
        ],
        "summary": "Create",
        "description": "Create an evaluator within your organization.",
        "operationId": "Evaluators_create",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateEvaluatorRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EvaluatorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/evaluators/{id}": {
      "get": {
        "tags": [
          "Evaluators"
        ],
        "summary": "Get",
        "description": "Get an evaluator within your organization.",
        "operationId": "Evaluators_get",
        "parameters": [
          {
            "required": true,
            "schema": {
              "type": "string",
              "title": "Id"
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EvaluatorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "delete": {
        "tags": [
          "Evaluators"
        ],
        "summary": "Delete",
        "description": "Delete an evaluator within your organization.",
        "operationId": "Evaluators_delete",
        "parameters": [
          {
            "required": true,
            "schema": {
              "type": "string",
              "title": "Id"
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "patch": {
        "tags": [
          "Evaluators"
        ],
        "summary": "Update",
        "description": "Update an evaluator within your organization.",
        "operationId": "Evaluators_update",
        "parameters": [
          {
            "required": true,
            "schema": {
              "type": "string",
              "title": "Id"
            },
            "name": "id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateEvaluatorRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EvaluatorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/datapoints/{id}": {
      "get": {
        "tags": [
          "Datapoints"
        ],
        "summary": "Get",
        "description": "Get a datapoint by ID.",
        "operationId": "Datapoints_get",
        "parameters": [
          {
            "description": "String ID of datapoint. Starts with `evtc_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Datapoint ID",
              "description": "String ID of datapoint. Starts with `evtc_`."
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DatapointResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "patch": {
        "tags": [
          "Datapoints"
        ],
        "summary": "Update",
        "description": "Edit the input, messages and criteria fields of a datapoint.\nThe fields passed in the request are the ones edited.\n\nPassing `null` as a value for a field will delete that field. In order to\nsignify not changing a field, it should be omitted from the request body.",
        "operationId": "Datapoints_update",
        "parameters": [
          {
            "description": "String ID of datapoint. Starts with `evtc_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Datapoint ID",
              "description": "String ID of datapoint. Starts with `evtc_`."
            },
            "name": "id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateDatapointRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DatapointResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/datapoints": {
      "delete": {
        "tags": [
          "Datapoints"
        ],
        "summary": "Delete",
        "description": "Delete a list of testsets by their IDs.",
        "operationId": "Datapoints_delete",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "title": "Request"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/projects/{project_id}/datasets": {
      "get": {
        "tags": [
          "Datasets"
        ],
        "summary": "List For Project",
        "description": "Get all datasets for a project.",
        "operationId": "Datasets_listAllForProject",
        "parameters": [
          {
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project Id"
            },
            "name": "project_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/DatasetResponse"
                  },
                  "type": "array",
                  "title": "Response Datasets Listallforproject"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "post": {
        "tags": [
          "Datasets"
        ],
        "summary": "Create",
        "description": "Create a new dataset for a project.",
        "operationId": "Datasets_create",
        "parameters": [
          {
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project Id"
            },
            "name": "project_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateDatasetRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DatasetResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/datasets/{id}": {
      "get": {
        "tags": [
          "Datasets"
        ],
        "summary": "Get",
        "description": "Get a single dataset by ID.",
        "operationId": "Datasets_get",
        "parameters": [
          {
            "description": "String ID of dataset. Starts with `evts_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Dataset ID",
              "description": "String ID of dataset. Starts with `evts_`."
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DatasetResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "delete": {
        "tags": [
          "Datasets"
        ],
        "summary": "Delete",
        "description": "Delete a dataset by ID.",
        "operationId": "Datasets_delete",
        "parameters": [
          {
            "description": "String ID of dataset. Starts with `evts_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Dataset ID",
              "description": "String ID of dataset. Starts with `evts_`."
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DatasetResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "patch": {
        "tags": [
          "Datasets"
        ],
        "summary": "Update",
        "description": "Update a testset by ID.",
        "operationId": "Datasets_update",
        "parameters": [
          {
            "description": "String ID of testset. Starts with `evts_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Dataset ID",
              "description": "String ID of testset. Starts with `evts_`."
            },
            "name": "id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateDatasetRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DatasetResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/datasets/{dataset_id}/datapoints": {
      "get": {
        "tags": [
          "Datasets"
        ],
        "summary": "Datapoints",
        "description": "Get datapoints for a dataset.",
        "operationId": "Datasets_listDatapoints",
        "parameters": [
          {
            "description": "String ID of dataset. Starts with `evts_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Dataset ID",
              "description": "String ID of dataset. Starts with `evts_`."
            },
            "name": "dataset_id",
            "in": "path"
          },
          {
            "required": false,
            "schema": {
              "type": "integer",
              "title": "Page",
              "default": 0
            },
            "name": "page",
            "in": "query"
          },
          {
            "required": false,
            "schema": {
              "type": "integer",
              "title": "Size",
              "default": 50
            },
            "name": "size",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedData_DatapointResponse_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "post": {
        "tags": [
          "Datasets"
        ],
        "summary": "Create Datapoint",
        "description": "Create a new testcase for a testset.",
        "operationId": "Datasets_createDatapoint",
        "parameters": [
          {
            "description": "String ID of dataset. Starts with `evts_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Dataset ID",
              "description": "String ID of dataset. Starts with `evts_`."
            },
            "name": "dataset_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "anyOf": [
                  {
                    "$ref": "#/components/schemas/CreateDatapointsByLogsRequest"
                  },
                  {
                    "$ref": "#/components/schemas/CreateDatapointRequest"
                  },
                  {
                    "items": {
                      "$ref": "#/components/schemas/CreateDatapointRequest"
                    },
                    "type": "array"
                  }
                ],
                "title": "Request"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/DatapointResponse"
                  },
                  "type": "array",
                  "title": "Response Datasets Createdatapoint"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/evaluations/{id}": {
      "get": {
        "tags": [
          "Evaluations"
        ],
        "summary": "Get",
        "description": "Get evaluation by ID.",
        "operationId": "Evaluations_get",
        "parameters": [
          {
            "description": "String ID of evaluation run. Starts with `ev_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Evaluation ID",
              "description": "String ID of evaluation run. Starts with `ev_`."
            },
            "name": "id",
            "in": "path"
          },
          {
            "description": "Whether to include evaluator aggregates in the response.",
            "required": false,
            "schema": {
              "type": "boolean",
              "title": "Evaluator aggregates",
              "description": "Whether to include evaluator aggregates in the response."
            },
            "name": "evaluator_aggregates",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EvaluationResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/evaluations/{id}/datapoints": {
      "get": {
        "tags": [
          "Evaluations"
        ],
        "summary": "List Datapoints",
        "description": "Get testcases by evaluation ID.",
        "operationId": "Evaluations_listDatapoints",
        "parameters": [
          {
            "description": "String ID of evaluation. Starts with `ev_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Evaluation ID",
              "description": "String ID of evaluation. Starts with `ev_`."
            },
            "name": "id",
            "in": "path"
          },
          {
            "description": "Page to fetch. Starts from 1.",
            "required": false,
            "schema": {
              "type": "integer",
              "title": "Page number",
              "description": "Page to fetch. Starts from 1.",
              "default": 1
            },
            "name": "page",
            "in": "query"
          },
          {
            "description": "Number of evaluation results to retrieve.",
            "required": false,
            "schema": {
              "type": "integer",
              "title": "Page size",
              "description": "Number of evaluation results to retrieve.",
              "default": 10
            },
            "name": "size",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedData_EvaluationDatapointSnapshotResponse_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/projects/{project_id}/evaluations": {
      "get": {
        "tags": [
          "Evaluations"
        ],
        "summary": "List For Project",
        "description": "Get all the evaluations associated with your project.",
        "operationId": "Evaluations_listAllForProject",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`."
            },
            "name": "project_id",
            "in": "path"
          },
          {
            "description": "Whether to include evaluator aggregates in the response.",
            "required": false,
            "schema": {
              "type": "boolean",
              "title": "Evaluator aggregates",
              "description": "Whether to include evaluator aggregates in the response."
            },
            "name": "evaluator_aggregates",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/EvaluationResponse"
                  },
                  "type": "array",
                  "title": "Response Evaluations Listallforproject"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "post": {
        "tags": [
          "Evaluations"
        ],
        "summary": "Create",
        "description": "Create an evaluation.",
        "operationId": "Evaluations_create",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`."
            },
            "name": "project_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateEvaluationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EvaluationResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/evaluations/{evaluation_run_external_id}/result": {
      "post": {
        "tags": [
          "Evaluations"
        ],
        "summary": "Log Result",
        "description": "Log an evaluation result to an evaluation run.\n\nThe run must have status 'running' and the `evaluator_id` of the result must be one of the `evaluator_id`s associated with the run.",
        "operationId": "Evaluations_logResult",
        "parameters": [
          {
            "description": "ID of the evaluation run. Starts with `evrun_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Evaluation run ID",
              "description": "ID of the evaluation run. Starts with `evrun_`."
            },
            "name": "evaluation_run_external_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateEvaluationResultLogRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EvaluationResultResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/evaluations/{id}/status": {
      "patch": {
        "tags": [
          "Evaluations"
        ],
        "summary": "Update Status",
        "description": "Update the status of an evaluation run.\n\nCan only be used to update the status of an evaluation run that uses external or human evaluators.\nThe evaluation must currently have status 'running' if swithcing to completed, or it must have status\n'completed' if switching back to 'running'.",
        "operationId": "Evaluations_updateStatus",
        "parameters": [
          {
            "description": "String ID of evaluation run. Starts with `ev_`.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Evaluation ID",
              "description": "String ID of evaluation run. Starts with `ev_`."
            },
            "name": "id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateEvaluationStatusRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EvaluationResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/projects/{project_id}/finetunes": {
      "get": {
        "tags": [
          "Finetunes"
        ],
        "summary": "List ",
        "description": "Get a list of all fine-tuned models associated to a given project.",
        "operationId": "Finetunes_listAllForProject",
        "parameters": [
          {
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project Id"
            },
            "name": "project_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/FinetuneResponse"
                  },
                  "type": "array",
                  "title": "Response Finetunes Listallforproject"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      },
      "post": {
        "tags": [
          "Finetunes"
        ],
        "summary": "Create",
        "description": "Trigger the fine-tuning process for a specific base model and data snapshot.",
        "operationId": "Finetunes_create",
        "parameters": [
          {
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project Id"
            },
            "name": "project_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FinetuneRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FinetuneResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/projects/{project_id}/finetunes/summary": {
      "post": {
        "tags": [
          "Finetunes"
        ],
        "summary": "Summarize",
        "description": "Checks data for errors and generates finetune data summary.\n\nDoes not actually trigger the finetuning process or persist the data.",
        "operationId": "Finetunes_summary",
        "parameters": [
          {
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project Id"
            },
            "name": "project_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FinetuneRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FinetuneDataSummary"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    },
    "/finetunes/{id}": {
      "patch": {
        "tags": [
          "Finetunes"
        ],
        "summary": "Update",
        "description": "Update user-specified attributes of the specified finetuned models.",
        "operationId": "Finetunes_update",
        "parameters": [
          {
            "required": true,
            "schema": {
              "type": "string",
              "title": "Id"
            },
            "name": "id",
            "in": "path"
          },
          {
            "required": true,
            "schema": {
              "type": "string",
              "title": "Project Id"
            },
            "name": "project_id",
            "in": "query"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateFinetuneRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FinetuneResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "APIKeyHeader": []
          }
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "AgentConfigRequest": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Model config name",
            "description": "A friendly display name for the model config. If not provided, a name will be generated."
          },
          "description": {
            "type": "string",
            "title": "Model config description",
            "description": "A description of the model config."
          },
          "type": {
            "type": "string",
            "enum": [
              "agent"
            ],
            "title": "Type"
          },
          "agent_class": {
            "type": "string",
            "title": "Agent class",
            "description": "Class of the agent."
          },
          "tools": {
            "items": {
              "$ref": "#/components/schemas/ToolConfigRequest"
            },
            "type": "array",
            "title": "Tools",
            "description": "Tools to associate with the agent."
          },
          "model_config": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelConfigRequest"
              }
            ],
            "title": "Model config",
            "description": "Model config to associate with the agent."
          },
          "other": {
            "type": "object",
            "title": "Other parameters",
            "description": "Other parameters that define the config."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "type",
          "agent_class",
          "model_config"
        ],
        "title": "AgentConfigRequest",
        "description": "Base config request for all config types.\n\nContains fields that are common to all config types. Specifically, `name`\nand `description` that are saved at the organization-level."
      },
      "AgentConfigResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Config ID",
            "description": "String ID of config. Starts with `config_`."
          },
          "other": {
            "type": "object",
            "title": "Other parameters",
            "description": "Other parameters that define the config."
          },
          "type": {
            "type": "string",
            "enum": [
              "agent"
            ],
            "title": "Type"
          },
          "name": {
            "type": "string",
            "title": "Config name",
            "description": "Name of config."
          },
          "description": {
            "type": "string",
            "title": "Config description",
            "description": "Description of config."
          },
          "agent_class": {
            "type": "string",
            "title": "Agent class",
            "description": "Class of the agent."
          },
          "tools": {
            "items": {
              "$ref": "#/components/schemas/ToolConfigRequest"
            },
            "type": "array",
            "title": "Tools",
            "description": "Tools associated with the agent.",
            "default": []
          },
          "model_config": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelConfigRequest"
              }
            ],
            "title": "Model config",
            "description": "Model config associated with the agent."
          }
        },
        "type": "object",
        "required": [
          "id",
          "type",
          "name",
          "agent_class",
          "model_config"
        ],
        "title": "AgentConfigResponse"
      },
      "BaseMetricResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Metric ID",
            "description": "ID of the metric. Starts with 'metric_'."
          },
          "name": {
            "type": "string",
            "title": "Metric name",
            "description": "The name of the metric."
          },
          "description": {
            "type": "string",
            "title": "Metric description",
            "description": "A description of what the metric measures."
          },
          "code": {
            "type": "string",
            "title": "Metric code",
            "description": "Python code used to calculate a metric value on each logged datapoint."
          },
          "default": {
            "type": "boolean",
            "title": "Metric default flag",
            "description": "Whether the metric is a global default metric. Metrics with this flag enabled cannot be deleted or modified."
          },
          "active": {
            "type": "boolean",
            "title": "Metric active flag",
            "description": "If enabled, the metric is calculated for every logged datapoint."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "description",
          "code",
          "default",
          "active",
          "created_at",
          "updated_at"
        ],
        "title": "BaseMetricResponse"
      },
      "Body_ModelConfigs_deserialize": {
        "properties": {
          "config": {
            "type": "string",
            "title": "Config"
          }
        },
        "type": "object",
        "required": [
          "config"
        ],
        "title": "Body_ModelConfigs_deserialize"
      },
      "CategoricalFeedbackLabel": {
        "properties": {
          "value": {
            "type": "string",
            "title": "Label value"
          },
          "sentiment": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LabelSentiment"
              }
            ],
            "title": "Feedback label sentiment",
            "description": "Whether the feedback sentiment is positive or negative."
          }
        },
        "type": "object",
        "required": [
          "value",
          "sentiment"
        ],
        "title": "CategoricalFeedbackLabel"
      },
      "ChatDataResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Data ID",
            "description": "Unique ID for the model inputs and output logged to Humanloop. Use this when recording feedback later."
          },
          "index": {
            "type": "integer",
            "title": "Sample index",
            "description": "The index for the sampled generation for a given input. The num_samples request parameter controls how many samples are generated."
          },
          "output": {
            "type": "string",
            "title": "Sanitized output text",
            "description": "Output text returned from the provider model with leading and trailing whitespaces stripped."
          },
          "raw_output": {
            "type": "string",
            "title": "Provider's output text",
            "description": "Raw output text returned from the provider model."
          },
          "inputs": {
            "type": "object",
            "title": "Inputs",
            "description": "The inputs passed to the chat template."
          },
          "finish_reason": {
            "type": "string",
            "title": "Finish reason",
            "description": "Why the generation ended. One of 'stop' (indicating a stop token was encountered), or 'length' (indicating the max tokens limit has been reached), or 'tool_call' (indicating that the model has chosen to call a tool - in which case the tool_call parameter of the response will be populated). It will be set as null for the intermediary responses during a stream, and will only be set as non-null for the final streamed token."
          },
          "model_config_id": {
            "type": "string",
            "title": "The ID of your model configuration",
            "description": "The model configuration used to create the generation."
          },
          "tool_results": {
            "items": {
              "$ref": "#/components/schemas/ToolResultResponse"
            },
            "type": "array",
            "title": "Tool results",
            "description": "Results of any tools run during the generation."
          },
          "messages": {
            "items": {
              "$ref": "#/components/schemas/ChatMessage"
            },
            "type": "array",
            "title": "Messages",
            "description": "The messages passed to the to provider chat endpoint."
          },
          "tool_call": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FunctionTool"
              }
            ],
            "title": "Tool call",
            "description": "JSON definition of the tool to call and the corresponding argument values. Will be populated when finish_reason='tool_call'.",
            "deprecated": true
          },
          "tool_calls": {
            "items": {
              "$ref": "#/components/schemas/ToolCall"
            },
            "type": "array",
            "title": "Tool call",
            "description": "JSON definition of the tools to call and the corresponding argument values. Will be populated when finish_reason='tool_call'."
          },
          "output_message": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChatMessage"
              }
            ],
            "title": "Output message",
            "description": "The message returned by the provider."
          }
        },
        "type": "object",
        "required": [
          "id",
          "index",
          "output",
          "raw_output",
          "model_config_id",
          "output_message"
        ],
        "title": "ChatDataResponse",
        "description": "Overwrite DataResponse for chat."
      },
      "ChatDeployedRequest": {
        "properties": {
          "project": {
            "type": "string",
            "title": "Project name",
            "description": "Unique project name. If no project exists with this name, a new project will be created."
          },
          "project_id": {
            "type": "string",
            "title": "Project ID",
            "description": "Unique ID of a project to associate to the log. Either this or `project` must be provided."
          },
          "session_id": {
            "type": "string",
            "title": "Session ID",
            "description": "ID of the session to associate the datapoint."
          },
          "session_reference_id": {
            "type": "string",
            "title": "Session Reference ID",
            "description": "A unique string identifying the session to associate the datapoint to. Allows you to log multiple datapoints to a session (using an ID kept by your internal systems) by passing the same `session_reference_id` in subsequent log requests. Specify at most one of this or `session_id`."
          },
          "parent_id": {
            "type": "string",
            "title": "Parent ID",
            "description": "ID associated to the parent datapoint in a session."
          },
          "parent_reference_id": {
            "type": "string",
            "title": "Parent Reference ID",
            "description": "A unique string identifying the previously-logged parent datapoint in a session. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a prior log request. Specify at most one of this or `parent_id`. Note that this cannot refer to a datapoint being logged in the same request."
          },
          "inputs": {
            "type": "object",
            "title": "Inputs",
            "description": "The inputs passed to the prompt template.",
            "default": {}
          },
          "source": {
            "type": "string",
            "title": "Source",
            "description": "Identifies where the model was called from."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Any additional metadata to record."
          },
          "source_datapoint_id": {
            "type": "string",
            "title": "Source datapoint ID",
            "description": "ID of the source datapoint if this is a log derived from a datapoint in a dataset."
          },
          "messages": {
            "items": {
              "$ref": "#/components/schemas/ChatMessage"
            },
            "type": "array",
            "title": "Messages",
            "description": "The messages passed to the to provider chat endpoint."
          },
          "provider_api_keys": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ProviderApiKeys"
              }
            ],
            "title": "Provider API Keys",
            "description": "API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization."
          },
          "num_samples": {
            "type": "integer",
            "title": "Number of samples",
            "description": "The number of chat responses.",
            "default": 1
          },
          "stream": {
            "type": "boolean",
            "title": "Whether to stream partial results",
            "description": "If true, tokens will be sent as data-only server-sent events. If num_samples > 1, samples are streamed back independently.",
            "default": false
          },
          "user": {
            "type": "string",
            "title": "End-user identifier",
            "description": "End-user ID passed through to provider call."
          },
          "tool_choice": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "none"
                ]
              },
              {
                "type": "string",
                "enum": [
                  "auto"
                ]
              },
              {
                "$ref": "#/components/schemas/ToolChoice"
              }
            ],
            "title": "Tool choice",
            "description": "Controls how the model uses tools. The following options are supported: 'none' forces the model to not call a tool; the default when no tools are provided as part of the model config. 'auto' the model can decide to call one of the provided tools; the default when tools are provided as part of the model config. Providing {'type': 'function', 'function': {name': <TOOL_NAME>}} forces the model to use the named function."
          },
          "tool_call": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              }
            ],
            "title": "Tool call",
            "description": "NB: Deprecated with new tool_choice. Controls how the model uses tools. The following options are supported: 'none' forces the model to not call a tool; the default when no tools are provided as part of the model config. 'auto' the model can decide to call one of the provided tools; the default when tools are provided as part of the model config. Providing {'name': <TOOL_NAME>} forces the model to use the provided tool of the same name.",
            "deprecated": true
          },
          "seed": {
            "type": "integer",
            "title": "Seed",
            "description": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed."
          },
          "response_format": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ResponseFormat"
              }
            ],
            "title": "Response format",
            "description": "The format of the response. Only type json_object is currently supported for chat."
          },
          "environment": {
            "type": "string",
            "title": "Environment name",
            "description": "The environment name used to create a chat response. If not specified, the default environment will be used."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "messages"
        ],
        "title": "ChatDeployedRequest",
        "description": "Chat request for active deployment."
      },
      "ChatExperimentRequest": {
        "properties": {
          "project": {
            "type": "string",
            "title": "Project name",
            "description": "Unique project name. If no project exists with this name, a new project will be created."
          },
          "project_id": {
            "type": "string",
            "title": "Project ID",
            "description": "Unique ID of a project to associate to the log. Either this or `project` must be provided."
          },
          "session_id": {
            "type": "string",
            "title": "Session ID",
            "description": "ID of the session to associate the datapoint."
          },
          "session_reference_id": {
            "type": "string",
            "title": "Session Reference ID",
            "description": "A unique string identifying the session to associate the datapoint to. Allows you to log multiple datapoints to a session (using an ID kept by your internal systems) by passing the same `session_reference_id` in subsequent log requests. Specify at most one of this or `session_id`."
          },
          "parent_id": {
            "type": "string",
            "title": "Parent ID",
            "description": "ID associated to the parent datapoint in a session."
          },
          "parent_reference_id": {
            "type": "string",
            "title": "Parent Reference ID",
            "description": "A unique string identifying the previously-logged parent datapoint in a session. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a prior log request. Specify at most one of this or `parent_id`. Note that this cannot refer to a datapoint being logged in the same request."
          },
          "inputs": {
            "type": "object",
            "title": "Inputs",
            "description": "The inputs passed to the prompt template.",
            "default": {}
          },
          "source": {
            "type": "string",
            "title": "Source",
            "description": "Identifies where the model was called from."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Any additional metadata to record."
          },
          "source_datapoint_id": {
            "type": "string",
            "title": "Source datapoint ID",
            "description": "ID of the source datapoint if this is a log derived from a datapoint in a dataset."
          },
          "messages": {
            "items": {
              "$ref": "#/components/schemas/ChatMessage"
            },
            "type": "array",
            "title": "Messages",
            "description": "The messages passed to the to provider chat endpoint."
          },
          "provider_api_keys": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ProviderApiKeys"
              }
            ],
            "title": "Provider API Keys",
            "description": "API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization."
          },
          "num_samples": {
            "type": "integer",
            "title": "Number of samples",
            "description": "The number of chat responses, where each chat response will use a model configuration sampled from the experiment.",
            "default": 1
          },
          "stream": {
            "type": "boolean",
            "title": "Whether to stream partial results",
            "description": "If true, tokens will be sent as data-only server-sent events. If num_samples > 1, samples are streamed back independently.",
            "default": false
          },
          "user": {
            "type": "string",
            "title": "End-user identifier",
            "description": "End-user ID passed through to provider call."
          },
          "tool_choice": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "none"
                ]
              },
              {
                "type": "string",
                "enum": [
                  "auto"
                ]
              },
              {
                "$ref": "#/components/schemas/ToolChoice"
              }
            ],
            "title": "Tool choice",
            "description": "Controls how the model uses tools. The following options are supported: 'none' forces the model to not call a tool; the default when no tools are provided as part of the model config. 'auto' the model can decide to call one of the provided tools; the default when tools are provided as part of the model config. Providing {'type': 'function', 'function': {name': <TOOL_NAME>}} forces the model to use the named function."
          },
          "tool_call": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              }
            ],
            "title": "Tool call",
            "description": "NB: Deprecated with new tool_choice. Controls how the model uses tools. The following options are supported: 'none' forces the model to not call a tool; the default when no tools are provided as part of the model config. 'auto' the model can decide to call one of the provided tools; the default when tools are provided as part of the model config. Providing {'name': <TOOL_NAME>} forces the model to use the provided tool of the same name.",
            "deprecated": true
          },
          "seed": {
            "type": "integer",
            "title": "Seed",
            "description": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed."
          },
          "response_format": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ResponseFormat"
              }
            ],
            "title": "Response format",
            "description": "The format of the response. Only type json_object is currently supported for chat."
          },
          "experiment_id": {
            "type": "string",
            "title": "Experiment ID",
            "description": "If an experiment ID is provided a model configuration will be sampled from the experiments active model configurations."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "messages",
          "experiment_id"
        ],
        "title": "ChatExperimentRequest",
        "description": "Base chat request."
      },
      "ChatMessage": {
        "properties": {
          "content": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/TextChatContent"
                    },
                    {
                      "$ref": "#/components/schemas/ImageChatContent"
                    }
                  ]
                },
                "type": "array"
              }
            ],
            "title": "Content",
            "description": "The content of the message.",
            "nullable": true
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Optional name of the message author.",
            "nullable": true
          },
          "tool_call_id": {
            "type": "string",
            "title": "Tool call id",
            "description": "Tool call that this message is responding to.",
            "nullable": true
          },
          "role": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChatRole"
              }
            ],
            "title": "Role",
            "description": "Role of the message author."
          },
          "tool_call": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FunctionTool"
              }
            ],
            "title": "Tool call",
            "description": "NB: Deprecated in favour of tool_calls. A tool call requested by the assistant.",
            "deprecated": true,
            "nullable": true
          },
          "tool_calls": {
            "items": {
              "$ref": "#/components/schemas/ToolCall"
            },
            "type": "array",
            "title": "Tool calls",
            "description": "A list of tool calls requested by the assistant.",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "role"
        ],
        "title": "ChatMessage"
      },
      "ChatModelConfigRequest": {
        "properties": {
          "project": {
            "type": "string",
            "title": "Project name",
            "description": "Unique project name. If no project exists with this name, a new project will be created."
          },
          "project_id": {
            "type": "string",
            "title": "Project ID",
            "description": "Unique ID of a project to associate to the log. Either this or `project` must be provided."
          },
          "session_id": {
            "type": "string",
            "title": "Session ID",
            "description": "ID of the session to associate the datapoint."
          },
          "session_reference_id": {
            "type": "string",
            "title": "Session Reference ID",
            "description": "A unique string identifying the session to associate the datapoint to. Allows you to log multiple datapoints to a session (using an ID kept by your internal systems) by passing the same `session_reference_id` in subsequent log requests. Specify at most one of this or `session_id`."
          },
          "parent_id": {
            "type": "string",
            "title": "Parent ID",
            "description": "ID associated to the parent datapoint in a session."
          },
          "parent_reference_id": {
            "type": "string",
            "title": "Parent Reference ID",
            "description": "A unique string identifying the previously-logged parent datapoint in a session. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a prior log request. Specify at most one of this or `parent_id`. Note that this cannot refer to a datapoint being logged in the same request."
          },
          "inputs": {
            "type": "object",
            "title": "Inputs",
            "description": "The inputs passed to the prompt template.",
            "default": {}
          },
          "source": {
            "type": "string",
            "title": "Source",
            "description": "Identifies where the model was called from."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Any additional metadata to record."
          },
          "source_datapoint_id": {
            "type": "string",
            "title": "Source datapoint ID",
            "description": "ID of the source datapoint if this is a log derived from a datapoint in a dataset."
          },
          "messages": {
            "items": {
              "$ref": "#/components/schemas/ChatMessage"
            },
            "type": "array",
            "title": "Messages",
            "description": "The messages passed to the to provider chat endpoint."
          },
          "provider_api_keys": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ProviderApiKeys"
              }
            ],
            "title": "Provider API Keys",
            "description": "API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization."
          },
          "num_samples": {
            "type": "integer",
            "title": "Number of samples",
            "description": "The number of chat responses.",
            "default": 1
          },
          "stream": {
            "type": "boolean",
            "title": "Whether to stream partial results",
            "description": "If true, tokens will be sent as data-only server-sent events. If num_samples > 1, samples are streamed back independently.",
            "default": false
          },
          "user": {
            "type": "string",
            "title": "End-user identifier",
            "description": "End-user ID passed through to provider call."
          },
          "tool_choice": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "none"
                ]
              },
              {
                "type": "string",
                "enum": [
                  "auto"
                ]
              },
              {
                "$ref": "#/components/schemas/ToolChoice"
              }
            ],
            "title": "Tool choice",
            "description": "Controls how the model uses tools. The following options are supported: 'none' forces the model to not call a tool; the default when no tools are provided as part of the model config. 'auto' the model can decide to call one of the provided tools; the default when tools are provided as part of the model config. Providing {'type': 'function', 'function': {name': <TOOL_NAME>}} forces the model to use the named function."
          },
          "tool_call": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              }
            ],
            "title": "Tool call",
            "description": "NB: Deprecated with new tool_choice. Controls how the model uses tools. The following options are supported: 'none' forces the model to not call a tool; the default when no tools are provided as part of the model config. 'auto' the model can decide to call one of the provided tools; the default when tools are provided as part of the model config. Providing {'name': <TOOL_NAME>} forces the model to use the provided tool of the same name.",
            "deprecated": true
          },
          "seed": {
            "type": "integer",
            "title": "Seed",
            "description": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed."
          },
          "response_format": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ResponseFormat"
              }
            ],
            "title": "Response format",
            "description": "The format of the response. Only type json_object is currently supported for chat."
          },
          "model_config_id": {
            "type": "string",
            "title": "Model config ID",
            "description": "Identifies the model configuration used to create a chat response."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "messages",
          "model_config_id"
        ],
        "title": "ChatModelConfigRequest",
        "description": "Base chat request."
      },
      "ChatRequest": {
        "properties": {
          "project": {
            "type": "string",
            "title": "Project name",
            "description": "Unique project name. If no project exists with this name, a new project will be created."
          },
          "project_id": {
            "type": "string",
            "title": "Project ID",
            "description": "Unique ID of a project to associate to the log. Either this or `project` must be provided."
          },
          "session_id": {
            "type": "string",
            "title": "Session ID",
            "description": "ID of the session to associate the datapoint."
          },
          "session_reference_id": {
            "type": "string",
            "title": "Session Reference ID",
            "description": "A unique string identifying the session to associate the datapoint to. Allows you to log multiple datapoints to a session (using an ID kept by your internal systems) by passing the same `session_reference_id` in subsequent log requests. Specify at most one of this or `session_id`."
          },
          "parent_id": {
            "type": "string",
            "title": "Parent ID",
            "description": "ID associated to the parent datapoint in a session."
          },
          "parent_reference_id": {
            "type": "string",
            "title": "Parent Reference ID",
            "description": "A unique string identifying the previously-logged parent datapoint in a session. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a prior log request. Specify at most one of this or `parent_id`. Note that this cannot refer to a datapoint being logged in the same request."
          },
          "inputs": {
            "type": "object",
            "title": "Inputs",
            "description": "The inputs passed to the prompt template.",
            "default": {}
          },
          "source": {
            "type": "string",
            "title": "Source",
            "description": "Identifies where the model was called from."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Any additional metadata to record."
          },
          "source_datapoint_id": {
            "type": "string",
            "title": "Source datapoint ID",
            "description": "ID of the source datapoint if this is a log derived from a datapoint in a dataset."
          },
          "messages": {
            "items": {
              "$ref": "#/components/schemas/ChatMessage"
            },
            "type": "array",
            "title": "Messages",
            "description": "The messages passed to the to provider chat endpoint."
          },
          "provider_api_keys": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ProviderApiKeys"
              }
            ],
            "title": "Provider API Keys",
            "description": "API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization."
          },
          "num_samples": {
            "type": "integer",
            "title": "Number of samples",
            "description": "The number of chat responses.",
            "default": 1
          },
          "stream": {
            "type": "boolean",
            "title": "Whether to stream partial results",
            "description": "If true, tokens will be sent as data-only server-sent events. If num_samples > 1, samples are streamed back independently.",
            "default": false
          },
          "user": {
            "type": "string",
            "title": "End-user identifier",
            "description": "End-user ID passed through to provider call."
          },
          "tool_choice": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "none"
                ]
              },
              {
                "type": "string",
                "enum": [
                  "auto"
                ]
              },
              {
                "$ref": "#/components/schemas/ToolChoice"
              }
            ],
            "title": "Tool choice",
            "description": "Controls how the model uses tools. The following options are supported: 'none' forces the model to not call a tool; the default when no tools are provided as part of the model config. 'auto' the model can decide to call one of the provided tools; the default when tools are provided as part of the model config. Providing {'type': 'function', 'function': {name': <TOOL_NAME>}} forces the model to use the named function."
          },
          "tool_call": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              }
            ],
            "title": "Tool call",
            "description": "NB: Deprecated with new tool_choice. Controls how the model uses tools. The following options are supported: 'none' forces the model to not call a tool; the default when no tools are provided as part of the model config. 'auto' the model can decide to call one of the provided tools; the default when tools are provided as part of the model config. Providing {'name': <TOOL_NAME>} forces the model to use the provided tool of the same name.",
            "deprecated": true
          },
          "seed": {
            "type": "integer",
            "title": "Seed",
            "description": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed."
          },
          "response_format": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ResponseFormat"
              }
            ],
            "title": "Response format",
            "description": "The format of the response. Only type json_object is currently supported for chat."
          },
          "model_config": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelConfigChatRequest"
              }
            ],
            "title": "Model configuration",
            "description": "The model configuration used to create a chat response."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "messages",
          "model_config"
        ],
        "title": "ChatRequest",
        "description": "Base chat request."
      },
      "ChatResponse": {
        "properties": {
          "project_id": {
            "type": "string",
            "title": "Project ID",
            "description": "Unique identifier of the parent project. Will not be provided if the request was made without providing a project name or id"
          },
          "num_samples": {
            "type": "integer",
            "title": "Number of samples",
            "description": "The number of chat responses.",
            "default": 1
          },
          "logprobs": {
            "type": "integer",
            "title": "Log probabilities",
            "description": "Include the log probabilities of the top n tokens in the provider_response"
          },
          "suffix": {
            "type": "string",
            "title": "Completion suffix",
            "description": "The suffix that comes after a completion of inserted text. Useful for completions that act like inserts."
          },
          "user": {
            "type": "string",
            "title": "End-user identifier",
            "description": "End-user ID passed through to provider call."
          },
          "data": {
            "items": {
              "$ref": "#/components/schemas/ChatDataResponse"
            },
            "type": "array",
            "title": "Logged data",
            "description": "Array containing the chat responses."
          },
          "usage": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Usage"
              }
            ],
            "title": "Usage",
            "description": "Counts of the number of tokens used and related stats."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Any additional metadata to record."
          },
          "provider_responses": {
            "items": {},
            "type": "array",
            "title": "Provider responses",
            "description": "The raw responses returned by the model provider."
          },
          "tool_choice": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "none"
                ]
              },
              {
                "type": "string",
                "enum": [
                  "auto"
                ]
              },
              {
                "$ref": "#/components/schemas/ToolChoice"
              }
            ],
            "title": "Tool choice",
            "description": "Controls how the model uses tools. The following options are supported: 'none' forces the model to not call a tool; the default when no tools are provided as part of the model config. 'auto' the model can decide to call one of the provided tools; the default when tools are provided as part of the model config. Providing {'type': 'function', 'function': {name': <TOOL_NAME>}} forces the model to use the named function."
          }
        },
        "type": "object",
        "required": [
          "data",
          "provider_responses"
        ],
        "title": "ChatResponse",
        "description": "Overwrite GenerateResponse for chat."
      },
      "ChatRole": {
        "type": "string",
        "enum": [
          "user",
          "assistant",
          "system",
          "tool"
        ],
        "title": "ChatRole",
        "description": "An enumeration."
      },
      "CompletionDeployedRequest": {
        "properties": {
          "project": {
            "type": "string",
            "title": "Project name",
            "description": "Unique project name. If no project exists with this name, a new project will be created."
          },
          "project_id": {
            "type": "string",
            "title": "Project ID",
            "description": "Unique ID of a project to associate to the log. Either this or `project` must be provided."
          },
          "session_id": {
            "type": "string",
            "title": "Session ID",
            "description": "ID of the session to associate the datapoint."
          },
          "session_reference_id": {
            "type": "string",
            "title": "Session Reference ID",
            "description": "A unique string identifying the session to associate the datapoint to. Allows you to log multiple datapoints to a session (using an ID kept by your internal systems) by passing the same `session_reference_id` in subsequent log requests. Specify at most one of this or `session_id`."
          },
          "parent_id": {
            "type": "string",
            "title": "Parent ID",
            "description": "ID associated to the parent datapoint in a session."
          },
          "parent_reference_id": {
            "type": "string",
            "title": "Parent Reference ID",
            "description": "A unique string identifying the previously-logged parent datapoint in a session. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a prior log request. Specify at most one of this or `parent_id`. Note that this cannot refer to a datapoint being logged in the same request."
          },
          "inputs": {
            "type": "object",
            "title": "Inputs",
            "description": "The inputs passed to the prompt template.",
            "default": {}
          },
          "source": {
            "type": "string",
            "title": "Source",
            "description": "Identifies where the model was called from."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Any additional metadata to record."
          },
          "source_datapoint_id": {
            "type": "string",
            "title": "Source datapoint ID",
            "description": "ID of the source datapoint if this is a log derived from a datapoint in a dataset."
          },
          "provider_api_keys": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ProviderApiKeys"
              }
            ],
            "title": "Provider API Keys",
            "description": "API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization."
          },
          "num_samples": {
            "type": "integer",
            "title": "Number of samples",
            "description": "The number of generations.",
            "default": 1
          },
          "logprobs": {
            "type": "integer",
            "title": "Log probabilities of most likely n tokens",
            "description": "Include the log probabilities of the top n tokens in the provider_response"
          },
          "stream": {
            "type": "boolean",
            "title": "Whether to stream partial results",
            "description": "If true, tokens will be sent as data-only server-sent events. If num_samples > 1, samples are streamed back independently.",
            "default": false
          },
          "suffix": {
            "type": "string",
            "title": "Completion suffix",
            "description": "The suffix that comes after a completion of inserted text. Useful for completions that act like inserts."
          },
          "seed": {
            "type": "integer",
            "title": "Seed",
            "description": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed."
          },
          "user": {
            "type": "string",
            "title": "End-user identifier",
            "description": "End-user ID passed through to provider call."
          },
          "environment": {
            "type": "string",
            "title": "Environment name",
            "description": "The environment name used to create a chat response. If not specified, the default environment will be used."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "CompletionDeployedRequest",
        "description": "Completion request using the project's active deployment."
      },
      "CompletionExperimentRequest": {
        "properties": {
          "project": {
            "type": "string",
            "title": "Project name",
            "description": "Unique project name. If no project exists with this name, a new project will be created."
          },
          "project_id": {
            "type": "string",
            "title": "Project ID",
            "description": "Unique ID of a project to associate to the log. Either this or `project` must be provided."
          },
          "session_id": {
            "type": "string",
            "title": "Session ID",
            "description": "ID of the session to associate the datapoint."
          },
          "session_reference_id": {
            "type": "string",
            "title": "Session Reference ID",
            "description": "A unique string identifying the session to associate the datapoint to. Allows you to log multiple datapoints to a session (using an ID kept by your internal systems) by passing the same `session_reference_id` in subsequent log requests. Specify at most one of this or `session_id`."
          },
          "parent_id": {
            "type": "string",
            "title": "Parent ID",
            "description": "ID associated to the parent datapoint in a session."
          },
          "parent_reference_id": {
            "type": "string",
            "title": "Parent Reference ID",
            "description": "A unique string identifying the previously-logged parent datapoint in a session. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a prior log request. Specify at most one of this or `parent_id`. Note that this cannot refer to a datapoint being logged in the same request."
          },
          "inputs": {
            "type": "object",
            "title": "Inputs",
            "description": "The inputs passed to the prompt template.",
            "default": {}
          },
          "source": {
            "type": "string",
            "title": "Source",
            "description": "Identifies where the model was called from."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Any additional metadata to record."
          },
          "source_datapoint_id": {
            "type": "string",
            "title": "Source datapoint ID",
            "description": "ID of the source datapoint if this is a log derived from a datapoint in a dataset."
          },
          "provider_api_keys": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ProviderApiKeys"
              }
            ],
            "title": "Provider API Keys",
            "description": "API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization."
          },
          "num_samples": {
            "type": "integer",
            "title": "Number of samples",
            "description": "The number of chat responses, where each chat response will use a model configuration sampled from the experiment.",
            "default": 1
          },
          "logprobs": {
            "type": "integer",
            "title": "Log probabilities of most likely n tokens",
            "description": "Include the log probabilities of the top n tokens in the provider_response"
          },
          "stream": {
            "type": "boolean",
            "title": "Whether to stream partial results",
            "description": "If true, tokens will be sent as data-only server-sent events. If num_samples > 1, samples are streamed back independently.",
            "default": false
          },
          "suffix": {
            "type": "string",
            "title": "Completion suffix",
            "description": "The suffix that comes after a completion of inserted text. Useful for completions that act like inserts."
          },
          "seed": {
            "type": "integer",
            "title": "Seed",
            "description": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed."
          },
          "user": {
            "type": "string",
            "title": "End-user identifier",
            "description": "End-user ID passed through to provider call."
          },
          "experiment_id": {
            "type": "string",
            "title": "Experiment ID",
            "description": "If an experiment ID is provided a model configuration will be sampled from the experiments active model configurations."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "experiment_id"
        ],
        "title": "CompletionExperimentRequest",
        "description": "Completion request for a specific experiment."
      },
      "CompletionModelConfigRequest": {
        "properties": {
          "project": {
            "type": "string",
            "title": "Project name",
            "description": "Unique project name. If no project exists with this name, a new project will be created."
          },
          "project_id": {
            "type": "string",
            "title": "Project ID",
            "description": "Unique ID of a project to associate to the log. Either this or `project` must be provided."
          },
          "session_id": {
            "type": "string",
            "title": "Session ID",
            "description": "ID of the session to associate the datapoint."
          },
          "session_reference_id": {
            "type": "string",
            "title": "Session Reference ID",
            "description": "A unique string identifying the session to associate the datapoint to. Allows you to log multiple datapoints to a session (using an ID kept by your internal systems) by passing the same `session_reference_id` in subsequent log requests. Specify at most one of this or `session_id`."
          },
          "parent_id": {
            "type": "string",
            "title": "Parent ID",
            "description": "ID associated to the parent datapoint in a session."
          },
          "parent_reference_id": {
            "type": "string",
            "title": "Parent Reference ID",
            "description": "A unique string identifying the previously-logged parent datapoint in a session. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a prior log request. Specify at most one of this or `parent_id`. Note that this cannot refer to a datapoint being logged in the same request."
          },
          "inputs": {
            "type": "object",
            "title": "Inputs",
            "description": "The inputs passed to the prompt template.",
            "default": {}
          },
          "source": {
            "type": "string",
            "title": "Source",
            "description": "Identifies where the model was called from."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Any additional metadata to record."
          },
          "source_datapoint_id": {
            "type": "string",
            "title": "Source datapoint ID",
            "description": "ID of the source datapoint if this is a log derived from a datapoint in a dataset."
          },
          "provider_api_keys": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ProviderApiKeys"
              }
            ],
            "title": "Provider API Keys",
            "description": "API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization."
          },
          "num_samples": {
            "type": "integer",
            "title": "Number of samples",
            "description": "The number of generations.",
            "default": 1
          },
          "logprobs": {
            "type": "integer",
            "title": "Log probabilities of most likely n tokens",
            "description": "Include the log probabilities of the top n tokens in the provider_response"
          },
          "stream": {
            "type": "boolean",
            "title": "Whether to stream partial results",
            "description": "If true, tokens will be sent as data-only server-sent events. If num_samples > 1, samples are streamed back independently.",
            "default": false
          },
          "suffix": {
            "type": "string",
            "title": "Completion suffix",
            "description": "The suffix that comes after a completion of inserted text. Useful for completions that act like inserts."
          },
          "seed": {
            "type": "integer",
            "title": "Seed",
            "description": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed."
          },
          "user": {
            "type": "string",
            "title": "End-user identifier",
            "description": "End-user ID passed through to provider call."
          },
          "model_config_id": {
            "type": "string",
            "title": "Model config ID",
            "description": "Identifies the model configuration used to create a chat response."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "model_config_id"
        ],
        "title": "CompletionModelConfigRequest",
        "description": "Completion request for a specific model config."
      },
      "CompletionRequest": {
        "properties": {
          "project": {
            "type": "string",
            "title": "Project name",
            "description": "Unique project name. If no project exists with this name, a new project will be created."
          },
          "project_id": {
            "type": "string",
            "title": "Project ID",
            "description": "Unique ID of a project to associate to the log. Either this or `project` must be provided."
          },
          "session_id": {
            "type": "string",
            "title": "Session ID",
            "description": "ID of the session to associate the datapoint."
          },
          "session_reference_id": {
            "type": "string",
            "title": "Session Reference ID",
            "description": "A unique string identifying the session to associate the datapoint to. Allows you to log multiple datapoints to a session (using an ID kept by your internal systems) by passing the same `session_reference_id` in subsequent log requests. Specify at most one of this or `session_id`."
          },
          "parent_id": {
            "type": "string",
            "title": "Parent ID",
            "description": "ID associated to the parent datapoint in a session."
          },
          "parent_reference_id": {
            "type": "string",
            "title": "Parent Reference ID",
            "description": "A unique string identifying the previously-logged parent datapoint in a session. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a prior log request. Specify at most one of this or `parent_id`. Note that this cannot refer to a datapoint being logged in the same request."
          },
          "inputs": {
            "type": "object",
            "title": "Inputs",
            "description": "The inputs passed to the prompt template.",
            "default": {}
          },
          "source": {
            "type": "string",
            "title": "Source",
            "description": "Identifies where the model was called from."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Any additional metadata to record."
          },
          "source_datapoint_id": {
            "type": "string",
            "title": "Source datapoint ID",
            "description": "ID of the source datapoint if this is a log derived from a datapoint in a dataset."
          },
          "provider_api_keys": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ProviderApiKeys"
              }
            ],
            "title": "Provider API Keys",
            "description": "API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization."
          },
          "num_samples": {
            "type": "integer",
            "title": "Number of samples",
            "description": "The number of generations.",
            "default": 1
          },
          "logprobs": {
            "type": "integer",
            "title": "Log probabilities of most likely n tokens",
            "description": "Include the log probabilities of the top n tokens in the provider_response"
          },
          "stream": {
            "type": "boolean",
            "title": "Whether to stream partial results",
            "description": "If true, tokens will be sent as data-only server-sent events. If num_samples > 1, samples are streamed back independently.",
            "default": false
          },
          "suffix": {
            "type": "string",
            "title": "Completion suffix",
            "description": "The suffix that comes after a completion of inserted text. Useful for completions that act like inserts."
          },
          "seed": {
            "type": "integer",
            "title": "Seed",
            "description": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed."
          },
          "user": {
            "type": "string",
            "title": "End-user identifier",
            "description": "End-user ID passed through to provider call."
          },
          "model_config": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelConfigCompletionRequest"
              }
            ],
            "title": "Model configuration",
            "description": "The model configuration used to generate."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "model_config"
        ],
        "title": "CompletionRequest",
        "description": "Completion request with a provided model config."
      },
      "CompletionResponse": {
        "properties": {
          "project_id": {
            "type": "string",
            "title": "Project ID",
            "description": "Unique identifier of the parent project. Will not be provided if the request was made without providing a project name or id"
          },
          "num_samples": {
            "type": "integer",
            "title": "Number of samples",
            "description": "How many completions to make for each set of inputs.",
            "default": 1
          },
          "logprobs": {
            "type": "integer",
            "title": "Log probabilities",
            "description": "Include the log probabilities of the top n tokens in the provider_response"
          },
          "suffix": {
            "type": "string",
            "title": "Completion suffix",
            "description": "The suffix that comes after a completion of inserted text. Useful for completions that act like inserts."
          },
          "user": {
            "type": "string",
            "title": "End-user identifier",
            "description": "End-user ID passed through to provider call."
          },
          "data": {
            "items": {
              "$ref": "#/components/schemas/DataResponse"
            },
            "type": "array",
            "title": "Logged data",
            "description": "Array containing the generation responses."
          },
          "usage": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Usage"
              }
            ],
            "title": "Usage",
            "description": "Counts of the number of tokens used and related stats."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Any additional metadata to record."
          },
          "provider_responses": {
            "items": {},
            "type": "array",
            "title": "Provider responses",
            "description": "The raw responses returned by the model provider."
          }
        },
        "type": "object",
        "required": [
          "data",
          "provider_responses"
        ],
        "title": "CompletionResponse"
      },
      "ConfigResponse": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/ModelConfigResponse"
          },
          {
            "$ref": "#/components/schemas/ToolConfigResponse"
          },
          {
            "$ref": "#/components/schemas/AgentConfigResponse"
          },
          {
            "$ref": "#/components/schemas/GenericConfigResponse"
          }
        ],
        "title": "ConfigResponse",
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "model": "#/components/schemas/ModelConfigResponse",
            "tool": "#/components/schemas/ToolConfigResponse",
            "agent": "#/components/schemas/AgentConfigResponse",
            "generic": "#/components/schemas/GenericConfigResponse"
          }
        }
      },
      "ConfigType": {
        "type": "string",
        "enum": [
          "generic",
          "model",
          "tool",
          "agent"
        ],
        "title": "ConfigType",
        "description": "An enumeration."
      },
      "CreateDatapointRequest": {
        "properties": {
          "inputs": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "title": "Inputs",
            "description": "The inputs to the prompt template for this datapoint."
          },
          "messages": {
            "items": {
              "$ref": "#/components/schemas/ChatMessage"
            },
            "type": "array",
            "title": "Chat messages",
            "description": "The chat messages for this datapoint."
          },
          "target": {
            "additionalProperties": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "number"
                },
                {
                  "type": "boolean"
                },
                {
                  "type": "object"
                },
                {
                  "items": {},
                  "type": "array"
                }
              ]
            },
            "type": "object",
            "title": "Target",
            "description": "Object with criteria necessary to evaluate this datapoint."
          }
        },
        "type": "object",
        "title": "CreateDatapointRequest"
      },
      "CreateDatapointsByLogsRequest": {
        "properties": {
          "log_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Log IDs",
            "description": "The IDs of the logs to create datapoints from."
          }
        },
        "type": "object",
        "required": [
          "log_ids"
        ],
        "title": "CreateDatapointsByLogsRequest"
      },
      "CreateDatasetRequest": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 255,
            "title": "Name",
            "description": "The name of the dataset."
          },
          "description": {
            "type": "string",
            "maxLength": 255,
            "title": "Description",
            "description": "The description of the dataset."
          }
        },
        "type": "object",
        "required": [
          "name",
          "description"
        ],
        "title": "CreateDatasetRequest"
      },
      "CreateEvaluationRequest": {
        "properties": {
          "config_id": {
            "type": "string",
            "title": "Config",
            "description": "ID of the config to evaluate. Starts with `config_`."
          },
          "evaluator_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Evaluators",
            "description": "IDs of evaluators to run on the dataset. IDs start with `evfn_`"
          },
          "dataset_id": {
            "type": "string",
            "title": "Evaluation dataset",
            "description": "ID of the dataset to use in this evaluation. Starts with `evts_`."
          },
          "provider_api_keys": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ProviderApiKeys"
              }
            ],
            "title": "Provider API Keys",
            "description": "API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization. Ensure you provide an API key for the provider for the model config you are evaluating, or have one saved to your organization."
          }
        },
        "type": "object",
        "required": [
          "config_id",
          "evaluator_ids",
          "dataset_id"
        ],
        "title": "CreateEvaluationRequest"
      },
      "CreateEvaluationResultLogRequest": {
        "properties": {
          "log_id": {
            "type": "string",
            "title": "Log ID",
            "description": "The log that was evaluated. Must have as its `source_datapoint_id` one of the datapoints in the dataset being evaluated."
          },
          "evaluator_id": {
            "type": "string",
            "title": "Evaluator ID",
            "description": "ID of the evaluator that evaluated the log. Starts with `evfn_`. Must be one of the evaluator IDs associated with the evaluation run being logged to."
          },
          "result": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "integer"
              },
              {
                "type": "number"
              }
            ],
            "title": "Value",
            "description": "The result value of the evaluation."
          },
          "error": {
            "type": "string",
            "title": "Error",
            "description": "An error that occurred during evaluation."
          }
        },
        "type": "object",
        "required": [
          "log_id",
          "evaluator_id"
        ],
        "title": "CreateEvaluationResultLogRequest",
        "description": "An evaluation result log."
      },
      "CreateEvaluatorRequest": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "Name",
            "description": "The name of the evaluator."
          },
          "description": {
            "type": "string",
            "maxLength": 255,
            "title": "Description",
            "description": "The description of the evaluator."
          },
          "arguments_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EvaluatorArgumentsType"
              }
            ],
            "title": "Arguments type",
            "description": "Whether this evaluator is target-free or target-required."
          },
          "return_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EvaluatorReturnTypeEnum"
              }
            ],
            "title": "Return type",
            "description": "The type of the return value of the evaluator."
          },
          "code": {
            "type": "string",
            "title": "Code",
            "description": "The code for the evaluator. This code will be executed in a sandboxed environment."
          },
          "model_config": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelConfigCompletionRequest"
              }
            ],
            "title": "Model configuration",
            "description": "The model configuration used to generate."
          },
          "type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EvaluatorType"
              }
            ],
            "title": "Evaluator type",
            "description": "The type of the evaluator."
          }
        },
        "type": "object",
        "required": [
          "name",
          "description",
          "arguments_type",
          "return_type",
          "type"
        ],
        "title": "CreateEvaluatorRequest"
      },
      "CreateExperimentRequest": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Experiment name",
            "description": "Name of experiment."
          },
          "config_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Config IDs",
            "description": "Configs to add to this experiment. Further configs can be added later."
          },
          "positive_labels": {
            "items": {
              "$ref": "#/components/schemas/PositiveLabel"
            },
            "type": "array",
            "title": "Positive labels",
            "description": "Feedback labels to treat as positive user feedback. Used to monitor the performance of model configs in the experiment."
          },
          "set_active": {
            "type": "boolean",
            "title": "Set as project's active experiment",
            "description": "Whether to set the created project as the project's active experiment.",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "name",
          "positive_labels"
        ],
        "title": "CreateExperimentRequest"
      },
      "CreateLogResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Datapoint ID",
            "description": "String ID of logged datapoint. Starts with `data_`."
          },
          "project_id": {
            "type": "string",
            "title": "Project ID",
            "description": "String ID of project the datapoint belongs to. Starts with `pr_`."
          },
          "session_id": {
            "type": "string",
            "title": "Session ID",
            "description": "String ID of session the datapoint belongs to. Populated only if the datapoint was logged with `session_id` or `session_reference_id`, and is `None` otherwise. Starts with `sesh_`."
          }
        },
        "type": "object",
        "required": [
          "id",
          "project_id"
        ],
        "title": "CreateLogResponse"
      },
      "CreateProjectRequest": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Project name",
            "description": "Unique project name."
          },
          "feedback_types": {
            "items": {
              "$ref": "#/components/schemas/FeedbackTypeRequest"
            },
            "type": "array",
            "title": "Feedback types",
            "description": "Feedback types to be created."
          },
          "directory_id": {
            "type": "string",
            "title": "Directory ID",
            "description": "ID of directory to assign project to. Starts with `dir_`. If not provided, the project will be created in the root directory."
          }
        },
        "type": "object",
        "required": [
          "name"
        ],
        "title": "CreateProjectRequest"
      },
      "CreateSessionResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Session ID",
            "description": "String ID of session. Starts with `sesh_`."
          }
        },
        "type": "object",
        "required": [
          "id"
        ],
        "title": "CreateSessionResponse"
      },
      "DashboardConfiguration": {
        "properties": {
          "time_unit": {
            "$ref": "#/components/schemas/TimeUnit"
          },
          "time_range_days": {
            "type": "integer",
            "title": "Time Range Days"
          },
          "model_config_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Model Config Ids"
          }
        },
        "type": "object",
        "required": [
          "time_unit",
          "time_range_days",
          "model_config_ids"
        ],
        "title": "DashboardConfiguration"
      },
      "DataResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Data ID",
            "description": "Unique ID for the model inputs and output logged to Humanloop. Use this when recording feedback later."
          },
          "index": {
            "type": "integer",
            "title": "Sample index",
            "description": "The index for the sampled generation for a given input. The num_samples request parameter controls how many samples are generated."
          },
          "output": {
            "type": "string",
            "title": "Sanitized output text",
            "description": "Output text returned from the provider model with leading and trailing whitespaces stripped."
          },
          "raw_output": {
            "type": "string",
            "title": "Provider's output text",
            "description": "Raw output text returned from the provider model."
          },
          "inputs": {
            "type": "object",
            "title": "Inputs",
            "description": "The inputs passed to the prompt template."
          },
          "finish_reason": {
            "type": "string",
            "title": "Finish reason",
            "description": "Why the generation ended. One of 'stop' (indicating a stop token was encountered), or 'length' (indicating the max tokens limit has been reached), or 'tool_call' (indicating that the model has chosen to call a tool - in which case the tool_call parameter of the response will be populated). It will be set as null for the intermediary responses during a stream, and will only be set as non-null for the final streamed token."
          },
          "model_config_id": {
            "type": "string",
            "title": "The ID of your model configuration",
            "description": "The model configuration used to create the generation."
          },
          "tool_results": {
            "items": {
              "$ref": "#/components/schemas/ToolResultResponse"
            },
            "type": "array",
            "title": "Tool results",
            "description": "Results of any tools run during the generation."
          }
        },
        "type": "object",
        "required": [
          "id",
          "index",
          "output",
          "raw_output",
          "inputs",
          "model_config_id"
        ],
        "title": "DataResponse"
      },
      "DatapointResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id"
          },
          "dataset_id": {
            "type": "string",
            "title": "Dataset Id"
          },
          "inputs": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "title": "Inputs"
          },
          "messages": {
            "items": {
              "$ref": "#/components/schemas/ChatMessage"
            },
            "type": "array",
            "title": "Messages"
          },
          "target": {
            "additionalProperties": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "number"
                },
                {
                  "type": "boolean"
                },
                {
                  "type": "object"
                },
                {
                  "items": {},
                  "type": "array"
                }
              ]
            },
            "type": "object",
            "title": "Target"
          },
          "source_project_data_id": {
            "type": "string",
            "title": "Source Project Data Id"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At"
          }
        },
        "type": "object",
        "required": [
          "id",
          "dataset_id",
          "created_at",
          "updated_at"
        ],
        "title": "DatapointResponse"
      },
      "DatasetResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id"
          },
          "project_id": {
            "type": "string",
            "title": "Project Id"
          },
          "name": {
            "type": "string",
            "title": "Name"
          },
          "description": {
            "type": "string",
            "title": "Description"
          },
          "datapoint_count": {
            "type": "integer",
            "title": "Datapoint Count"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At"
          }
        },
        "type": "object",
        "required": [
          "id",
          "project_id",
          "name",
          "datapoint_count",
          "created_at",
          "updated_at"
        ],
        "title": "DatasetResponse"
      },
      "EnvironmentProjectConfigRequest": {
        "properties": {
          "config_id": {
            "type": "string",
            "title": "Model config ID",
            "description": "Model config unique identifier generated by Humanloop."
          },
          "experiment_id": {
            "type": "string",
            "title": "Experiment ID",
            "description": "String ID of experiment. Starts with `exp_`."
          },
          "environments": {
            "items": {
              "$ref": "#/components/schemas/EnvironmentRequest"
            },
            "type": "array",
            "title": "Environments",
            "description": "List of environments to associate with the model config."
          }
        },
        "type": "object",
        "title": "EnvironmentProjectConfigRequest"
      },
      "EnvironmentProjectConfigResponse": {
        "properties": {
          "project_id": {
            "type": "string",
            "title": "Project ID",
            "description": "String ID of project the model config belongs to. Starts with `pr_`."
          },
          "project_name": {
            "type": "string",
            "title": "Project name",
            "description": "Name of the project the model config belongs to."
          },
          "model_config_id": {
            "type": "string",
            "title": "Model config ID",
            "description": "Model config unique identifier generated by Humanloop."
          },
          "model_config_name": {
            "type": "string",
            "title": "Model config name",
            "description": "A friendly display name for the model config."
          },
          "experiment_id": {
            "type": "string",
            "title": "Experiment ID",
            "description": "String ID of experiment. Starts with `exp_`."
          },
          "experiment_name": {
            "type": "string",
            "title": "Experiment Display name",
            "description": "Display name of experiment."
          },
          "environment_id": {
            "type": "string",
            "title": "Environment ID",
            "description": "The ID of the environment."
          },
          "environment_name": {
            "type": "string",
            "title": "Environment name",
            "description": "The name of the environment."
          },
          "environment_tag": {
            "type": "string",
            "title": "Environment tag",
            "description": "Tag for the environment e.g. 'default' or 'other'."
          }
        },
        "type": "object",
        "required": [
          "project_id",
          "project_name",
          "environment_id",
          "environment_name",
          "environment_tag"
        ],
        "title": "EnvironmentProjectConfigResponse"
      },
      "EnvironmentRequest": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Environemnt id",
            "description": "Str Id of the envrionment. Starts with `env_`."
          },
          "name": {
            "type": "string",
            "title": "Environemnt name",
            "description": "The environment name."
          }
        },
        "type": "object",
        "required": [
          "id"
        ],
        "title": "EnvironmentRequest"
      },
      "EvaluationDatapointSnapshotResponse": {
        "properties": {
          "datapoint": {
            "$ref": "#/components/schemas/DatapointResponse"
          },
          "log": {
            "$ref": "#/components/schemas/LogResponse"
          },
          "evaluation_results": {
            "items": {
              "$ref": "#/components/schemas/EvaluationResultResponse"
            },
            "type": "array",
            "title": "Evaluation Results"
          }
        },
        "type": "object",
        "required": [
          "datapoint",
          "evaluation_results"
        ],
        "title": "EvaluationDatapointSnapshotResponse"
      },
      "EvaluationResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Evaluation ID",
            "description": "Unique ID for the evaluation. Starts with `ev_`."
          },
          "status": {
            "$ref": "#/components/schemas/EvaluationStatus"
          },
          "config": {
            "$ref": "#/components/schemas/ConfigResponse"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At"
          },
          "evaluators": {
            "items": {
              "$ref": "#/components/schemas/EvaluatorResponse"
            },
            "type": "array",
            "title": "Evaluators"
          },
          "dataset": {
            "$ref": "#/components/schemas/DatasetResponse"
          },
          "dataset_snapshot": {
            "$ref": "#/components/schemas/DatasetResponse"
          },
          "evaluator_aggregates": {
            "items": {
              "$ref": "#/components/schemas/ModelConfigEvaluatorAggregateResponse"
            },
            "type": "array",
            "title": "Evaluator Aggregates"
          },
          "feedback_aggregates": {
            "$ref": "#/components/schemas/FeedbackAggregateResponse"
          }
        },
        "type": "object",
        "required": [
          "id",
          "status",
          "config",
          "created_at",
          "updated_at",
          "evaluators",
          "dataset"
        ],
        "title": "EvaluationResponse"
      },
      "EvaluationResultResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id"
          },
          "evaluator_id": {
            "type": "string",
            "title": "Evaluator Id"
          },
          "evaluation_id": {
            "type": "string",
            "title": "Evaluation Id"
          },
          "log_id": {
            "type": "string",
            "title": "Log Id"
          },
          "value": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "number"
              }
            ],
            "title": "Value"
          },
          "error": {
            "type": "string",
            "title": "Error"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At"
          }
        },
        "type": "object",
        "required": [
          "id",
          "evaluator_id",
          "log_id",
          "updated_at"
        ],
        "title": "EvaluationResultResponse"
      },
      "EvaluationStatus": {
        "type": "string",
        "enum": [
          "pending",
          "running",
          "completed",
          "failed"
        ],
        "title": "EvaluationStatus",
        "description": "Status of an evaluation."
      },
      "EvaluatorArgumentsType": {
        "type": "string",
        "enum": [
          "target_free",
          "target_required"
        ],
        "title": "EvaluatorArgumentsType",
        "description": "Enum representing the possible argument types of an evaluator."
      },
      "EvaluatorResponse": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "Name",
            "description": "The name of the evaluator."
          },
          "description": {
            "type": "string",
            "maxLength": 255,
            "title": "Description",
            "description": "The description of the evaluator."
          },
          "arguments_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EvaluatorArgumentsType"
              }
            ],
            "title": "Arguments type",
            "description": "Whether this evaluator is target-free or target-required."
          },
          "return_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EvaluatorReturnTypeEnum"
              }
            ],
            "title": "Return type",
            "description": "The type of the return value of the evaluator."
          },
          "code": {
            "type": "string",
            "title": "Code",
            "description": "The code for the evaluator. This code will be executed in a sandboxed environment."
          },
          "model_config": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelConfigResponse"
              }
            ],
            "title": "Model config",
            "description": "The model config defining the LLM evaluator."
          },
          "type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EvaluatorType"
              }
            ],
            "title": "Evaluator type",
            "description": "The type of the evaluator."
          },
          "id": {
            "type": "string",
            "title": "Evaluator ID",
            "description": "Unique ID for the evaluator. Starts with `evfn_`."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At"
          },
          "logging_project": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ProjectResponse"
              }
            ],
            "title": "Logging project",
            "description": "The project where the evaluator logs are stored."
          }
        },
        "type": "object",
        "required": [
          "name",
          "description",
          "arguments_type",
          "return_type",
          "type",
          "id",
          "created_at",
          "updated_at"
        ],
        "title": "EvaluatorResponse"
      },
      "EvaluatorReturnTypeEnum": {
        "type": "string",
        "enum": [
          "boolean",
          "number"
        ],
        "title": "EvaluatorReturnTypeEnum",
        "description": "Enum representing the possible return types of an evaluator."
      },
      "EvaluatorType": {
        "type": "string",
        "enum": [
          "python",
          "llm",
          "human",
          "external"
        ],
        "title": "EvaluatorType",
        "description": "An enumeration."
      },
      "ExperimentConfigResponse": {
        "properties": {
          "mean": {
            "type": "number",
            "title": "Mean of experiment's metric",
            "description": "The mean performance of the model config."
          },
          "spread": {
            "type": "number",
            "title": "Spread of experiment's metric",
            "description": "The spread of performance of the model config."
          },
          "trials_count": {
            "type": "integer",
            "title": "Trials count",
            "description": "Number of datapoints with feedback associated to the experiment."
          },
          "active": {
            "type": "boolean",
            "title": "Model config active",
            "description": "Whether the model config is active in the experiment. Only active model configs can be sampled from the experiment."
          },
          "id": {
            "type": "string",
            "title": "Model config ID",
            "description": "String ID of model config. Starts with `config_`."
          },
          "display_name": {
            "type": "string",
            "title": "Display name",
            "description": "Display name of model config. If this is not set by the user, a friendly name is generated."
          },
          "config": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ConfigResponse"
              }
            ],
            "title": "Config",
            "description": "Definition of the config used in the experiment."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At"
          }
        },
        "type": "object",
        "required": [
          "trials_count",
          "active",
          "id",
          "display_name",
          "config",
          "created_at",
          "updated_at"
        ],
        "title": "ExperimentConfigResponse"
      },
      "ExperimentResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Experiment ID",
            "description": "String ID of experiment. Starts with `exp_`."
          },
          "project_id": {
            "type": "string",
            "title": "Project ID",
            "description": "String ID of project the experiment belongs to. Starts with `pr_`."
          },
          "name": {
            "type": "string",
            "title": "Experiment name",
            "description": "Name of experiment."
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ExperimentStatus"
              }
            ],
            "title": "Experiment status",
            "description": "Status of experiment."
          },
          "configs": {
            "items": {
              "$ref": "#/components/schemas/ExperimentConfigResponse"
            },
            "type": "array",
            "title": "Experiment configs",
            "description": "List of configs associated to the experiment."
          },
          "metric": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BaseMetricResponse"
              }
            ],
            "title": "Experiment metric",
            "description": "Metric used as the experiment's objective."
          },
          "positive_labels": {
            "items": {
              "$ref": "#/components/schemas/PositiveLabel"
            },
            "type": "array",
            "title": "Positive labels",
            "description": "Feedback labels to treat as positive user feedback. Used to monitor the performance of model configs in the experiment."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At"
          }
        },
        "type": "object",
        "required": [
          "id",
          "project_id",
          "name",
          "status",
          "metric",
          "positive_labels",
          "created_at",
          "updated_at"
        ],
        "title": "ExperimentResponse"
      },
      "ExperimentStatus": {
        "type": "string",
        "enum": [
          "Initialized",
          "In progress"
        ],
        "title": "ExperimentStatus",
        "description": "An enumeration."
      },
      "Feedback": {
        "properties": {
          "type": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/FeedbackType"
              },
              {
                "type": "string"
              }
            ],
            "title": "Feedback type",
            "description": "The type of feedback. The default feedback types available are 'rating', 'action', 'issue', 'correction', and 'comment'."
          },
          "value": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ],
            "title": "Feedback value",
            "description": "The feedback value to set. This would be the appropriate text for 'correction' or 'comment', or a label to apply for 'rating', 'action', or 'issue'."
          },
          "data_id": {
            "type": "string",
            "title": "Datapoint ID",
            "description": "ID to associate the feedback to a previously logged datapoint."
          },
          "user": {
            "type": "string",
            "title": "User",
            "description": "A unique identifier to who provided the feedback."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "description": "User defined timestamp for when the feedback was created. "
          }
        },
        "type": "object",
        "required": [
          "type",
          "value"
        ],
        "title": "Feedback"
      },
      "FeedbackAggregateResponse": {
        "items": {
          "anyOf": [
            {
              "$ref": "#/components/schemas/FeedbackSelectAggregate"
            },
            {
              "$ref": "#/components/schemas/FeedbackMultiSelectAggregate"
            },
            {
              "$ref": "#/components/schemas/FeedbackTextAggregate"
            },
            {
              "$ref": "#/components/schemas/FeedbackNumberAggregate"
            }
          ]
        },
        "type": "array",
        "title": "FeedbackAggregateResponse"
      },
      "FeedbackClass": {
        "type": "string",
        "enum": [
          "select",
          "multi_select",
          "text",
          "number"
        ],
        "title": "FeedbackClass",
        "description": "An enumeration."
      },
      "FeedbackLabelRequest": {
        "properties": {
          "value": {
            "type": "string",
            "title": "Value"
          },
          "sentiment": {
            "$ref": "#/components/schemas/LabelSentiment"
          }
        },
        "type": "object",
        "required": [
          "value"
        ],
        "title": "FeedbackLabelRequest"
      },
      "FeedbackMultiSelectAggregate": {
        "properties": {
          "feedback_type": {
            "$ref": "#/components/schemas/FeedbackTypeModel"
          },
          "values": {
            "additionalProperties": {
              "type": "integer"
            },
            "type": "object",
            "title": "Feedback values",
            "description": "The number of times each value exists in the aggregation."
          },
          "total": {
            "type": "integer",
            "title": "Total",
            "description": "The total number of feedbacks provided."
          }
        },
        "type": "object",
        "required": [
          "feedback_type",
          "values",
          "total"
        ],
        "title": "FeedbackMultiSelectAggregate"
      },
      "FeedbackNumberAggregate": {
        "properties": {
          "feedback_type": {
            "$ref": "#/components/schemas/FeedbackTypeModel"
          },
          "mean": {
            "type": "number",
            "title": "Mean",
            "description": "The mean of all feedback values."
          }
        },
        "type": "object",
        "required": [
          "feedback_type",
          "mean"
        ],
        "title": "FeedbackNumberAggregate"
      },
      "FeedbackRequest": {
        "properties": {
          "type": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/FeedbackType"
              },
              {
                "type": "string"
              }
            ],
            "title": "Feedback type",
            "description": "The type of feedback. The default feedback types available are 'rating', 'action', 'issue', 'correction', and 'comment'."
          },
          "value": {
            "type": "string",
            "title": "Feedback value",
            "description": "The feedback value to be set. This field should be left blank when unsetting 'rating', 'correction' or 'comment', but is required otherwise."
          },
          "data_id": {
            "type": "string",
            "title": "Datapoint ID",
            "description": "ID to associate the feedback to a previously logged datapoint."
          },
          "user": {
            "type": "string",
            "title": "User",
            "description": "A unique identifier to who provided the feedback."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "description": "User defined timestamp for when the feedback was created. "
          },
          "unset": {
            "type": "boolean",
            "title": "Unset",
            "description": "If true, the value for this feedback is unset."
          }
        },
        "type": "object",
        "required": [
          "type"
        ],
        "title": "FeedbackRequest"
      },
      "FeedbackResponse": {
        "properties": {
          "type": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/FeedbackType"
              },
              {
                "type": "string"
              }
            ],
            "title": "Feedback type",
            "description": "The type of feedback. The default feedback types available are 'rating', 'action', 'issue', 'correction', and 'comment'."
          },
          "value": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ],
            "title": "Feedback value",
            "description": "The feedback value to set. This would be the appropriate text for 'correction' or 'comment', or a label to apply for 'rating', 'action', or 'issue'."
          },
          "data_id": {
            "type": "string",
            "title": "Datapoint ID",
            "description": "ID to associate the feedback to a previously logged datapoint."
          },
          "user": {
            "type": "string",
            "title": "User",
            "description": "A unique identifier to who provided the feedback."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "description": "User defined timestamp for when the feedback was created. "
          },
          "id": {
            "type": "string",
            "title": "Feedback ID",
            "description": "String ID of user feedback. Starts with `ann_`, short for annotation."
          }
        },
        "type": "object",
        "required": [
          "type",
          "value",
          "id"
        ],
        "title": "FeedbackResponse"
      },
      "FeedbackSelectAggregate": {
        "properties": {
          "feedback_type": {
            "$ref": "#/components/schemas/FeedbackTypeModel"
          },
          "values": {
            "additionalProperties": {
              "type": "integer"
            },
            "type": "object",
            "title": "Feedback values",
            "description": "The number of times each value exists in the aggregation."
          },
          "total": {
            "type": "integer",
            "title": "Total",
            "description": "The total number of feedbacks provided."
          }
        },
        "type": "object",
        "required": [
          "feedback_type",
          "values",
          "total"
        ],
        "title": "FeedbackSelectAggregate"
      },
      "FeedbackTextAggregate": {
        "properties": {
          "feedback_type": {
            "$ref": "#/components/schemas/FeedbackTypeModel"
          }
        },
        "type": "object",
        "required": [
          "feedback_type"
        ],
        "title": "FeedbackTextAggregate"
      },
      "FeedbackType": {
        "type": "string",
        "enum": [
          "rating",
          "action",
          "issue",
          "correction",
          "comment"
        ],
        "title": "FeedbackType",
        "description": "An enumeration."
      },
      "FeedbackTypeModel": {
        "properties": {
          "type": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/FeedbackType"
              },
              {
                "type": "string"
              }
            ],
            "title": "Feedback type",
            "description": "The type of feedback. The default feedback types available are 'rating', 'action', 'issue', 'correction', and 'comment'."
          },
          "values": {
            "items": {
              "$ref": "#/components/schemas/CategoricalFeedbackLabel"
            },
            "type": "array",
            "title": "Allowed values for categorical feedback types",
            "description": "The allowed values for categorical feedback types. Not populated for `correction` and `comment`."
          }
        },
        "type": "object",
        "required": [
          "type"
        ],
        "title": "FeedbackTypeModel"
      },
      "FeedbackTypeRequest": {
        "properties": {
          "type": {
            "type": "string",
            "title": "Feedback type",
            "description": "The type of feedback to update."
          },
          "values": {
            "items": {
              "$ref": "#/components/schemas/FeedbackLabelRequest"
            },
            "type": "array",
            "title": "Feedback label values",
            "description": "The feedback values to be available. This field should only be populated when updating a 'select' or 'multi_select' feedback class."
          },
          "class": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FeedbackClass"
              }
            ],
            "title": "Feedback class",
            "description": "The data type associated to this feedback type; whether it is a 'text'/'select'/'multi_select'. This is optional when updating the default feedback types (i.e. when `type` is 'rating', 'action' or 'issue')."
          }
        },
        "type": "object",
        "required": [
          "type"
        ],
        "title": "FeedbackTypeRequest"
      },
      "FeedbackTypes": {
        "items": {
          "$ref": "#/components/schemas/FeedbackTypeModel"
        },
        "type": "array",
        "title": "FeedbackTypes"
      },
      "FinetuneConfig": {
        "properties": {
          "provider": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelProviders"
              }
            ],
            "title": "Model provider",
            "description": "The company who is hosting the target model.This is used only if an existing experiment_id or model_config_id are not provided.",
            "default": "openai"
          },
          "base_model": {
            "type": "string",
            "title": "Base model",
            "description": "Unique reference to the model the fine-tuning was based on."
          },
          "parameters": {
            "type": "object",
            "title": "Fine-tuning parameters",
            "description": "Provider specific hyper-parameter settings that along with your base model will configure the fine-tuning process with the provider."
          }
        },
        "type": "object",
        "required": [
          "base_model"
        ],
        "title": "FinetuneConfig"
      },
      "FinetuneDataSummary": {
        "properties": {
          "data_count": {
            "type": "integer",
            "title": "Data Count"
          },
          "error_count": {
            "type": "integer",
            "title": "Error Count"
          },
          "truncated_data_count": {
            "type": "integer",
            "title": "Truncated Data Count"
          },
          "token_count": {
            "type": "integer",
            "title": "Token Count"
          },
          "truncated_token_count": {
            "type": "integer",
            "title": "Truncated Token Count"
          },
          "cost": {
            "type": "number",
            "title": "Cost"
          },
          "errors": {
            "items": {
              "type": "object"
            },
            "type": "array",
            "title": "Errors"
          },
          "dataset_name": {
            "type": "string",
            "title": "Dataset Name"
          },
          "dataset_id": {
            "type": "string",
            "title": "Dataset Id"
          }
        },
        "type": "object",
        "required": [
          "data_count",
          "error_count",
          "truncated_data_count",
          "token_count",
          "truncated_token_count",
          "cost",
          "errors",
          "dataset_name",
          "dataset_id"
        ],
        "title": "FinetuneDataSummary",
        "description": "Summary of a finetuning dataset."
      },
      "FinetuneRequest": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Fine-tune run name",
            "description": "User defined friendly name for a finetuning run"
          },
          "dataset_id": {
            "type": "string",
            "title": "Dataset ID",
            "description": "ID of dataset used for finetuning"
          },
          "config": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FinetuneConfig"
              }
            ],
            "title": "Finetuning config",
            "description": "Configuration and hyper-parameters for the fine-tuning process"
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Any additional metadata that you would like to log for reference."
          },
          "provider_api_keys": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ProviderApiKeys"
              }
            ],
            "title": "Provider API Keys",
            "description": "API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization."
          }
        },
        "type": "object",
        "required": [
          "name",
          "dataset_id",
          "config"
        ],
        "title": "FinetuneRequest"
      },
      "FinetuneResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Fine-tuned model ID",
            "description": "Unique identifier for fine-tuned model."
          },
          "name": {
            "type": "string",
            "title": "Fine-tune run name",
            "description": "User defined friendly name for a fine-tuning run"
          },
          "status": {
            "type": "string",
            "title": "Status of fine tuning process",
            "description": "The fine-tuning process is run async and so the resultingfine-tuned model won't be available for generations until it has completed."
          },
          "model_name": {
            "type": "string",
            "title": "Fine-tuned model provider reference",
            "description": "Unique reference for the fine-tuned required to make calls to the provider."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Any additional metadata that you would like to log for reference."
          },
          "provider_id": {
            "type": "string",
            "title": "Fine-tuned model unique ID from the provider.",
            "description": "Unique ID for the fine-tuned model required to make calls to the provider's API."
          },
          "provider_details": {
            "type": "object",
            "title": "Provider results",
            "description": "Provider specific fine-tuning results."
          },
          "data_summary": {
            "type": "object",
            "title": "Data summary",
            "description": "Summary stats about the data used for finetuning."
          },
          "config": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FinetuneConfig"
              }
            ],
            "title": "Fine-tuning config.",
            "description": "Configuration details for the fine-tuned model."
          },
          "dataset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DatasetResponse"
              }
            ],
            "title": "Dataset"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "status",
          "config",
          "dataset",
          "created_at",
          "updated_at"
        ],
        "title": "FinetuneResponse"
      },
      "FunctionTool": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "arguments": {
            "type": "string",
            "title": "Arguments"
          }
        },
        "type": "object",
        "required": [
          "name"
        ],
        "title": "FunctionTool",
        "description": "A function tool to be called by the model where user owns runtime."
      },
      "FunctionToolChoice": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          }
        },
        "type": "object",
        "required": [
          "name"
        ],
        "title": "FunctionToolChoice",
        "description": "A function tool to be called by the model where user owns runtime."
      },
      "GenericConfigRequest": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Model config name",
            "description": "A friendly display name for the model config. If not provided, a name will be generated."
          },
          "description": {
            "type": "string",
            "title": "Model config description",
            "description": "A description of the model config."
          },
          "type": {
            "type": "string",
            "enum": [
              "generic"
            ],
            "title": "Type"
          },
          "other": {
            "type": "object",
            "title": "Other parameters",
            "description": "Other parameters that define the config."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "type"
        ],
        "title": "GenericConfigRequest",
        "description": "Base config request for all config types.\n\nContains fields that are common to all config types. Specifically, `name`\nand `description` that are saved at the organization-level."
      },
      "GenericConfigResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Config ID",
            "description": "String ID of config. Starts with `config_`."
          },
          "other": {
            "type": "object",
            "title": "Other parameters",
            "description": "Other parameters that define the config."
          },
          "type": {
            "type": "string",
            "enum": [
              "generic"
            ],
            "title": "Type"
          },
          "name": {
            "type": "string",
            "title": "Config name",
            "description": "Name of config."
          },
          "description": {
            "type": "string",
            "title": "Config description",
            "description": "Description of config."
          }
        },
        "type": "object",
        "required": [
          "id",
          "type",
          "name"
        ],
        "title": "GenericConfigResponse"
      },
      "GetModelConfigResponse": {
        "properties": {
          "project_id": {
            "type": "string",
            "title": "Project ID",
            "description": "String ID of project the model config belongs to. Starts with `pr_`."
          },
          "project_name": {
            "type": "string",
            "title": "Project name",
            "description": "Name of the project the model config belongs to."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At"
          },
          "last_used": {
            "type": "string",
            "format": "date-time",
            "title": "Last Used"
          },
          "feedback_stats": {
            "items": {
              "$ref": "#/components/schemas/ProjectModelConfigFeedbackStatsResponse"
            },
            "type": "array",
            "title": "Feedback statistics",
            "description": "Feedback statistics for the project model config."
          },
          "num_datapoints": {
            "type": "integer",
            "title": "Number of datapoints",
            "description": "Number of datapoints associated with this project model config."
          },
          "experiment_id": {
            "type": "string",
            "title": "Experiment ID",
            "description": "The ID of the experiment the model config has been registered to. Only populated when registering a model config to an experiment."
          },
          "evaluation_aggregates": {
            "items": {
              "$ref": "#/components/schemas/ModelConfigEvaluatorAggregateResponse"
            },
            "type": "array",
            "title": "Evaluator aggregates",
            "description": "Aggregates of evaluators for the model config."
          },
          "config": {
            "$ref": "#/components/schemas/ConfigResponse"
          },
          "trial_id": {
            "type": "string",
            "title": "Trial ID",
            "description": "ID of trial to reference in subsequent log calls."
          },
          "environment_id": {
            "type": "string",
            "title": "Environment ID",
            "description": "ID of environment to reference in subsequent log calls."
          }
        },
        "type": "object",
        "required": [
          "project_id",
          "project_name",
          "created_at",
          "updated_at",
          "last_used",
          "config"
        ],
        "title": "GetModelConfigResponse",
        "description": "A selected model configuration.\n\nIf the model configuration was selected in the context of an experiment,\nthe response will include a trial_id to associate a subsequent log() call."
      },
      "HTTPValidationError": {
        "properties": {
          "detail": {
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "type": "array",
            "title": "Detail"
          }
        },
        "type": "object",
        "title": "HTTPValidationError"
      },
      "ImageChatContent": {
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "image_url"
            ],
            "title": "Type"
          },
          "image_url": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ImageUrl"
              }
            ],
            "title": "Image URL",
            "description": "The message's image content."
          }
        },
        "type": "object",
        "required": [
          "type",
          "image_url"
        ],
        "title": "ImageChatContent"
      },
      "ImageUrl": {
        "properties": {
          "url": {
            "type": "string",
            "title": "URL",
            "description": "Either a URL of the image or the base64 encoded image data."
          },
          "detail": {
            "type": "string",
            "enum": [
              "high",
              "low",
              "auto"
            ],
            "title": "Image detail level",
            "description": "Specify the detail level of the image provided to the model. For more details see: https://platform.openai.com/docs/guides/vision/low-or-high-fidelity-image-understanding"
          }
        },
        "type": "object",
        "required": [
          "url"
        ],
        "title": "ImageUrl"
      },
      "LabelSentiment": {
        "type": "string",
        "enum": [
          "positive",
          "negative",
          "neutral",
          "unset"
        ],
        "title": "LabelSentiment",
        "description": "How a label should be treated in calculating model config performance.\n\nUsed by a project's PAPV metric."
      },
      "LinkedToolRequest": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Tool ID",
            "description": "The ID of the linked tool. Starts with \"oc_\""
          },
          "source": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ToolSource"
              }
            ],
            "title": "Tool source",
            "description": "The source of the linked tool. For a linked tool it should be `organization`"
          },
          "name": {
            "type": "string",
            "title": "Tool name",
            "description": "The name of the linked tool."
          },
          "description": {
            "type": "string",
            "title": "Tool description",
            "description": "The description of the linked tool."
          },
          "parameters": {
            "type": "object",
            "title": "Tool parameters",
            "description": "The parameters of the linked tool."
          }
        },
        "type": "object",
        "required": [
          "id",
          "source"
        ],
        "title": "LinkedToolRequest"
      },
      "LogRequest": {
        "properties": {
          "project": {
            "type": "string",
            "title": "Project name",
            "description": "Unique project name. If no project exists with this name, a new project will be created."
          },
          "project_id": {
            "type": "string",
            "title": "Project ID",
            "description": "Unique ID of a project to associate to the log. Either this or `project` must be provided."
          },
          "session_id": {
            "type": "string",
            "title": "Session ID",
            "description": "ID of the session to associate the datapoint."
          },
          "session_reference_id": {
            "type": "string",
            "title": "Session Reference ID",
            "description": "A unique string identifying the session to associate the datapoint to. Allows you to log multiple datapoints to a session (using an ID kept by your internal systems) by passing the same `session_reference_id` in subsequent log requests. Specify at most one of this or `session_id`."
          },
          "parent_id": {
            "type": "string",
            "title": "Parent ID",
            "description": "ID associated to the parent datapoint in a session."
          },
          "parent_reference_id": {
            "type": "string",
            "title": "Parent Reference ID",
            "description": "A unique string identifying the previously-logged parent datapoint in a session. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a prior log request. Specify at most one of this or `parent_id`. Note that this cannot refer to a datapoint being logged in the same request."
          },
          "inputs": {
            "type": "object",
            "title": "Inputs",
            "description": "The inputs passed to the prompt template.",
            "default": {}
          },
          "source": {
            "type": "string",
            "title": "Source",
            "description": "Identifies where the model was called from."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Any additional metadata to record."
          },
          "source_datapoint_id": {
            "type": "string",
            "title": "Source datapoint ID",
            "description": "ID of the source datapoint if this is a log derived from a datapoint in a dataset."
          },
          "reference_id": {
            "type": "string",
            "title": "Reference ID",
            "description": "A unique string to reference the datapoint. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a subsequent log request."
          },
          "trial_id": {
            "type": "string",
            "title": "Trial ID",
            "description": "Unique ID of an experiment trial to associate to the log."
          },
          "messages": {
            "items": {
              "$ref": "#/components/schemas/ChatMessage"
            },
            "type": "array",
            "title": "Messages",
            "description": "The messages passed to the to provider chat endpoint."
          },
          "output": {
            "type": "string",
            "title": "Model output",
            "description": "Generated output from your model for the provided inputs. Can be `None` if logging an error, or if logging a parent datapoint with the intention to populate it later"
          },
          "config_id": {
            "type": "string",
            "title": "Config ID",
            "description": "Unique ID of a config to associate to the log."
          },
          "config": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/ModelConfigRequest"
              },
              {
                "$ref": "#/components/schemas/ToolConfigRequest"
              },
              {
                "$ref": "#/components/schemas/GenericConfigRequest"
              },
              {
                "$ref": "#/components/schemas/AgentConfigRequest"
              }
            ],
            "title": "Config",
            "description": "The model config used for this generation. Required unless `config_id` or `trial_id` is provided.",
            "discriminator": {
              "propertyName": "type",
              "mapping": {
                "model": "#/components/schemas/ModelConfigRequest",
                "tool": "#/components/schemas/ToolConfigRequest",
                "generic": "#/components/schemas/GenericConfigRequest",
                "agent": "#/components/schemas/AgentConfigRequest"
              }
            }
          },
          "environment": {
            "type": "string",
            "title": "Environment name",
            "description": "The environment name used to create the log."
          },
          "feedback": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Feedback"
              },
              {
                "items": {
                  "$ref": "#/components/schemas/Feedback"
                },
                "type": "array"
              }
            ],
            "title": "Feedback labels",
            "description": "Optional parameter to provide feedback with your logged datapoint."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "description": "User defined timestamp for when the log was created. "
          },
          "error": {
            "type": "string",
            "title": "Error",
            "description": "Error message if the log is an error."
          },
          "duration": {
            "type": "number",
            "title": "Duration",
            "description": "Duration of the logged event in seconds."
          },
          "output_message": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChatMessage"
              }
            ],
            "title": "Output message",
            "description": "The message returned by the provider."
          }
        },
        "type": "object",
        "title": "LogRequest",
        "description": "Request model for logging a datapoint."
      },
      "LogResponse": {
        "properties": {
          "project": {
            "type": "string",
            "title": "Project name",
            "description": "The name of the project associated with this log"
          },
          "project_id": {
            "type": "string",
            "title": "Project ID",
            "description": "The unique ID of the project associated with this log."
          },
          "session_id": {
            "type": "string",
            "title": "Session ID",
            "description": "ID of the session to associate the datapoint."
          },
          "session_reference_id": {
            "type": "string",
            "title": "Session Reference ID",
            "description": "A unique string identifying the session to associate the datapoint to. Allows you to log multiple datapoints to a session (using an ID kept by your internal systems) by passing the same `session_reference_id` in subsequent log requests. Specify at most one of this or `session_id`."
          },
          "parent_id": {
            "type": "string",
            "title": "Parent ID",
            "description": "ID associated to the parent datapoint in a session."
          },
          "parent_reference_id": {
            "type": "string",
            "title": "Parent Reference ID",
            "description": "A unique string identifying the previously-logged parent datapoint in a session. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a prior log request. Specify at most one of this or `parent_id`. Note that this cannot refer to a datapoint being logged in the same request."
          },
          "inputs": {
            "type": "object",
            "title": "Inputs",
            "description": "The inputs passed to the prompt template.",
            "default": {}
          },
          "source": {
            "type": "string",
            "title": "Source",
            "description": "Identifies where the model was called from."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Any additional metadata to record."
          },
          "source_datapoint_id": {
            "type": "string",
            "title": "Source datapoint ID",
            "description": "ID of the source datapoint if this is a log derived from a datapoint in a dataset."
          },
          "id": {
            "type": "string",
            "title": "Datapoint ID",
            "description": "String ID of logged datapoint. Starts with `data_`."
          },
          "reference_id": {
            "type": "string",
            "title": "Reference ID",
            "description": "Unique user-provided string identifying the datapoint."
          },
          "trial_id": {
            "type": "string",
            "title": "Trial ID",
            "description": "Unique ID of an experiment trial to associate to the log."
          },
          "messages": {
            "items": {
              "$ref": "#/components/schemas/ChatMessage"
            },
            "type": "array",
            "title": "Messages",
            "description": "The messages passed to the to provider chat endpoint."
          },
          "output": {
            "type": "string",
            "title": "Model output",
            "description": "Generated output from your model for the provided inputs. Can be `None` if logging an error, or if logging a parent datapoint with the intention to populate it later"
          },
          "config_id": {
            "type": "string",
            "title": "Config ID",
            "description": "Unique ID of a config to associate to the log."
          },
          "config": {
            "$ref": "#/components/schemas/ConfigResponse"
          },
          "environment": {
            "type": "string",
            "title": "Environment name",
            "description": "The environment name used to create the log."
          },
          "feedback": {
            "items": {
              "$ref": "#/components/schemas/FeedbackResponse"
            },
            "type": "array",
            "title": "Feedback"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created at",
            "description": "User defined timestamp for when the log was created. "
          },
          "error": {
            "type": "string",
            "title": "Error",
            "description": "Error message if the log is an error."
          },
          "duration": {
            "type": "number",
            "title": "Duration",
            "description": "Duration of the logged event in seconds."
          },
          "output_message": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ChatMessage"
              }
            ],
            "title": "Output message",
            "description": "The message returned by the provider."
          },
          "model_config": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ProjectConfigResponse"
              }
            ],
            "title": "Config",
            "description": "The config used for this datapoint."
          },
          "user": {
            "type": "string",
            "title": "User",
            "description": "User email address provided when creating the datapoint."
          },
          "provider_response": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "string"
              }
            ],
            "title": "Provider response",
            "description": "Original response from the provider."
          },
          "provider_latency": {
            "type": "number",
            "title": "Provider Latency",
            "description": "Latency of provider response."
          },
          "raw_output": {
            "type": "string",
            "title": "Raw output",
            "description": "Raw output from the provider."
          },
          "finish_reason": {
            "type": "string",
            "title": "Finish reason",
            "description": "Reason the generation finished."
          },
          "metric_values": {
            "items": {
              "$ref": "#/components/schemas/MetricValueResponse"
            },
            "type": "array",
            "title": "Metric Values"
          },
          "tools": {
            "items": {
              "$ref": "#/components/schemas/ToolResultResponse"
            },
            "type": "array",
            "title": "Tools"
          },
          "tool_choice": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "none"
                ]
              },
              {
                "type": "string",
                "enum": [
                  "auto"
                ]
              },
              {
                "$ref": "#/components/schemas/ToolChoice"
              }
            ],
            "title": "Tool choice",
            "description": "Controls how the model uses tools. The following options are supported: 'none' forces the model to not call a tool; the default when no tools are provided as part of the model config. 'auto' the model can decide to call one of the provided tools; the default when tools are provided as part of the model config. Providing {'type': 'function', 'function': {name': <TOOL_NAME>}} forces the model to use the named function."
          },
          "evaluation_results": {
            "items": {
              "$ref": "#/components/schemas/EvaluationResultResponse"
            },
            "type": "array",
            "title": "Evaluation Results"
          },
          "observability_status": {
            "$ref": "#/components/schemas/ObservabilityStatus"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At"
          }
        },
        "type": "object",
        "required": [
          "id",
          "config",
          "evaluation_results",
          "observability_status",
          "updated_at"
        ],
        "title": "LogResponse",
        "description": "Request model for logging a datapoint."
      },
      "MetricValueResponse": {
        "properties": {
          "metric_id": {
            "type": "string",
            "title": "Metric Id"
          },
          "metric_name": {
            "type": "string",
            "title": "Metric Name"
          },
          "metric_value": {
            "type": "number",
            "title": "Metric Value"
          }
        },
        "type": "object",
        "required": [
          "metric_id",
          "metric_name",
          "metric_value"
        ],
        "title": "MetricValueResponse"
      },
      "ModelConfigChatRequest": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Model config name",
            "description": "A friendly display name for the model config. If not provided, a name will be generated."
          },
          "description": {
            "type": "string",
            "title": "Model config description",
            "description": "A description of the model config."
          },
          "provider": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelProviders"
              }
            ],
            "title": "Model provider",
            "description": "The company providing the underlying model service.",
            "default": "openai"
          },
          "model": {
            "type": "string",
            "title": "Model instance used",
            "description": "The model instance used. E.g. text-davinci-002."
          },
          "max_tokens": {
            "type": "integer",
            "title": "Maximum tokens",
            "description": "The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt",
            "default": -1
          },
          "temperature": {
            "type": "number",
            "title": "Sampling temperature",
            "description": "What sampling temperature to use when making a generation. Higher values means the model will be more creative.",
            "default": 1
          },
          "top_p": {
            "type": "number",
            "title": "Top p probability mass",
            "description": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.",
            "default": 1
          },
          "stop": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            ],
            "title": "Stop sequence(s)",
            "description": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence."
          },
          "presence_penalty": {
            "type": "number",
            "title": "Penalize tokens on whether present.",
            "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.",
            "default": 0
          },
          "frequency_penalty": {
            "type": "number",
            "title": "Penalize tokens on whether frequent.",
            "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.",
            "default": 0
          },
          "other": {
            "type": "object",
            "title": "Other provider parameters",
            "description": "Other parameter values to be passed to the provider call.",
            "default": {}
          },
          "seed": {
            "type": "integer",
            "title": "Seed",
            "description": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed."
          },
          "response_format": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ResponseFormat"
              }
            ],
            "title": "Response format",
            "description": "The format of the response. Only type json_object is currently supported for chat."
          },
          "endpoint": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelEndpoints"
              }
            ],
            "title": "Provider endpoint",
            "description": "The provider model endpoint used.",
            "default": "chat"
          },
          "chat_template": {
            "items": {
              "$ref": "#/components/schemas/ChatMessage"
            },
            "type": "array",
            "title": "Chat template",
            "description": "Messages prepended to the list of messages sent to the provider. These messages that will take your specified inputs to form your final request to the provider model. Input variables within the template should be specified with syntax: {{INPUT_NAME}}."
          },
          "tools": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/LinkedToolRequest"
                },
                {
                  "$ref": "#/components/schemas/ModelConfigToolRequest"
                }
              ]
            },
            "type": "array",
            "title": "Tools - equivalent to OpenAI functions.",
            "description": "Make tools available to OpenAIs chat model as functions."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "model"
        ],
        "title": "ModelConfigChatRequest",
        "description": "Chat model config request."
      },
      "ModelConfigCompletionRequest": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Model config name",
            "description": "A friendly display name for the model config. If not provided, a name will be generated."
          },
          "description": {
            "type": "string",
            "title": "Model config description",
            "description": "A description of the model config."
          },
          "provider": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelProviders"
              }
            ],
            "title": "Model provider",
            "description": "The company providing the underlying model service.",
            "default": "openai"
          },
          "model": {
            "type": "string",
            "title": "Model instance used",
            "description": "The model instance used. E.g. text-davinci-002."
          },
          "max_tokens": {
            "type": "integer",
            "title": "Maximum tokens",
            "description": "The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt",
            "default": -1
          },
          "temperature": {
            "type": "number",
            "title": "Sampling temperature",
            "description": "What sampling temperature to use when making a generation. Higher values means the model will be more creative.",
            "default": 1
          },
          "top_p": {
            "type": "number",
            "title": "Top p probability mass",
            "description": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.",
            "default": 1
          },
          "stop": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            ],
            "title": "Stop sequence(s)",
            "description": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence."
          },
          "presence_penalty": {
            "type": "number",
            "title": "Penalize tokens on whether present.",
            "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.",
            "default": 0
          },
          "frequency_penalty": {
            "type": "number",
            "title": "Penalize tokens on whether frequent.",
            "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.",
            "default": 0
          },
          "other": {
            "type": "object",
            "title": "Other provider parameters",
            "description": "Other parameter values to be passed to the provider call.",
            "default": {}
          },
          "seed": {
            "type": "integer",
            "title": "Seed",
            "description": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed."
          },
          "response_format": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ResponseFormat"
              }
            ],
            "title": "Response format",
            "description": "The format of the response. Only type json_object is currently supported for chat."
          },
          "endpoint": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelEndpoints"
              }
            ],
            "title": "Provider endpoint",
            "description": "The provider model endpoint used.",
            "default": "complete"
          },
          "prompt_template": {
            "type": "string",
            "title": "Prompt template",
            "description": "Prompt template that will take your specified inputs to form your final request to the model. Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "model"
        ],
        "title": "ModelConfigCompletionRequest",
        "description": "Completion model config request"
      },
      "ModelConfigEvaluatorAggregateResponse": {
        "properties": {
          "model_config_id": {
            "type": "string",
            "title": "Model Config Id"
          },
          "evaluator_id": {
            "type": "string",
            "title": "Evaluator Id"
          },
          "aggregate_value": {
            "title": "Aggregate Value"
          }
        },
        "type": "object",
        "required": [
          "model_config_id",
          "evaluator_id"
        ],
        "title": "ModelConfigEvaluatorAggregateResponse"
      },
      "ModelConfigRequest": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Model config name",
            "description": "A friendly display name for the model config. If not provided, a name will be generated."
          },
          "description": {
            "type": "string",
            "title": "Model config description",
            "description": "A description of the model config."
          },
          "provider": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelProviders"
              }
            ],
            "title": "Model provider",
            "description": "The company providing the underlying model service.",
            "default": "openai"
          },
          "model": {
            "type": "string",
            "title": "Model instance used",
            "description": "The model instance used. E.g. text-davinci-002."
          },
          "max_tokens": {
            "type": "integer",
            "title": "Maximum tokens",
            "description": "The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt",
            "default": -1
          },
          "temperature": {
            "type": "number",
            "title": "Sampling temperature",
            "description": "What sampling temperature to use when making a generation. Higher values means the model will be more creative.",
            "default": 1
          },
          "top_p": {
            "type": "number",
            "title": "Top p probability mass",
            "description": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.",
            "default": 1
          },
          "stop": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            ],
            "title": "Stop sequence(s)",
            "description": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence."
          },
          "presence_penalty": {
            "type": "number",
            "title": "Penalize tokens on whether present.",
            "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.",
            "default": 0
          },
          "frequency_penalty": {
            "type": "number",
            "title": "Penalize tokens on whether frequent.",
            "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.",
            "default": 0
          },
          "other": {
            "type": "object",
            "title": "Other provider parameters",
            "description": "Other parameter values to be passed to the provider call.",
            "default": {}
          },
          "seed": {
            "type": "integer",
            "title": "Seed",
            "description": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed."
          },
          "response_format": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ResponseFormat"
              }
            ],
            "title": "Response format",
            "description": "The format of the response. Only type json_object is currently supported for chat."
          },
          "endpoint": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelEndpoints"
              }
            ],
            "title": "Provider endpoint",
            "description": "The provider model endpoint used.",
            "default": "complete"
          },
          "prompt_template": {
            "type": "string",
            "title": "Prompt template",
            "description": "Prompt template that will take your specified inputs to form your final request to the model. Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}."
          },
          "chat_template": {
            "items": {
              "$ref": "#/components/schemas/ChatMessage"
            },
            "type": "array",
            "title": "Chat template",
            "description": "Messages prepended to the list of messages sent to the provider. These messages that will take your specified inputs to form your final request to the provider model. Input variables within the template should be specified with syntax: {{INPUT_NAME}}."
          },
          "tools": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/LinkedToolRequest"
                },
                {
                  "$ref": "#/components/schemas/ModelConfigToolRequest"
                }
              ]
            },
            "type": "array",
            "title": "Tools - equivalent to OpenAI functions.",
            "description": "Make tools available to OpenAIs chat model as functions."
          },
          "type": {
            "type": "string",
            "enum": [
              "model"
            ],
            "title": "Type"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "model"
        ],
        "title": "ModelConfigRequest",
        "description": "Model config used for logging both chat and completion."
      },
      "ModelConfigResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Config ID",
            "description": "String ID of config. Starts with `config_`."
          },
          "other": {
            "type": "object",
            "title": "Other provider parameters",
            "description": "Other parameter values to be passed to the provider call.",
            "default": {}
          },
          "type": {
            "type": "string",
            "enum": [
              "model"
            ],
            "title": "Type"
          },
          "name": {
            "type": "string",
            "title": "Model config name",
            "description": "A friendly display name for the model config. If not provided, a name will be generated."
          },
          "description": {
            "type": "string",
            "title": "Model config description",
            "description": "A description of the model config."
          },
          "provider": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelProviders"
              }
            ],
            "title": "Model provider",
            "description": "The company providing the underlying model service.",
            "default": "openai"
          },
          "model": {
            "type": "string",
            "title": "Model instance used",
            "description": "The model instance used. E.g. text-davinci-002."
          },
          "max_tokens": {
            "type": "integer",
            "title": "Maximum tokens",
            "description": "The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt",
            "default": -1
          },
          "temperature": {
            "type": "number",
            "title": "Sampling temperature",
            "description": "What sampling temperature to use when making a generation. Higher values means the model will be more creative.",
            "default": 1
          },
          "top_p": {
            "type": "number",
            "title": "Top p probability mass",
            "description": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.",
            "default": 1
          },
          "stop": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            ],
            "title": "Stop sequence(s)",
            "description": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence."
          },
          "presence_penalty": {
            "type": "number",
            "title": "Penalize tokens on whether present.",
            "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.",
            "default": 0
          },
          "frequency_penalty": {
            "type": "number",
            "title": "Penalize tokens on whether frequent.",
            "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.",
            "default": 0
          },
          "seed": {
            "type": "integer",
            "title": "Seed",
            "description": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed."
          },
          "response_format": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ResponseFormat"
              }
            ],
            "title": "Response format",
            "description": "The format of the response. Only type json_object is currently supported for chat."
          },
          "prompt_template": {
            "type": "string",
            "title": "Prompt template",
            "description": "Prompt template that will take your specified inputs to form your final request to the model. NB: Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}."
          },
          "chat_template": {
            "items": {
              "$ref": "#/components/schemas/ChatMessage"
            },
            "type": "array",
            "title": "Chat template",
            "description": "Messages prepended to the list of messages sent to the provider. These messages that will take your specified inputs to form your final request to the provider model. NB: Input variables within the template should be specified with syntax: {{INPUT_NAME}}."
          },
          "tool_configs": {
            "items": {
              "$ref": "#/components/schemas/ToolConfigResponse"
            },
            "type": "array",
            "title": "Tool configs",
            "description": "NB: Deprecated with tools field. Definition of tools shown to the model.",
            "deprecated": true
          },
          "tools": {
            "items": {
              "$ref": "#/components/schemas/ToolResponse"
            },
            "type": "array",
            "title": "Tools",
            "description": "Tools shown to the model."
          },
          "endpoint": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelEndpoints"
              }
            ],
            "title": "Provider endpoint",
            "description": "The provider model endpoint used."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "id",
          "type",
          "model"
        ],
        "title": "ModelConfigResponse",
        "description": "Model config request.\n\nContains fields that are common to all (i.e. both chat and complete) endpoints."
      },
      "ModelConfigToolRequest": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Tool name",
            "description": "The name of the tool shown to the model."
          },
          "description": {
            "type": "string",
            "title": "Tool description",
            "description": "The description of the tool shown to the model."
          },
          "parameters": {
            "type": "object",
            "title": "Schema of tool arguments.",
            "description": "Definition of parameters needed to run the tool. Provided in jsonschema format: https://json-schema.org/"
          },
          "source": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ToolSource"
              }
            ],
            "title": "Source",
            "description": "Source of the tool. If defined at an organization level will be 'organization' else 'inline'."
          },
          "source_code": {
            "type": "string",
            "title": "Code source",
            "description": "Code source of the tool."
          },
          "other": {
            "type": "object",
            "title": "Other parameters",
            "description": "Other parameters that define the config."
          },
          "preset_name": {
            "type": "string",
            "title": "preset_name",
            "description": "If is_preset = true, this is the name of the preset tool on Humanloop. This is used as the key to look up the Humanloop runtime of the tool"
          }
        },
        "type": "object",
        "required": [
          "name"
        ],
        "title": "ModelConfigToolRequest",
        "description": "Definition of tool within a model config.\n\nThe subset of ToolConfig parameters received by the chat endpoint.\nDoes not have things like the signature or setup schema."
      },
      "ModelEndpoints": {
        "type": "string",
        "enum": [
          "complete",
          "chat",
          "edit"
        ],
        "title": "ModelEndpoints",
        "description": "Supported model provider endpoints."
      },
      "ModelProviders": {
        "type": "string",
        "enum": [
          "openai",
          "openai_azure",
          "ai21",
          "mock",
          "anthropic",
          "langchain",
          "cohere",
          "replicate"
        ],
        "title": "ModelProviders",
        "description": "Supported model providers."
      },
      "ObservabilityStatus": {
        "type": "string",
        "enum": [
          "pending",
          "running",
          "completed",
          "failed"
        ],
        "title": "ObservabilityStatus",
        "description": "Status of a project datum for observability."
      },
      "PaginatedData_DatapointResponse_": {
        "properties": {
          "records": {
            "items": {
              "$ref": "#/components/schemas/DatapointResponse"
            },
            "type": "array",
            "title": "Records"
          },
          "page": {
            "type": "integer",
            "title": "Page"
          },
          "size": {
            "type": "integer",
            "title": "Size"
          },
          "total": {
            "type": "integer",
            "title": "Total"
          }
        },
        "type": "object",
        "required": [
          "records",
          "page",
          "size",
          "total"
        ],
        "title": "PaginatedData[DatapointResponse]"
      },
      "PaginatedData_EvaluationDatapointSnapshotResponse_": {
        "properties": {
          "records": {
            "items": {
              "$ref": "#/components/schemas/EvaluationDatapointSnapshotResponse"
            },
            "type": "array",
            "title": "Records"
          },
          "page": {
            "type": "integer",
            "title": "Page"
          },
          "size": {
            "type": "integer",
            "title": "Size"
          },
          "total": {
            "type": "integer",
            "title": "Total"
          }
        },
        "type": "object",
        "required": [
          "records",
          "page",
          "size",
          "total"
        ],
        "title": "PaginatedData[EvaluationDatapointSnapshotResponse]"
      },
      "PaginatedData_LogResponse_": {
        "properties": {
          "records": {
            "items": {
              "$ref": "#/components/schemas/LogResponse"
            },
            "type": "array",
            "title": "Records"
          },
          "page": {
            "type": "integer",
            "title": "Page"
          },
          "size": {
            "type": "integer",
            "title": "Size"
          },
          "total": {
            "type": "integer",
            "title": "Total"
          }
        },
        "type": "object",
        "required": [
          "records",
          "page",
          "size",
          "total"
        ],
        "title": "PaginatedData[LogResponse]"
      },
      "PaginatedData_ProjectResponse_": {
        "properties": {
          "records": {
            "items": {
              "$ref": "#/components/schemas/ProjectResponse"
            },
            "type": "array",
            "title": "Records"
          },
          "page": {
            "type": "integer",
            "title": "Page"
          },
          "size": {
            "type": "integer",
            "title": "Size"
          },
          "total": {
            "type": "integer",
            "title": "Total"
          }
        },
        "type": "object",
        "required": [
          "records",
          "page",
          "size",
          "total"
        ],
        "title": "PaginatedData[ProjectResponse]"
      },
      "PaginatedData_SessionResponse_": {
        "properties": {
          "records": {
            "items": {
              "$ref": "#/components/schemas/SessionResponse"
            },
            "type": "array",
            "title": "Records"
          },
          "page": {
            "type": "integer",
            "title": "Page"
          },
          "size": {
            "type": "integer",
            "title": "Size"
          },
          "total": {
            "type": "integer",
            "title": "Total"
          }
        },
        "type": "object",
        "required": [
          "records",
          "page",
          "size",
          "total"
        ],
        "title": "PaginatedData[SessionResponse]"
      },
      "PositiveLabel": {
        "properties": {
          "type": {
            "type": "string",
            "title": "Feedback type"
          },
          "value": {
            "type": "string",
            "title": "Feedback value"
          }
        },
        "type": "object",
        "required": [
          "type",
          "value"
        ],
        "title": "PositiveLabel"
      },
      "ProjectConfigResponse": {
        "properties": {
          "project_id": {
            "type": "string",
            "title": "Project ID",
            "description": "String ID of project the model config belongs to. Starts with `pr_`."
          },
          "project_name": {
            "type": "string",
            "title": "Project name",
            "description": "Name of the project the model config belongs to."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At"
          },
          "last_used": {
            "type": "string",
            "format": "date-time",
            "title": "Last Used"
          },
          "feedback_stats": {
            "items": {
              "$ref": "#/components/schemas/ProjectModelConfigFeedbackStatsResponse"
            },
            "type": "array",
            "title": "Feedback statistics",
            "description": "Feedback statistics for the project model config."
          },
          "num_datapoints": {
            "type": "integer",
            "title": "Number of datapoints",
            "description": "Number of datapoints associated with this project model config."
          },
          "experiment_id": {
            "type": "string",
            "title": "Experiment ID",
            "description": "The ID of the experiment the model config has been registered to. Only populated when registering a model config to an experiment."
          },
          "evaluation_aggregates": {
            "items": {
              "$ref": "#/components/schemas/ModelConfigEvaluatorAggregateResponse"
            },
            "type": "array",
            "title": "Evaluator aggregates",
            "description": "Aggregates of evaluators for the model config."
          },
          "config": {
            "$ref": "#/components/schemas/ConfigResponse"
          }
        },
        "type": "object",
        "required": [
          "project_id",
          "project_name",
          "created_at",
          "updated_at",
          "last_used",
          "config"
        ],
        "title": "ProjectConfigResponse"
      },
      "ProjectInputResponse": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Input name",
            "description": "Type of input."
          }
        },
        "type": "object",
        "required": [
          "name"
        ],
        "title": "ProjectInputResponse"
      },
      "ProjectModelConfigFeedbackStatsResponse": {
        "properties": {
          "feedback_type_id": {
            "type": "integer",
            "title": "Feedback Type Id"
          },
          "feedback_type": {
            "type": "string",
            "title": "Feedback Type"
          },
          "feedback_value": {
            "type": "string",
            "title": "Feedback Value"
          },
          "feedback_count": {
            "type": "integer",
            "title": "Feedback Count"
          }
        },
        "type": "object",
        "required": [
          "feedback_type_id",
          "feedback_type",
          "feedback_value",
          "feedback_count"
        ],
        "title": "ProjectModelConfigFeedbackStatsResponse"
      },
      "ProjectModelConfigRequest": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Model config name",
            "description": "A friendly display name for the model config. If not provided, a name will be generated."
          },
          "description": {
            "type": "string",
            "title": "Model config description",
            "description": "A description of the model config."
          },
          "provider": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelProviders"
              }
            ],
            "title": "Model provider",
            "description": "The company providing the underlying model service.",
            "default": "openai"
          },
          "model": {
            "type": "string",
            "title": "Model instance used",
            "description": "The model instance used. E.g. text-davinci-002."
          },
          "max_tokens": {
            "type": "integer",
            "title": "Maximum tokens",
            "description": "The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt",
            "default": -1
          },
          "temperature": {
            "type": "number",
            "title": "Sampling temperature",
            "description": "What sampling temperature to use when making a generation. Higher values means the model will be more creative.",
            "default": 1
          },
          "top_p": {
            "type": "number",
            "title": "Top p probability mass",
            "description": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.",
            "default": 1
          },
          "stop": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            ],
            "title": "Stop sequence(s)",
            "description": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence."
          },
          "presence_penalty": {
            "type": "number",
            "title": "Penalize tokens on whether present.",
            "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.",
            "default": 0
          },
          "frequency_penalty": {
            "type": "number",
            "title": "Penalize tokens on whether frequent.",
            "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.",
            "default": 0
          },
          "other": {
            "type": "object",
            "title": "Other provider parameters",
            "description": "Other parameter values to be passed to the provider call.",
            "default": {}
          },
          "seed": {
            "type": "integer",
            "title": "Seed",
            "description": "If specified, model will make a best effort to sample deterministically, but it is not guaranteed."
          },
          "response_format": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ResponseFormat"
              }
            ],
            "title": "Response format",
            "description": "The format of the response. Only type json_object is currently supported for chat."
          },
          "project": {
            "type": "string",
            "title": "Project name",
            "description": "Unique project name. If it does not exist, a new project will be created."
          },
          "project_id": {
            "type": "string",
            "title": "Project ID",
            "description": "Unique project ID"
          },
          "experiment": {
            "type": "string",
            "title": "Experiment name",
            "description": "If specified, the model config will be added to this experiment. Experiments are used for A/B testing and optimizing hyperparameters."
          },
          "prompt_template": {
            "type": "string",
            "title": "Prompt template",
            "description": "Prompt template that will take your specified inputs to form your final request to the provider model. NB: Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}."
          },
          "chat_template": {
            "items": {
              "$ref": "#/components/schemas/ChatMessage"
            },
            "type": "array",
            "title": "Chat template",
            "description": "Messages prepended to the list of messages sent to the provider. These messages that will take your specified inputs to form your final request to the provider model. NB: Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}."
          },
          "endpoint": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelEndpoints"
              }
            ],
            "title": "Provider endpoint",
            "description": "Which of the providers model endpoints to use. For example Complete or Edit.",
            "default": "complete"
          },
          "tools": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/LinkedToolRequest"
                },
                {
                  "$ref": "#/components/schemas/ModelConfigToolRequest"
                }
              ]
            },
            "type": "array",
            "title": "Tools - equivalent to OpenAI functions.",
            "description": "Make tools available to OpenAIs chat model as functions."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "model"
        ],
        "title": "ProjectModelConfigRequest",
        "description": "Model config request.\n\nContains fields that are common to all (i.e. both chat and complete) endpoints."
      },
      "ProjectResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Project ID",
            "description": "Project ID"
          },
          "name": {
            "type": "string",
            "title": "Project name",
            "description": "Unique project name."
          },
          "active_experiment": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ExperimentResponse"
              }
            ],
            "title": "Active experiment",
            "description": "Experiment that has been set as the project's active deployment. At most one of active_experiment and active_model_config can be set."
          },
          "active_config": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ProjectConfigResponse"
              }
            ],
            "title": "Active config",
            "description": "Config that has been set as the project's active deployment. At most one of active_experiment and active_model_config can be set."
          },
          "users": {
            "items": {
              "$ref": "#/components/schemas/ProjectUserResponse"
            },
            "type": "array",
            "title": "Project users",
            "description": "Users associated to the project."
          },
          "data_count": {
            "type": "integer",
            "title": "Number of datapoints",
            "description": "The count of datapoints that have been logged to the project."
          },
          "feedback_types": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FeedbackTypes"
              }
            ],
            "title": "Feedback types",
            "description": "The feedback types that have been defined in the project."
          },
          "team_id": {
            "type": "string",
            "title": "Team ID",
            "description": "Unique ID of the team the project belongs to. Starts with `tm_`."
          },
          "config_type": {
            "$ref": "#/components/schemas/ConfigType"
          },
          "active_evaluators": {
            "items": {
              "$ref": "#/components/schemas/EvaluatorResponse"
            },
            "type": "array",
            "title": "Active evaluators",
            "description": "Evaluators that have been set as active for the project."
          },
          "directory_id": {
            "type": "string",
            "title": "Directory ID",
            "description": "String ID of the directory the project belongs to. Starts with `dir_`."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "users",
          "data_count",
          "feedback_types",
          "team_id",
          "created_at",
          "updated_at"
        ],
        "title": "ProjectResponse"
      },
      "ProjectSortBy": {
        "type": "string",
        "enum": [
          "created_at",
          "updated_at",
          "name"
        ],
        "title": "ProjectSortBy",
        "description": "An enumeration."
      },
      "ProjectUserResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "User ID",
            "description": "String ID of user. Starts with `usr_`."
          },
          "email_address": {
            "type": "string",
            "title": "Email address",
            "description": "The user's email address."
          },
          "full_name": {
            "type": "string",
            "title": "Full name",
            "description": "The user's full name."
          }
        },
        "type": "object",
        "required": [
          "id",
          "email_address"
        ],
        "title": "ProjectUserResponse"
      },
      "ProviderApiKeys": {
        "properties": {
          "openai": {
            "type": "string",
            "title": "Openai"
          },
          "ai21": {
            "type": "string",
            "title": "Ai21"
          },
          "mock": {
            "type": "string",
            "title": "Mock"
          },
          "anthropic": {
            "type": "string",
            "title": "Anthropic"
          },
          "cohere": {
            "type": "string",
            "title": "Cohere"
          },
          "openai_azure": {
            "type": "string",
            "title": "Openai Azure"
          },
          "openai_azure_endpoint": {
            "type": "string",
            "title": "Openai Azure Endpoint"
          }
        },
        "type": "object",
        "title": "ProviderApiKeys"
      },
      "ResponseFormat": {
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "json_object"
            ],
            "title": "Type"
          }
        },
        "type": "object",
        "required": [
          "type"
        ],
        "title": "ResponseFormat",
        "description": "Response format of the model."
      },
      "SessionProjectResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Project ID",
            "description": "String ID of project the datapoint belongs to. Starts with `pr_`."
          },
          "name": {
            "type": "string",
            "title": "Project name"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name"
        ],
        "title": "SessionProjectResponse"
      },
      "SessionResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Session ID",
            "description": "String ID of session. Starts with `sesh_`."
          },
          "reference_id": {
            "type": "string",
            "title": "Reference ID",
            "description": "Unique user-provided string identifying the session."
          },
          "projects": {
            "items": {
              "$ref": "#/components/schemas/SessionProjectResponse"
            },
            "type": "array",
            "title": "Projects",
            "description": "List of projects that have datapoints associated to this session."
          },
          "datapoints_count": {
            "type": "integer",
            "title": "Datapoints count",
            "description": "Number of datapoints associated to this session."
          },
          "first_inputs": {
            "type": "object",
            "title": "First inputs",
            "description": "Inputs for the first datapoint in the session."
          },
          "last_output": {
            "type": "string",
            "title": "Last output",
            "description": "Output for the last datapoint in the session."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At"
          }
        },
        "type": "object",
        "required": [
          "id",
          "projects",
          "datapoints_count",
          "created_at",
          "updated_at"
        ],
        "title": "SessionResponse"
      },
      "SortOrder": {
        "type": "string",
        "enum": [
          "asc",
          "desc"
        ],
        "title": "SortOrder",
        "description": "An enumeration."
      },
      "TextChatContent": {
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "text"
            ],
            "title": "Type"
          },
          "text": {
            "type": "string",
            "title": "Text",
            "description": "The message's text content."
          }
        },
        "type": "object",
        "required": [
          "type",
          "text"
        ],
        "title": "TextChatContent"
      },
      "TimeUnit": {
        "type": "string",
        "enum": [
          "day",
          "week",
          "month"
        ],
        "title": "TimeUnit",
        "description": "An enumeration."
      },
      "ToolCall": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id"
          },
          "type": {
            "$ref": "#/components/schemas/ToolType"
          },
          "function": {
            "$ref": "#/components/schemas/FunctionTool"
          }
        },
        "type": "object",
        "required": [
          "id",
          "type",
          "function"
        ],
        "title": "ToolCall",
        "description": "A tool call to be made."
      },
      "ToolChoice": {
        "properties": {
          "type": {
            "$ref": "#/components/schemas/ToolType"
          },
          "function": {
            "$ref": "#/components/schemas/FunctionToolChoice"
          }
        },
        "type": "object",
        "required": [
          "type",
          "function"
        ],
        "title": "ToolChoice",
        "description": "Tool choice to force the model to use a tool."
      },
      "ToolConfigRequest": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Tool name",
            "description": "The name of the tool shown to the model."
          },
          "description": {
            "type": "string",
            "title": "Tool description",
            "description": "The description of the tool shown to the model."
          },
          "parameters": {
            "type": "object",
            "title": "Schema of tool arguments.",
            "description": "Definition of parameters needed to run the tool. Provided in jsonschema format: https://json-schema.org/"
          },
          "source": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ToolSource"
              }
            ],
            "title": "Source",
            "description": "Source of the tool. If defined at an organization level will be 'organization' else 'inline'."
          },
          "source_code": {
            "type": "string",
            "title": "Code source",
            "description": "Code source of the tool."
          },
          "other": {
            "type": "object",
            "title": "Other parameters",
            "description": "Other parameters that define the config."
          },
          "preset_name": {
            "type": "string",
            "title": "preset_name",
            "description": "If is_preset = true, this is the name of the preset tool on Humanloop. This is used as the key to look up the Humanloop runtime of the tool"
          },
          "type": {
            "type": "string",
            "enum": [
              "tool"
            ],
            "title": "Type"
          }
        },
        "type": "object",
        "required": [
          "name",
          "type"
        ],
        "title": "ToolConfigRequest",
        "description": "Definition of tool within a model config.\n\nThe subset of ToolConfig parameters received by the chat endpoint.\nDoes not have things like the signature or setup schema."
      },
      "ToolConfigResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Config ID",
            "description": "String ID of config. Starts with `config_`."
          },
          "other": {
            "type": "object",
            "title": "Other parameters",
            "description": "Other parameters that define the config."
          },
          "type": {
            "type": "string",
            "enum": [
              "tool"
            ],
            "title": "Type"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Name for the tool referenced by the model."
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Description of the tool referenced by the model"
          },
          "source": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ToolSource"
              }
            ],
            "title": "Source",
            "description": "Source of the tool. If defined at an organization level will be 'organiztion' else 'inline'."
          },
          "source_code": {
            "type": "string",
            "title": "Source Code",
            "description": "Code source of the tool."
          },
          "setup_schema": {
            "type": "object",
            "title": "Setup arguments schema.",
            "description": "Definition of parameters needed to run the tool. Provided in jsonschema format: https://json-schema.org/"
          },
          "parameters": {
            "type": "object",
            "title": "Run arguments schema.",
            "description": "Definition of parameters needed to run the tool. Provided in jsonschema format: https://json-schema.org/"
          },
          "signature": {
            "type": "string",
            "title": "Signature",
            "description": "The function signature of the tool when being called."
          },
          "is_preset": {
            "type": "boolean",
            "title": "Is preset",
            "description": "Whether the tool is one where Humanloop defines runtime or not."
          },
          "preset_name": {
            "type": "string",
            "title": "preset_name",
            "description": "If is_preset = true, this is the name of the preset tool on Humanloop. This is used as the key to lookup the Humanloop runtime of the tool"
          }
        },
        "type": "object",
        "required": [
          "id",
          "type",
          "name"
        ],
        "title": "ToolConfigResponse"
      },
      "ToolResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Tool ID",
            "description": "The ID of the tool. Starts with either `config_` or `oc_`."
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Name for the tool referenced by the model."
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Description of the tool referenced by the model"
          },
          "parameters": {
            "type": "object",
            "title": "Run arguments schema.",
            "description": "Definition of parameters needed to run the tool. Provided in jsonschema format: https://json-schema.org/"
          },
          "source": {
            "type": "string",
            "title": "Origin",
            "description": "The origin of the tool"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name"
        ],
        "title": "ToolResponse"
      },
      "ToolResultResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id"
          },
          "name": {
            "type": "string",
            "title": "Name"
          },
          "signature": {
            "type": "string",
            "title": "Signature"
          },
          "result": {
            "type": "string",
            "title": "Result"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "signature",
          "result"
        ],
        "title": "ToolResultResponse",
        "description": "A result from a tool used to populate the prompt template"
      },
      "ToolSource": {
        "type": "string",
        "enum": [
          "organization",
          "inline"
        ],
        "title": "ToolSource",
        "description": "Source of tool, either defined at the organization level or inline."
      },
      "ToolType": {
        "type": "string",
        "enum": [
          "function"
        ],
        "title": "ToolType",
        "description": "The type of tool to call."
      },
      "UpdateDatapointRequest": {
        "properties": {
          "inputs": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "title": "Inputs",
            "description": "The inputs to the prompt template for this datapoint."
          },
          "messages": {
            "items": {
              "$ref": "#/components/schemas/ChatMessage"
            },
            "type": "array",
            "title": "Chat messages",
            "description": "The chat messages for this datapoint."
          },
          "target": {
            "additionalProperties": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "number"
                },
                {
                  "type": "boolean"
                },
                {
                  "type": "object"
                },
                {
                  "items": {},
                  "type": "array"
                }
              ]
            },
            "type": "object",
            "title": "Target",
            "description": "Object with criteria necessary to evaluate this datapoint."
          }
        },
        "type": "object",
        "title": "UpdateDatapointRequest"
      },
      "UpdateDatasetRequest": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 255,
            "title": "Name",
            "description": "The name of the dataset."
          },
          "description": {
            "type": "string",
            "maxLength": 255,
            "title": "Description",
            "description": "The description of the dataset."
          }
        },
        "type": "object",
        "title": "UpdateDatasetRequest"
      },
      "UpdateEvaluationStatusRequest": {
        "properties": {
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EvaluationStatus"
              }
            ],
            "title": "Evaluation status",
            "description": "The new status of the evaluation."
          }
        },
        "type": "object",
        "required": [
          "status"
        ],
        "title": "UpdateEvaluationStatusRequest"
      },
      "UpdateEvaluatorRequest": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The name of the evaluator."
          },
          "description": {
            "type": "string",
            "maxLength": 255,
            "title": "Description",
            "description": "The description of the evaluator."
          },
          "arguments_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EvaluatorArgumentsType"
              }
            ],
            "title": "Arguments type",
            "description": "Whether this evaluator is target-free or target-required."
          },
          "return_type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EvaluatorReturnTypeEnum"
              }
            ],
            "title": "Return type",
            "description": "The type of the return value of the evaluator."
          },
          "code": {
            "type": "string",
            "title": "Code",
            "description": "The code for the evaluator. This code will be executed in a sandboxed environment."
          },
          "model_config": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelConfigCompletionRequest"
              }
            ],
            "title": "Model configuration",
            "description": "The model configuration used to generate."
          }
        },
        "type": "object",
        "title": "UpdateEvaluatorRequest"
      },
      "UpdateExperimentRequest": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Experiment name",
            "description": "Name of experiment."
          },
          "positive_labels": {
            "items": {
              "$ref": "#/components/schemas/PositiveLabel"
            },
            "type": "array",
            "title": "Positive labels",
            "description": "Feedback labels to treat as positive user feedback. Used to monitor the performance of model configs in the experiment."
          },
          "config_ids_to_register": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Model config IDs to register",
            "description": "Model configs to add to this experiment."
          },
          "config_ids_to_deregister": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Model config IDs to deregister",
            "description": "Model configs in this experiment to be deactivated."
          }
        },
        "type": "object",
        "title": "UpdateExperimentRequest"
      },
      "UpdateFinetuneRequest": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          }
        },
        "type": "object",
        "title": "UpdateFinetuneRequest"
      },
      "UpdateLogRequest": {
        "properties": {
          "output": {
            "type": "string",
            "title": "Model output",
            "description": "Generated output from your model for the provided inputs."
          },
          "error": {
            "type": "string",
            "title": "Error",
            "description": "Error message if the log is an error."
          },
          "duration": {
            "type": "number",
            "title": "Duration",
            "description": "Duration of the logged event in seconds."
          }
        },
        "type": "object",
        "title": "UpdateLogRequest"
      },
      "UpdateProjectRequest": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Project name",
            "description": "The new unique project name. Caution, if you are using the project name as the unique identifier in your API calls, changing the name will break the calls."
          },
          "active_experiment_id": {
            "type": "string",
            "title": "Active experiment ID",
            "description": "ID for an experiment to set as the project's active deployment. Starts with 'exp_'. At most one of 'active_experiment_id' and 'active_model_config_id' can be set."
          },
          "active_config_id": {
            "type": "string",
            "title": "Active config ID",
            "description": "ID for a config to set as the project's active deployment. Starts with 'config_'. At most one of 'active_experiment_id' and 'active_config_id' can be set."
          },
          "positive_labels": {
            "items": {
              "$ref": "#/components/schemas/PositiveLabel"
            },
            "type": "array",
            "title": "List of feedback labels to consider as positive actions",
            "description": "The full list of labels to treat as positive user feedback."
          },
          "directory_id": {
            "type": "string",
            "title": "Directory ID",
            "description": "ID of directory to assign project to. Starts with `dir_`."
          }
        },
        "type": "object",
        "title": "UpdateProjectRequest"
      },
      "Usage": {
        "properties": {
          "prompt_tokens": {
            "type": "integer",
            "title": "Prompt tokens",
            "description": "Number of tokens used in the prompt."
          },
          "generation_tokens": {
            "type": "integer",
            "title": "Generation tokens",
            "description": "Number of tokens produced by the generation."
          },
          "total_tokens": {
            "type": "integer",
            "title": "Total tokens",
            "description": "Total number of tokens used by the prompt and generation combined."
          }
        },
        "type": "object",
        "required": [
          "prompt_tokens",
          "generation_tokens",
          "total_tokens"
        ],
        "title": "Usage"
      },
      "ValidationError": {
        "properties": {
          "loc": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "type": "array",
            "title": "Location"
          },
          "msg": {
            "type": "string",
            "title": "Message"
          },
          "type": {
            "type": "string",
            "title": "Error Type"
          }
        },
        "type": "object",
        "required": [
          "loc",
          "msg",
          "type"
        ],
        "title": "ValidationError"
      }
    },
    "securitySchemes": {
      "APIKeyHeader": {
        "type": "apiKey",
        "in": "header",
        "name": "X-API-KEY",
        "description": "The Humanloop API uses API keys for authentication. Visit your\n[API Keys](https://app.humanloop.com/account/api-keys) page to retrieve the\nAPI key you'll use in your requests.\n\nThis key allows full access and control over your projects, so keep this secret\nand take care to not expose it in any client-side code.\n\nTo use your API key, include it under the `X-API-KEY` header in your HTTP request.\n\n```bash\ncurl https://api.humanloop.com/v4/projects -H 'X-API-KEY: YOUR_API_KEY'\n```\n\nIf you're using the Python SDK, initialize the client with your API key before\nusing other SDK methods:\n\n```python\nfrom humanloop import Humanloop\nhumanloop = Humanloop(api_key=\"YOUR_API_KEY\")\n```\n\nIf you're using the TypeScript SDK, initialize the client with your API key before\nusing other SDK methods:\n\n```js\nimport { Humanloop } from \"humanloop\";\nconst humanloop = new Humanloop({apiKey: \"YOUR_API_KEY\"});\n```"
      }
    }
  },
  "x-readme": {
    "samples-languages": [
      "python",
      "javascript",
      "curl"
    ]
  },
  "tags": [
    {
      "name": "Authentication",
      "description": "The Humanloop API uses API keys for authentication. Visit your\n[API Keys](https://app.humanloop.com/account/api-keys) page to retrieve the\nAPI key you'll use in your requests.\n\nThis key allows full access and control over your projects, so keep this secret\nand take care to not expose it in any client-side code.\n\nTo use your API key, include it under the `X-API-KEY` header in your HTTP request.\n\n```bash\ncurl https://api.humanloop.com/v4/projects -H 'X-API-KEY: YOUR_API_KEY'\n```\n\nIf you're using the Python SDK, initialize the client with your API key before\nusing other SDK methods:\n\n```python\nfrom humanloop import Humanloop\nhumanloop = Humanloop(api_key=\"YOUR_API_KEY\")\n```\n\nIf you're using the TypeScript SDK, initialize the client with your API key before\nusing other SDK methods:\n\n```js\nimport { Humanloop } from \"humanloop\";\nconst humanloop = new Humanloop({apiKey: \"YOUR_API_KEY\"});\n```"
    }
  ]
}