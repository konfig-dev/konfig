/*
 * SnapTrade
 *
 * Connect brokerage accounts to your app for live positions and trading
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@snaptrade.com
 * Generated by: https://konfigthis.com
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = SnapTrade.Net.Client.OpenAPIDateConverter;

namespace SnapTrade.Net.Model
{
    /// <summary>
    /// This response consists of 2 different components that must be decrypted to obtain the decrypted message  * Decrypting the encryptedSharedKey    The encrypted shared key is a shared key that was randomly generated by SnapTrade and encrypted using the users SSH public key provided when registering the user   It is needed to decrypt the message in step 2.    To decrypt the shared key, the user should have access to their SSH private key stored locally in their device    An example Python code on how to decrypt the shared key is shown below    &#x60;&#x60;&#x60;   def decrypt_rsa_message(self, encrypted_message):       from Crypto.Cipher import PKCS1_OAEP       from Crypto.PublicKey import RSA       from base64 import b64decode        f &#x3D; open(&#39;private.pem&#39;, &#39;r&#39;)       private_key &#x3D; RSA.import_key(f.read())       cipher &#x3D; PKCS1_OAEP.new(private_key)        return cipher.decrypt(b64decode(encrypted_message.encode())).decode()   &#x60;&#x60;&#x60;  * Decrypting the encryptedMessageData     The data meant to be returned by an endpoint can be obtained by decrypting the encrypted message     An encrypted message is a message that is encrypted using AES - MODE OCB with the shared key obtained in step one    An example code to decrypt the encrypted message is shown below    &#x60;&#x60;&#x60;   def decrypt_aes_message(self, shared_key, encrypted_message):       from Crypto.Cipher import AES       from base64 import b64decode        encrypted_msg &#x3D; b64decode(encrypted_message[\&quot;encryptedMessage\&quot;].encode())       tag &#x3D; b64decode(encrypted_message[\&quot;tag\&quot;].encode())       nonce &#x3D; b64decode(encrypted_message[\&quot;nonce\&quot;].encode())       cipher &#x3D; AES.new(shared_key.encode(), AES.MODE_OCB, nonce&#x3D;nonce)        return cipher.decrypt_and_verify(encrypted_msg, tag).decode()   &#x60;&#x60;&#x60; 
    /// </summary>
    [DataContract(Name = "encryptedResponse")]
    public partial class EncryptedResponse : IEquatable<EncryptedResponse>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EncryptedResponse" /> class.
        /// </summary>
        /// <param name="encryptedSharedKey">encryptedSharedKey.</param>
        /// <param name="encryptedMessageData">encryptedMessageData.</param>
        public EncryptedResponse(string encryptedSharedKey = default(string), EncryptedResponseEncryptedMessageData encryptedMessageData = default(EncryptedResponseEncryptedMessageData))
        {
            this.EncryptedSharedKey = encryptedSharedKey;
            this.EncryptedMessageData = encryptedMessageData;
        }

        /// <summary>
        /// Gets or Sets EncryptedSharedKey
        /// </summary>
        [DataMember(Name = "encryptedSharedKey", EmitDefaultValue = false)]
        public string EncryptedSharedKey { get; set; }

        /// <summary>
        /// Gets or Sets EncryptedMessageData
        /// </summary>
        [DataMember(Name = "encryptedMessageData", EmitDefaultValue = false)]
        public EncryptedResponseEncryptedMessageData EncryptedMessageData { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class EncryptedResponse {\n");
            sb.Append("  EncryptedSharedKey: ").Append(EncryptedSharedKey).Append("\n");
            sb.Append("  EncryptedMessageData: ").Append(EncryptedMessageData).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as EncryptedResponse);
        }

        /// <summary>
        /// Returns true if EncryptedResponse instances are equal
        /// </summary>
        /// <param name="input">Instance of EncryptedResponse to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(EncryptedResponse input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.EncryptedSharedKey == input.EncryptedSharedKey ||
                    (this.EncryptedSharedKey != null &&
                    this.EncryptedSharedKey.Equals(input.EncryptedSharedKey))
                ) && 
                (
                    this.EncryptedMessageData == input.EncryptedMessageData ||
                    (this.EncryptedMessageData != null &&
                    this.EncryptedMessageData.Equals(input.EncryptedMessageData))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.EncryptedSharedKey != null)
                {
                    hashCode = (hashCode * 59) + this.EncryptedSharedKey.GetHashCode();
                }
                if (this.EncryptedMessageData != null)
                {
                    hashCode = (hashCode * 59) + this.EncryptedMessageData.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
