import * as execa from "execa";
import * as fs from "fs";
import * as path from "path";
import * as mustache from "mustache";

// In debug mode, repository is not created and code is not pushed to remote
export function generateSdkRepository(
  companyName: string,
  language: string,
  pathToOas: string,
  siteUrl: string,
  debug: boolean = false
) {
  const repoName = generateRepoName(companyName, language);
  const repoDescription = generateRepositoryDescription(companyName, language);
  const repoDir = path.join(__dirname, "..", "sdks", repoName);

  if (!debug && repositoryExists(repoName)) {
    console.log(`Repository ${repoName} already exists. Aborting...`);
    return;
  }

  // Create and clone repository. If debug mode, create local directory.
  if (!debug) createRepository(repoName, repoDescription);
  else if (!fs.existsSync(repoDir)) fs.mkdirSync(repoDir);

  // Copy the OAS into the cloned repository
  fs.copyFileSync(
    path.join(__dirname, "..", "openapi-directory", "APIs", pathToOas),
    path.join(repoDir, path.basename(pathToOas))
  );

  // Copy the header image into the cloned repository
  fs.copyFileSync(
    path.join(__dirname, "..", "headers", `${companyName}.png`),
    path.join(repoDir, "header.png")
  );

  writeKonfigYaml(companyName, language, pathToOas, siteUrl);

  // Run konfig generate. If any errors occur, delete the repository and abort.
  try {
    execa.sync("konfig", ["generate"], {
      cwd: repoDir,
      stdio: "inherit",
    });
  } catch (error: any) {
    console.log("Error occurred during konfig generate.");
    console.log("Aborting process and deleting repository...");
    if (!debug) {
      execa.sync("rm", ["-rf", repoName], {
        cwd: path.join(__dirname, "..", "sdks"),
        stdio: "inherit",
      });
      deleteRepository(repoName);
    }
    console.log("Repository deleted.");
    return;
  }
  removeInstallationFromReadme(repoDir, language);

  // Commit and push to remote
  if (!debug) {
    execa.sync("git", ["add", "-A"], { cwd: repoDir, stdio: "inherit" });
    execa.sync(
      "git",
      ["commit", "-m", `Generate ${companyName} ${language} SDK`],
      { cwd: repoDir, stdio: "inherit" }
    );
    execa.sync("git", ["push", "origin", "HEAD"], {
      cwd: repoDir,
      stdio: "inherit",
    });
    // Remove local directory
    execa.sync("rm", ["-rf", repoName], {
      cwd: path.join(__dirname, "..", "sdks"),
      stdio: "inherit",
    });
  }
}

function removeInstallationFromReadme(repoDir: string, language: string) {
  const readmeFilepath = path.join(repoDir, language, "README.md");
  const readme = fs.readFileSync(readmeFilepath, "utf-8");
  const installationSectionRegex = /^## Installation([\s\S]*?)(?=\n##)/im;
  const replacementText =
    '## Installation<a id="installation"></a>\n\nTo install, please sign up for the SDK: placeholder.\n';
  const newReadme = readme.replace(installationSectionRegex, replacementText);
  fs.writeFileSync(readmeFilepath, newReadme);
}

function createRepository(name: string, description: string) {
  console.log(`Creating repository ${name}...`);
  execa.sync(
    "gh",
    [
      "repo",
      "create",
      `konfig-sdks/${name}`,
      "--public",
      "--clone",
      "-d",
      description,
    ],
    { cwd: path.join(__dirname, "..", "sdks"), stdio: "inherit" }
  );
}

function deleteRepository(name: string) {
  execa.sync("gh", ["repo", "delete", `konfig-sdks/${name}`, "--yes"]);
}

function writeKonfigYaml(
  companyName: string,
  language: string,
  pathToOas: string,
  siteUrl: string
) {
  const template = fs.readFileSync(
    path.join(__dirname, "..", "templates", "konfig.yaml.mustache"),
    "utf-8"
  );
  companyName = companyName.toLowerCase();
  const repoName = generateRepoName(companyName, language);
  const konfigYaml = mustache.render(template, {
    companyName: capitalize(companyName),
    siteUrl,
    repoName,
    lang: language,
    clientName: generateClientName(companyName, language),
    packageName: repoName.replace(/-/g, "_"),
    oasFileName: path.basename(pathToOas),
    ...generateTemplateLanguageData(language),
  });

  fs.writeFileSync(
    path.join(__dirname, "..", "sdks", repoName, "konfig.yaml"),
    konfigYaml
  );
}

function repositoryExists(name: string): boolean {
  try {
    execa.sync("gh", ["repo", "view", `konfig-sdks/${name}`]);
    return true;
  } catch (error: any) {
    if (
      error.stderr &&
      error.stderr.includes("Could not resolve to a Repository")
    ) {
      return false;
    }
    throw error;
  }
}

function generateTemplateLanguageData(language: string) {
  const data: Record<string, any> = {
    typescript: false,
    java: false,
    python: false,
  };
  data[language] = true;
  return data;
}

function generateRepositoryDescription(companyName: string, language: string) {
  return `${capitalize(
    language
  )} SDK for ${companyName} API. Generated by Konfig (https://konfigthis.com/).`;
}

function generateRepoName(companyName: string, language: string): string {
  return `${companyName.toLowerCase().replace(/ /g, "-")}-${language}-sdk`;
}

function generateClientName(companyName: string, language: string): string {
  return `${capitalize(toCamelCase(companyName))}${capitalize(language)}Client`;
}

function toCamelCase(str: string): string {
  return str
    .split(/[-_ ]+/)
    .map((word, index) =>
      index === 0
        ? word[0].toUpperCase() + word.slice(1)
        : word[0].toUpperCase() + word.slice(1)
    )
    .join("");
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// For testing:

generateSdkRepository(
  "Wikimedia",
  "java",
  "wikimedia.org/1.0.0/swagger.yaml",
  "wikimedia.org",
  true
);
