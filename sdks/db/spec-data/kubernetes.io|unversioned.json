{
  "providerName": "kubernetes.io",
  "openApiRaw": "https://raw.githubusercontent.com/kubernetes/kubernetes/master/api/openapi-spec/swagger.json",
  "securitySchemes": {
    "BearerToken": {
      "description": "Bearer Token authentication",
      "in": "header",
      "name": "authorization",
      "type": "apiKey"
    }
  },
  "homepage": "kubernetes.io",
  "apiVersion": "unversioned",
  "methods": [
    {
      "url": "/.well-known/openid-configuration/",
      "method": "getServiceAccountIssuerOpenIdConfiguration",
      "httpMethod": "get",
      "tag": "WellKnown",
      "description": "get service account issuer OpenID configuration, also known as the 'OIDC discovery doc'",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/",
      "method": "getCoreApiVersions",
      "httpMethod": "get",
      "tag": "core",
      "description": "get available API versions",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIVersions lists the versions that are available, to allow clients to discover the API at /api, which is the root path of the legacy v1 API."
        }
      ]
    },
    {
      "url": "/api/v1/",
      "method": "getCoreV1ApiResources",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/api/v1/componentstatuses",
      "method": "listCoreV1ComponentStatus",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list objects of kind ComponentStatus",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status of all the conditions for the component as a list of ComponentStatus objects. Deprecated: This API is deprecated in v1.19+"
        }
      ]
    },
    {
      "url": "/api/v1/componentstatuses/{name}",
      "method": "readCoreV1ComponentStatus",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read the specified ComponentStatus",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ComponentStatus (and ComponentStatusList) holds the cluster validation info. Deprecated: This API is deprecated in v1.19+"
        }
      ]
    },
    {
      "url": "/api/v1/configmaps",
      "method": "listCoreV1ConfigMapForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind ConfigMap",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ConfigMapList is a resource containing a list of ConfigMap objects."
        }
      ]
    },
    {
      "url": "/api/v1/endpoints",
      "method": "listCoreV1EndpointsForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind Endpoints",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "EndpointsList is a list of endpoints."
        }
      ]
    },
    {
      "url": "/api/v1/events",
      "method": "listCoreV1EventForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind Event",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "EventList is a list of events."
        }
      ]
    },
    {
      "url": "/api/v1/limitranges",
      "method": "listCoreV1LimitRangeForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind LimitRange",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "LimitRangeList is a list of LimitRange items."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces",
      "method": "listCoreV1Namespace",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind Namespace",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "NamespaceList is a list of Namespaces."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces",
      "method": "createCoreV1Namespace",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "create a Namespace",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        },
        {
          "statusCode": "201",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        },
        {
          "statusCode": "202",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/bindings",
      "method": "createCoreV1NamespacedBinding",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "create a Binding",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "target",
          "schema": "object",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Binding ties one object to another; for example, a pod is bound to a node by a scheduler. Deprecated in 1.7, please use the bindings subresource of pods instead."
        },
        {
          "statusCode": "201",
          "description": "Binding ties one object to another; for example, a pod is bound to a node by a scheduler. Deprecated in 1.7, please use the bindings subresource of pods instead."
        },
        {
          "statusCode": "202",
          "description": "Binding ties one object to another; for example, a pod is bound to a node by a scheduler. Deprecated in 1.7, please use the bindings subresource of pods instead."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/configmaps",
      "method": "deleteCoreV1CollectionNamespacedConfigMap",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete collection of ConfigMap",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/configmaps",
      "method": "listCoreV1NamespacedConfigMap",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind ConfigMap",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ConfigMapList is a resource containing a list of ConfigMap objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/configmaps",
      "method": "createCoreV1NamespacedConfigMap",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "create a ConfigMap",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "binaryData",
          "schema": "object",
          "description": ""
        },
        {
          "name": "data",
          "schema": "object",
          "description": ""
        },
        {
          "name": "immutable",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ConfigMap holds configuration data for pods to consume."
        },
        {
          "statusCode": "201",
          "description": "ConfigMap holds configuration data for pods to consume."
        },
        {
          "statusCode": "202",
          "description": "ConfigMap holds configuration data for pods to consume."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/configmaps/{name}",
      "method": "deleteCoreV1NamespacedConfigMap",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete a ConfigMap",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/configmaps/{name}",
      "method": "readCoreV1NamespacedConfigMap",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read the specified ConfigMap",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ConfigMap holds configuration data for pods to consume."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/configmaps/{name}",
      "method": "patchCoreV1NamespacedConfigMap",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update the specified ConfigMap",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ConfigMap holds configuration data for pods to consume."
        },
        {
          "statusCode": "201",
          "description": "ConfigMap holds configuration data for pods to consume."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/configmaps/{name}",
      "method": "replaceCoreV1NamespacedConfigMap",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace the specified ConfigMap",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "binaryData",
          "schema": "object",
          "description": ""
        },
        {
          "name": "data",
          "schema": "object",
          "description": ""
        },
        {
          "name": "immutable",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ConfigMap holds configuration data for pods to consume."
        },
        {
          "statusCode": "201",
          "description": "ConfigMap holds configuration data for pods to consume."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/endpoints",
      "method": "deleteCoreV1CollectionNamespacedEndpoints",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete collection of Endpoints",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/endpoints",
      "method": "listCoreV1NamespacedEndpoints",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind Endpoints",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "EndpointsList is a list of endpoints."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/endpoints",
      "method": "createCoreV1NamespacedEndpoints",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "create Endpoints",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "subsets",
          "schema": "array",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Endpoints is a collection of endpoints that implement the actual service. Example:\n\n\t Name: \"mysvc\",\n\t Subsets: [\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n\t   },\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.3.3\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n\t   },\n\t]"
        },
        {
          "statusCode": "201",
          "description": "Endpoints is a collection of endpoints that implement the actual service. Example:\n\n\t Name: \"mysvc\",\n\t Subsets: [\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n\t   },\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.3.3\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n\t   },\n\t]"
        },
        {
          "statusCode": "202",
          "description": "Endpoints is a collection of endpoints that implement the actual service. Example:\n\n\t Name: \"mysvc\",\n\t Subsets: [\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n\t   },\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.3.3\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n\t   },\n\t]"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/endpoints/{name}",
      "method": "deleteCoreV1NamespacedEndpoints",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete Endpoints",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/endpoints/{name}",
      "method": "readCoreV1NamespacedEndpoints",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read the specified Endpoints",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Endpoints is a collection of endpoints that implement the actual service. Example:\n\n\t Name: \"mysvc\",\n\t Subsets: [\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n\t   },\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.3.3\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n\t   },\n\t]"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/endpoints/{name}",
      "method": "patchCoreV1NamespacedEndpoints",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update the specified Endpoints",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Endpoints is a collection of endpoints that implement the actual service. Example:\n\n\t Name: \"mysvc\",\n\t Subsets: [\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n\t   },\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.3.3\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n\t   },\n\t]"
        },
        {
          "statusCode": "201",
          "description": "Endpoints is a collection of endpoints that implement the actual service. Example:\n\n\t Name: \"mysvc\",\n\t Subsets: [\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n\t   },\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.3.3\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n\t   },\n\t]"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/endpoints/{name}",
      "method": "replaceCoreV1NamespacedEndpoints",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace the specified Endpoints",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "subsets",
          "schema": "array",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Endpoints is a collection of endpoints that implement the actual service. Example:\n\n\t Name: \"mysvc\",\n\t Subsets: [\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n\t   },\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.3.3\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n\t   },\n\t]"
        },
        {
          "statusCode": "201",
          "description": "Endpoints is a collection of endpoints that implement the actual service. Example:\n\n\t Name: \"mysvc\",\n\t Subsets: [\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n\t   },\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.3.3\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n\t   },\n\t]"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/events",
      "method": "deleteCoreV1CollectionNamespacedEvent",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete collection of Event",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/events",
      "method": "listCoreV1NamespacedEvent",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind Event",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "EventList is a list of events."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/events",
      "method": "createCoreV1NamespacedEvent",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "create an Event",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "action",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "count",
          "schema": "integer",
          "required": false,
          "description": ""
        },
        {
          "name": "eventTime",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "firstTimestamp",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "involvedObject",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "lastTimestamp",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "message",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "reason",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "related",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "reportingComponent",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "reportingInstance",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "series",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "source",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "type",
          "schema": "string",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event is a report of an event somewhere in the cluster.  Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data."
        },
        {
          "statusCode": "201",
          "description": "Event is a report of an event somewhere in the cluster.  Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data."
        },
        {
          "statusCode": "202",
          "description": "Event is a report of an event somewhere in the cluster.  Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/events/{name}",
      "method": "deleteCoreV1NamespacedEvent",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete an Event",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/events/{name}",
      "method": "readCoreV1NamespacedEvent",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read the specified Event",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event is a report of an event somewhere in the cluster.  Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/events/{name}",
      "method": "patchCoreV1NamespacedEvent",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update the specified Event",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event is a report of an event somewhere in the cluster.  Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data."
        },
        {
          "statusCode": "201",
          "description": "Event is a report of an event somewhere in the cluster.  Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/events/{name}",
      "method": "replaceCoreV1NamespacedEvent",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace the specified Event",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "action",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "count",
          "schema": "integer",
          "required": false,
          "description": ""
        },
        {
          "name": "eventTime",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "firstTimestamp",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "involvedObject",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "lastTimestamp",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "message",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "reason",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "related",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "reportingComponent",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "reportingInstance",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "series",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "source",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "type",
          "schema": "string",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event is a report of an event somewhere in the cluster.  Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data."
        },
        {
          "statusCode": "201",
          "description": "Event is a report of an event somewhere in the cluster.  Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/limitranges",
      "method": "deleteCoreV1CollectionNamespacedLimitRange",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete collection of LimitRange",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/limitranges",
      "method": "listCoreV1NamespacedLimitRange",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind LimitRange",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "LimitRangeList is a list of LimitRange items."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/limitranges",
      "method": "createCoreV1NamespacedLimitRange",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "create a LimitRange",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "LimitRange sets resource usage limits for each kind of resource in a Namespace."
        },
        {
          "statusCode": "201",
          "description": "LimitRange sets resource usage limits for each kind of resource in a Namespace."
        },
        {
          "statusCode": "202",
          "description": "LimitRange sets resource usage limits for each kind of resource in a Namespace."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/limitranges/{name}",
      "method": "deleteCoreV1NamespacedLimitRange",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete a LimitRange",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/limitranges/{name}",
      "method": "readCoreV1NamespacedLimitRange",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read the specified LimitRange",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "LimitRange sets resource usage limits for each kind of resource in a Namespace."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/limitranges/{name}",
      "method": "patchCoreV1NamespacedLimitRange",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update the specified LimitRange",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "LimitRange sets resource usage limits for each kind of resource in a Namespace."
        },
        {
          "statusCode": "201",
          "description": "LimitRange sets resource usage limits for each kind of resource in a Namespace."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/limitranges/{name}",
      "method": "replaceCoreV1NamespacedLimitRange",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace the specified LimitRange",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "LimitRange sets resource usage limits for each kind of resource in a Namespace."
        },
        {
          "statusCode": "201",
          "description": "LimitRange sets resource usage limits for each kind of resource in a Namespace."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/persistentvolumeclaims",
      "method": "deleteCoreV1CollectionNamespacedPersistentVolumeClaim",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete collection of PersistentVolumeClaim",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/persistentvolumeclaims",
      "method": "listCoreV1NamespacedPersistentVolumeClaim",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind PersistentVolumeClaim",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeClaimList is a list of PersistentVolumeClaim items."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/persistentvolumeclaims",
      "method": "createCoreV1NamespacedPersistentVolumeClaim",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "create a PersistentVolumeClaim",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        },
        {
          "statusCode": "201",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        },
        {
          "statusCode": "202",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}",
      "method": "deleteCoreV1NamespacedPersistentVolumeClaim",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete a PersistentVolumeClaim",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        },
        {
          "statusCode": "202",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}",
      "method": "readCoreV1NamespacedPersistentVolumeClaim",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read the specified PersistentVolumeClaim",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}",
      "method": "patchCoreV1NamespacedPersistentVolumeClaim",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update the specified PersistentVolumeClaim",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        },
        {
          "statusCode": "201",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}",
      "method": "replaceCoreV1NamespacedPersistentVolumeClaim",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace the specified PersistentVolumeClaim",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        },
        {
          "statusCode": "201",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status",
      "method": "readCoreV1NamespacedPersistentVolumeClaimStatus",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read status of the specified PersistentVolumeClaim",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status",
      "method": "patchCoreV1NamespacedPersistentVolumeClaimStatus",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update status of the specified PersistentVolumeClaim",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        },
        {
          "statusCode": "201",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status",
      "method": "replaceCoreV1NamespacedPersistentVolumeClaimStatus",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace status of the specified PersistentVolumeClaim",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        },
        {
          "statusCode": "201",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods",
      "method": "deleteCoreV1CollectionNamespacedPod",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete collection of Pod",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods",
      "method": "listCoreV1NamespacedPod",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind Pod",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodList is a list of Pods."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods",
      "method": "createCoreV1NamespacedPod",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "create a Pod",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        },
        {
          "statusCode": "201",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        },
        {
          "statusCode": "202",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}",
      "method": "deleteCoreV1NamespacedPod",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete a Pod",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        },
        {
          "statusCode": "202",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}",
      "method": "readCoreV1NamespacedPod",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read the specified Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}",
      "method": "patchCoreV1NamespacedPod",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update the specified Pod",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        },
        {
          "statusCode": "201",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}",
      "method": "replaceCoreV1NamespacedPod",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace the specified Pod",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        },
        {
          "statusCode": "201",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/attach",
      "method": "connectCoreV1GetNamespacedPodAttach",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "connect GET requests to attach of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/attach",
      "method": "connectCoreV1PostNamespacedPodAttach",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "connect POST requests to attach of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/binding",
      "method": "createCoreV1NamespacedPodBinding",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "create binding of a Pod",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "target",
          "schema": "object",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Binding ties one object to another; for example, a pod is bound to a node by a scheduler. Deprecated in 1.7, please use the bindings subresource of pods instead."
        },
        {
          "statusCode": "201",
          "description": "Binding ties one object to another; for example, a pod is bound to a node by a scheduler. Deprecated in 1.7, please use the bindings subresource of pods instead."
        },
        {
          "statusCode": "202",
          "description": "Binding ties one object to another; for example, a pod is bound to a node by a scheduler. Deprecated in 1.7, please use the bindings subresource of pods instead."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers",
      "method": "readCoreV1NamespacedPodEphemeralcontainers",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read ephemeralcontainers of the specified Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers",
      "method": "patchCoreV1NamespacedPodEphemeralcontainers",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update ephemeralcontainers of the specified Pod",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        },
        {
          "statusCode": "201",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers",
      "method": "replaceCoreV1NamespacedPodEphemeralcontainers",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace ephemeralcontainers of the specified Pod",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        },
        {
          "statusCode": "201",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/eviction",
      "method": "createCoreV1NamespacedPodEviction",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "create eviction of a Pod",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "deleteOptions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Eviction evicts a pod from its node subject to certain policies and safety constraints. This is a subresource of Pod.  A request to cause such an eviction is created by POSTing to .../pods/<pod name>/evictions."
        },
        {
          "statusCode": "201",
          "description": "Eviction evicts a pod from its node subject to certain policies and safety constraints. This is a subresource of Pod.  A request to cause such an eviction is created by POSTing to .../pods/<pod name>/evictions."
        },
        {
          "statusCode": "202",
          "description": "Eviction evicts a pod from its node subject to certain policies and safety constraints. This is a subresource of Pod.  A request to cause such an eviction is created by POSTing to .../pods/<pod name>/evictions."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/exec",
      "method": "connectCoreV1GetNamespacedPodExec",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "connect GET requests to exec of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/exec",
      "method": "connectCoreV1PostNamespacedPodExec",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "connect POST requests to exec of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/log",
      "method": "readCoreV1NamespacedPodLog",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read log of the specified Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/portforward",
      "method": "connectCoreV1GetNamespacedPodPortforward",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "connect GET requests to portforward of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/portforward",
      "method": "connectCoreV1PostNamespacedPodPortforward",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "connect POST requests to portforward of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy",
      "method": "connectCoreV1DeleteNamespacedPodProxy",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "connect DELETE requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy",
      "method": "connectCoreV1GetNamespacedPodProxy",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "connect GET requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy",
      "method": "connectCoreV1HeadNamespacedPodProxy",
      "httpMethod": "head",
      "tag": "core_v1",
      "description": "connect HEAD requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy",
      "method": "connectCoreV1OptionsNamespacedPodProxy",
      "httpMethod": "options",
      "tag": "core_v1",
      "description": "connect OPTIONS requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy",
      "method": "connectCoreV1PatchNamespacedPodProxy",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "connect PATCH requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy",
      "method": "connectCoreV1PostNamespacedPodProxy",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "connect POST requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy",
      "method": "connectCoreV1PutNamespacedPodProxy",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "connect PUT requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}",
      "method": "connectCoreV1DeleteNamespacedPodProxyWithPath",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "connect DELETE requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}",
      "method": "connectCoreV1GetNamespacedPodProxyWithPath",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "connect GET requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}",
      "method": "connectCoreV1HeadNamespacedPodProxyWithPath",
      "httpMethod": "head",
      "tag": "core_v1",
      "description": "connect HEAD requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}",
      "method": "connectCoreV1OptionsNamespacedPodProxyWithPath",
      "httpMethod": "options",
      "tag": "core_v1",
      "description": "connect OPTIONS requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}",
      "method": "connectCoreV1PatchNamespacedPodProxyWithPath",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "connect PATCH requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}",
      "method": "connectCoreV1PostNamespacedPodProxyWithPath",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "connect POST requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}",
      "method": "connectCoreV1PutNamespacedPodProxyWithPath",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "connect PUT requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/status",
      "method": "readCoreV1NamespacedPodStatus",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read status of the specified Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/status",
      "method": "patchCoreV1NamespacedPodStatus",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update status of the specified Pod",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        },
        {
          "statusCode": "201",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/status",
      "method": "replaceCoreV1NamespacedPodStatus",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace status of the specified Pod",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        },
        {
          "statusCode": "201",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/podtemplates",
      "method": "deleteCoreV1CollectionNamespacedPodTemplate",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete collection of PodTemplate",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/podtemplates",
      "method": "listCoreV1NamespacedPodTemplate",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind PodTemplate",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodTemplateList is a list of PodTemplates."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/podtemplates",
      "method": "createCoreV1NamespacedPodTemplate",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "create a PodTemplate",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "template",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodTemplate describes a template for creating copies of a predefined pod."
        },
        {
          "statusCode": "201",
          "description": "PodTemplate describes a template for creating copies of a predefined pod."
        },
        {
          "statusCode": "202",
          "description": "PodTemplate describes a template for creating copies of a predefined pod."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/podtemplates/{name}",
      "method": "deleteCoreV1NamespacedPodTemplate",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete a PodTemplate",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodTemplate describes a template for creating copies of a predefined pod."
        },
        {
          "statusCode": "202",
          "description": "PodTemplate describes a template for creating copies of a predefined pod."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/podtemplates/{name}",
      "method": "readCoreV1NamespacedPodTemplate",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read the specified PodTemplate",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodTemplate describes a template for creating copies of a predefined pod."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/podtemplates/{name}",
      "method": "patchCoreV1NamespacedPodTemplate",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update the specified PodTemplate",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodTemplate describes a template for creating copies of a predefined pod."
        },
        {
          "statusCode": "201",
          "description": "PodTemplate describes a template for creating copies of a predefined pod."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/podtemplates/{name}",
      "method": "replaceCoreV1NamespacedPodTemplate",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace the specified PodTemplate",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "template",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodTemplate describes a template for creating copies of a predefined pod."
        },
        {
          "statusCode": "201",
          "description": "PodTemplate describes a template for creating copies of a predefined pod."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers",
      "method": "deleteCoreV1CollectionNamespacedReplicationController",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete collection of ReplicationController",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers",
      "method": "listCoreV1NamespacedReplicationController",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind ReplicationController",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicationControllerList is a collection of replication controllers."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers",
      "method": "createCoreV1NamespacedReplicationController",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "create a ReplicationController",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicationController represents the configuration of a replication controller."
        },
        {
          "statusCode": "201",
          "description": "ReplicationController represents the configuration of a replication controller."
        },
        {
          "statusCode": "202",
          "description": "ReplicationController represents the configuration of a replication controller."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}",
      "method": "deleteCoreV1NamespacedReplicationController",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete a ReplicationController",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}",
      "method": "readCoreV1NamespacedReplicationController",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read the specified ReplicationController",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicationController represents the configuration of a replication controller."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}",
      "method": "patchCoreV1NamespacedReplicationController",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update the specified ReplicationController",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicationController represents the configuration of a replication controller."
        },
        {
          "statusCode": "201",
          "description": "ReplicationController represents the configuration of a replication controller."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}",
      "method": "replaceCoreV1NamespacedReplicationController",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace the specified ReplicationController",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicationController represents the configuration of a replication controller."
        },
        {
          "statusCode": "201",
          "description": "ReplicationController represents the configuration of a replication controller."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale",
      "method": "readCoreV1NamespacedReplicationControllerScale",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read scale of the specified ReplicationController",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale",
      "method": "patchCoreV1NamespacedReplicationControllerScale",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update scale of the specified ReplicationController",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        },
        {
          "statusCode": "201",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale",
      "method": "replaceCoreV1NamespacedReplicationControllerScale",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace scale of the specified ReplicationController",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        },
        {
          "statusCode": "201",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status",
      "method": "readCoreV1NamespacedReplicationControllerStatus",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read status of the specified ReplicationController",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicationController represents the configuration of a replication controller."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status",
      "method": "patchCoreV1NamespacedReplicationControllerStatus",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update status of the specified ReplicationController",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicationController represents the configuration of a replication controller."
        },
        {
          "statusCode": "201",
          "description": "ReplicationController represents the configuration of a replication controller."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status",
      "method": "replaceCoreV1NamespacedReplicationControllerStatus",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace status of the specified ReplicationController",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicationController represents the configuration of a replication controller."
        },
        {
          "statusCode": "201",
          "description": "ReplicationController represents the configuration of a replication controller."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/resourcequotas",
      "method": "deleteCoreV1CollectionNamespacedResourceQuota",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete collection of ResourceQuota",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/resourcequotas",
      "method": "listCoreV1NamespacedResourceQuota",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind ResourceQuota",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceQuotaList is a list of ResourceQuota items."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/resourcequotas",
      "method": "createCoreV1NamespacedResourceQuota",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "create a ResourceQuota",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        },
        {
          "statusCode": "201",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        },
        {
          "statusCode": "202",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/resourcequotas/{name}",
      "method": "deleteCoreV1NamespacedResourceQuota",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete a ResourceQuota",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        },
        {
          "statusCode": "202",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/resourcequotas/{name}",
      "method": "readCoreV1NamespacedResourceQuota",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read the specified ResourceQuota",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/resourcequotas/{name}",
      "method": "patchCoreV1NamespacedResourceQuota",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update the specified ResourceQuota",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        },
        {
          "statusCode": "201",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/resourcequotas/{name}",
      "method": "replaceCoreV1NamespacedResourceQuota",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace the specified ResourceQuota",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        },
        {
          "statusCode": "201",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status",
      "method": "readCoreV1NamespacedResourceQuotaStatus",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read status of the specified ResourceQuota",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status",
      "method": "patchCoreV1NamespacedResourceQuotaStatus",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update status of the specified ResourceQuota",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        },
        {
          "statusCode": "201",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status",
      "method": "replaceCoreV1NamespacedResourceQuotaStatus",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace status of the specified ResourceQuota",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        },
        {
          "statusCode": "201",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/secrets",
      "method": "deleteCoreV1CollectionNamespacedSecret",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete collection of Secret",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/secrets",
      "method": "listCoreV1NamespacedSecret",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind Secret",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "SecretList is a list of Secret."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/secrets",
      "method": "createCoreV1NamespacedSecret",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "create a Secret",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "data",
          "schema": "object",
          "description": ""
        },
        {
          "name": "immutable",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "stringData",
          "schema": "object",
          "description": ""
        },
        {
          "name": "type",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes."
        },
        {
          "statusCode": "201",
          "description": "Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes."
        },
        {
          "statusCode": "202",
          "description": "Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/secrets/{name}",
      "method": "deleteCoreV1NamespacedSecret",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete a Secret",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/secrets/{name}",
      "method": "readCoreV1NamespacedSecret",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read the specified Secret",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/secrets/{name}",
      "method": "patchCoreV1NamespacedSecret",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update the specified Secret",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes."
        },
        {
          "statusCode": "201",
          "description": "Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/secrets/{name}",
      "method": "replaceCoreV1NamespacedSecret",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace the specified Secret",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "data",
          "schema": "object",
          "description": ""
        },
        {
          "name": "immutable",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "stringData",
          "schema": "object",
          "description": ""
        },
        {
          "name": "type",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes."
        },
        {
          "statusCode": "201",
          "description": "Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/serviceaccounts",
      "method": "deleteCoreV1CollectionNamespacedServiceAccount",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete collection of ServiceAccount",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/serviceaccounts",
      "method": "listCoreV1NamespacedServiceAccount",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind ServiceAccount",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ServiceAccountList is a list of ServiceAccount objects"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/serviceaccounts",
      "method": "createCoreV1NamespacedServiceAccount",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "create a ServiceAccount",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "automountServiceAccountToken",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "imagePullSecrets",
          "schema": "array",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "secrets",
          "schema": "array",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets"
        },
        {
          "statusCode": "201",
          "description": "ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets"
        },
        {
          "statusCode": "202",
          "description": "ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/serviceaccounts/{name}",
      "method": "deleteCoreV1NamespacedServiceAccount",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete a ServiceAccount",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets"
        },
        {
          "statusCode": "202",
          "description": "ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/serviceaccounts/{name}",
      "method": "readCoreV1NamespacedServiceAccount",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read the specified ServiceAccount",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/serviceaccounts/{name}",
      "method": "patchCoreV1NamespacedServiceAccount",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update the specified ServiceAccount",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets"
        },
        {
          "statusCode": "201",
          "description": "ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/serviceaccounts/{name}",
      "method": "replaceCoreV1NamespacedServiceAccount",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace the specified ServiceAccount",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "automountServiceAccountToken",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "imagePullSecrets",
          "schema": "array",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "secrets",
          "schema": "array",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets"
        },
        {
          "statusCode": "201",
          "description": "ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/serviceaccounts/{name}/token",
      "method": "createCoreV1NamespacedServiceAccountToken",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "create token of a ServiceAccount",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "TokenRequest requests a token for a given service account."
        },
        {
          "statusCode": "201",
          "description": "TokenRequest requests a token for a given service account."
        },
        {
          "statusCode": "202",
          "description": "TokenRequest requests a token for a given service account."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services",
      "method": "deleteCoreV1CollectionNamespacedService",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete collection of Service",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services",
      "method": "listCoreV1NamespacedService",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind Service",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ServiceList holds a list of services."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services",
      "method": "createCoreV1NamespacedService",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "create a Service",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        },
        {
          "statusCode": "201",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        },
        {
          "statusCode": "202",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}",
      "method": "deleteCoreV1NamespacedService",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete a Service",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        },
        {
          "statusCode": "202",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}",
      "method": "readCoreV1NamespacedService",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read the specified Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}",
      "method": "patchCoreV1NamespacedService",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update the specified Service",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        },
        {
          "statusCode": "201",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}",
      "method": "replaceCoreV1NamespacedService",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace the specified Service",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        },
        {
          "statusCode": "201",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy",
      "method": "connectCoreV1DeleteNamespacedServiceProxy",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "connect DELETE requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy",
      "method": "connectCoreV1GetNamespacedServiceProxy",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "connect GET requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy",
      "method": "connectCoreV1HeadNamespacedServiceProxy",
      "httpMethod": "head",
      "tag": "core_v1",
      "description": "connect HEAD requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy",
      "method": "connectCoreV1OptionsNamespacedServiceProxy",
      "httpMethod": "options",
      "tag": "core_v1",
      "description": "connect OPTIONS requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy",
      "method": "connectCoreV1PatchNamespacedServiceProxy",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "connect PATCH requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy",
      "method": "connectCoreV1PostNamespacedServiceProxy",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "connect POST requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy",
      "method": "connectCoreV1PutNamespacedServiceProxy",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "connect PUT requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}",
      "method": "connectCoreV1DeleteNamespacedServiceProxyWithPath",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "connect DELETE requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}",
      "method": "connectCoreV1GetNamespacedServiceProxyWithPath",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "connect GET requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}",
      "method": "connectCoreV1HeadNamespacedServiceProxyWithPath",
      "httpMethod": "head",
      "tag": "core_v1",
      "description": "connect HEAD requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}",
      "method": "connectCoreV1OptionsNamespacedServiceProxyWithPath",
      "httpMethod": "options",
      "tag": "core_v1",
      "description": "connect OPTIONS requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}",
      "method": "connectCoreV1PatchNamespacedServiceProxyWithPath",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "connect PATCH requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}",
      "method": "connectCoreV1PostNamespacedServiceProxyWithPath",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "connect POST requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}",
      "method": "connectCoreV1PutNamespacedServiceProxyWithPath",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "connect PUT requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/status",
      "method": "readCoreV1NamespacedServiceStatus",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read status of the specified Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/status",
      "method": "patchCoreV1NamespacedServiceStatus",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update status of the specified Service",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        },
        {
          "statusCode": "201",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/status",
      "method": "replaceCoreV1NamespacedServiceStatus",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace status of the specified Service",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        },
        {
          "statusCode": "201",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{name}",
      "method": "deleteCoreV1Namespace",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete a Namespace",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{name}",
      "method": "readCoreV1Namespace",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read the specified Namespace",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{name}",
      "method": "patchCoreV1Namespace",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update the specified Namespace",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        },
        {
          "statusCode": "201",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{name}",
      "method": "replaceCoreV1Namespace",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace the specified Namespace",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        },
        {
          "statusCode": "201",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{name}/finalize",
      "method": "replaceCoreV1NamespaceFinalize",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace finalize of the specified Namespace",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        },
        {
          "statusCode": "201",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{name}/status",
      "method": "readCoreV1NamespaceStatus",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read status of the specified Namespace",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{name}/status",
      "method": "patchCoreV1NamespaceStatus",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update status of the specified Namespace",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        },
        {
          "statusCode": "201",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{name}/status",
      "method": "replaceCoreV1NamespaceStatus",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace status of the specified Namespace",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        },
        {
          "statusCode": "201",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        }
      ]
    },
    {
      "url": "/api/v1/nodes",
      "method": "deleteCoreV1CollectionNode",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete collection of Node",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/nodes",
      "method": "listCoreV1Node",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind Node",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "NodeList is the whole list of all Nodes which have been registered with master."
        }
      ]
    },
    {
      "url": "/api/v1/nodes",
      "method": "createCoreV1Node",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "create a Node",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        },
        {
          "statusCode": "201",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        },
        {
          "statusCode": "202",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}",
      "method": "deleteCoreV1Node",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete a Node",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}",
      "method": "readCoreV1Node",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read the specified Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}",
      "method": "patchCoreV1Node",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update the specified Node",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        },
        {
          "statusCode": "201",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}",
      "method": "replaceCoreV1Node",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace the specified Node",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        },
        {
          "statusCode": "201",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy",
      "method": "connectCoreV1DeleteNodeProxy",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "connect DELETE requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy",
      "method": "connectCoreV1GetNodeProxy",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "connect GET requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy",
      "method": "connectCoreV1HeadNodeProxy",
      "httpMethod": "head",
      "tag": "core_v1",
      "description": "connect HEAD requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy",
      "method": "connectCoreV1OptionsNodeProxy",
      "httpMethod": "options",
      "tag": "core_v1",
      "description": "connect OPTIONS requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy",
      "method": "connectCoreV1PatchNodeProxy",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "connect PATCH requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy",
      "method": "connectCoreV1PostNodeProxy",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "connect POST requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy",
      "method": "connectCoreV1PutNodeProxy",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "connect PUT requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy/{path}",
      "method": "connectCoreV1DeleteNodeProxyWithPath",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "connect DELETE requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy/{path}",
      "method": "connectCoreV1GetNodeProxyWithPath",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "connect GET requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy/{path}",
      "method": "connectCoreV1HeadNodeProxyWithPath",
      "httpMethod": "head",
      "tag": "core_v1",
      "description": "connect HEAD requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy/{path}",
      "method": "connectCoreV1OptionsNodeProxyWithPath",
      "httpMethod": "options",
      "tag": "core_v1",
      "description": "connect OPTIONS requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy/{path}",
      "method": "connectCoreV1PatchNodeProxyWithPath",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "connect PATCH requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy/{path}",
      "method": "connectCoreV1PostNodeProxyWithPath",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "connect POST requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy/{path}",
      "method": "connectCoreV1PutNodeProxyWithPath",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "connect PUT requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/status",
      "method": "readCoreV1NodeStatus",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read status of the specified Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/status",
      "method": "patchCoreV1NodeStatus",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update status of the specified Node",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        },
        {
          "statusCode": "201",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/status",
      "method": "replaceCoreV1NodeStatus",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace status of the specified Node",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        },
        {
          "statusCode": "201",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumeclaims",
      "method": "listCoreV1PersistentVolumeClaimForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind PersistentVolumeClaim",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeClaimList is a list of PersistentVolumeClaim items."
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumes",
      "method": "deleteCoreV1CollectionPersistentVolume",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete collection of PersistentVolume",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumes",
      "method": "listCoreV1PersistentVolume",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind PersistentVolume",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeList is a list of PersistentVolume items."
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumes",
      "method": "createCoreV1PersistentVolume",
      "httpMethod": "post",
      "tag": "core_v1",
      "description": "create a PersistentVolume",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        },
        {
          "statusCode": "201",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        },
        {
          "statusCode": "202",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumes/{name}",
      "method": "deleteCoreV1PersistentVolume",
      "httpMethod": "delete",
      "tag": "core_v1",
      "description": "delete a PersistentVolume",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        },
        {
          "statusCode": "202",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumes/{name}",
      "method": "readCoreV1PersistentVolume",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read the specified PersistentVolume",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumes/{name}",
      "method": "patchCoreV1PersistentVolume",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update the specified PersistentVolume",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        },
        {
          "statusCode": "201",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumes/{name}",
      "method": "replaceCoreV1PersistentVolume",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace the specified PersistentVolume",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        },
        {
          "statusCode": "201",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumes/{name}/status",
      "method": "readCoreV1PersistentVolumeStatus",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "read status of the specified PersistentVolume",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumes/{name}/status",
      "method": "patchCoreV1PersistentVolumeStatus",
      "httpMethod": "patch",
      "tag": "core_v1",
      "description": "partially update status of the specified PersistentVolume",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        },
        {
          "statusCode": "201",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumes/{name}/status",
      "method": "replaceCoreV1PersistentVolumeStatus",
      "httpMethod": "put",
      "tag": "core_v1",
      "description": "replace status of the specified PersistentVolume",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        },
        {
          "statusCode": "201",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        }
      ]
    },
    {
      "url": "/api/v1/pods",
      "method": "listCoreV1PodForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodList is a list of Pods."
        }
      ]
    },
    {
      "url": "/api/v1/podtemplates",
      "method": "listCoreV1PodTemplateForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind PodTemplate",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodTemplateList is a list of PodTemplates."
        }
      ]
    },
    {
      "url": "/api/v1/replicationcontrollers",
      "method": "listCoreV1ReplicationControllerForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind ReplicationController",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicationControllerList is a collection of replication controllers."
        }
      ]
    },
    {
      "url": "/api/v1/resourcequotas",
      "method": "listCoreV1ResourceQuotaForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind ResourceQuota",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceQuotaList is a list of ResourceQuota items."
        }
      ]
    },
    {
      "url": "/api/v1/secrets",
      "method": "listCoreV1SecretForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind Secret",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "SecretList is a list of Secret."
        }
      ]
    },
    {
      "url": "/api/v1/serviceaccounts",
      "method": "listCoreV1ServiceAccountForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind ServiceAccount",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ServiceAccountList is a list of ServiceAccount objects"
        }
      ]
    },
    {
      "url": "/api/v1/services",
      "method": "listCoreV1ServiceForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "list or watch objects of kind Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ServiceList holds a list of services."
        }
      ]
    },
    {
      "url": "/api/v1/watch/configmaps",
      "method": "watchCoreV1ConfigMapListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of ConfigMap. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/endpoints",
      "method": "watchCoreV1EndpointsListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of Endpoints. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/events",
      "method": "watchCoreV1EventListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/limitranges",
      "method": "watchCoreV1LimitRangeListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of LimitRange. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces",
      "method": "watchCoreV1NamespaceList",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of Namespace. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/configmaps",
      "method": "watchCoreV1NamespacedConfigMapList",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of ConfigMap. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/configmaps/{name}",
      "method": "watchCoreV1NamespacedConfigMap",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch changes to an object of kind ConfigMap. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/endpoints",
      "method": "watchCoreV1NamespacedEndpointsList",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of Endpoints. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/endpoints/{name}",
      "method": "watchCoreV1NamespacedEndpoints",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch changes to an object of kind Endpoints. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/events",
      "method": "watchCoreV1NamespacedEventList",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/events/{name}",
      "method": "watchCoreV1NamespacedEvent",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch changes to an object of kind Event. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/limitranges",
      "method": "watchCoreV1NamespacedLimitRangeList",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of LimitRange. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/limitranges/{name}",
      "method": "watchCoreV1NamespacedLimitRange",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch changes to an object of kind LimitRange. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims",
      "method": "watchCoreV1NamespacedPersistentVolumeClaimList",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of PersistentVolumeClaim. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims/{name}",
      "method": "watchCoreV1NamespacedPersistentVolumeClaim",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch changes to an object of kind PersistentVolumeClaim. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/pods",
      "method": "watchCoreV1NamespacedPodList",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of Pod. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/pods/{name}",
      "method": "watchCoreV1NamespacedPod",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch changes to an object of kind Pod. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/podtemplates",
      "method": "watchCoreV1NamespacedPodTemplateList",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of PodTemplate. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/podtemplates/{name}",
      "method": "watchCoreV1NamespacedPodTemplate",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch changes to an object of kind PodTemplate. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/replicationcontrollers",
      "method": "watchCoreV1NamespacedReplicationControllerList",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of ReplicationController. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/replicationcontrollers/{name}",
      "method": "watchCoreV1NamespacedReplicationController",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch changes to an object of kind ReplicationController. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/resourcequotas",
      "method": "watchCoreV1NamespacedResourceQuotaList",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of ResourceQuota. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/resourcequotas/{name}",
      "method": "watchCoreV1NamespacedResourceQuota",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch changes to an object of kind ResourceQuota. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/secrets",
      "method": "watchCoreV1NamespacedSecretList",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of Secret. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/secrets/{name}",
      "method": "watchCoreV1NamespacedSecret",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch changes to an object of kind Secret. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/serviceaccounts",
      "method": "watchCoreV1NamespacedServiceAccountList",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of ServiceAccount. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/serviceaccounts/{name}",
      "method": "watchCoreV1NamespacedServiceAccount",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch changes to an object of kind ServiceAccount. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/services",
      "method": "watchCoreV1NamespacedServiceList",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of Service. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/services/{name}",
      "method": "watchCoreV1NamespacedService",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch changes to an object of kind Service. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{name}",
      "method": "watchCoreV1Namespace",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch changes to an object of kind Namespace. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/nodes",
      "method": "watchCoreV1NodeList",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of Node. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/nodes/{name}",
      "method": "watchCoreV1Node",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch changes to an object of kind Node. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/persistentvolumeclaims",
      "method": "watchCoreV1PersistentVolumeClaimListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of PersistentVolumeClaim. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/persistentvolumes",
      "method": "watchCoreV1PersistentVolumeList",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of PersistentVolume. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/persistentvolumes/{name}",
      "method": "watchCoreV1PersistentVolume",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch changes to an object of kind PersistentVolume. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/pods",
      "method": "watchCoreV1PodListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of Pod. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/podtemplates",
      "method": "watchCoreV1PodTemplateListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of PodTemplate. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/replicationcontrollers",
      "method": "watchCoreV1ReplicationControllerListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of ReplicationController. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/resourcequotas",
      "method": "watchCoreV1ResourceQuotaListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of ResourceQuota. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/secrets",
      "method": "watchCoreV1SecretListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of Secret. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/serviceaccounts",
      "method": "watchCoreV1ServiceAccountListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of ServiceAccount. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/services",
      "method": "watchCoreV1ServiceListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "description": "watch individual changes to a list of Service. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/",
      "method": "getApiVersions",
      "httpMethod": "get",
      "tag": "apis",
      "description": "get available API versions",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroupList is a list of APIGroup, to allow clients to discover the API at /apis."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/",
      "method": "getAdmissionregistrationApiGroup",
      "httpMethod": "get",
      "tag": "admissionregistration",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1/",
      "method": "getAdmissionregistrationV1ApiResources",
      "httpMethod": "get",
      "tag": "admissionregistration_v1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations",
      "method": "deleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration",
      "httpMethod": "delete",
      "tag": "admissionregistration_v1",
      "description": "delete collection of MutatingWebhookConfiguration",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations",
      "method": "listAdmissionregistrationV1MutatingWebhookConfiguration",
      "httpMethod": "get",
      "tag": "admissionregistration_v1",
      "description": "list or watch objects of kind MutatingWebhookConfiguration",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations",
      "method": "createAdmissionregistrationV1MutatingWebhookConfiguration",
      "httpMethod": "post",
      "tag": "admissionregistration_v1",
      "description": "create a MutatingWebhookConfiguration",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "webhooks",
          "schema": "array",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object."
        },
        {
          "statusCode": "201",
          "description": "MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object."
        },
        {
          "statusCode": "202",
          "description": "MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}",
      "method": "deleteAdmissionregistrationV1MutatingWebhookConfiguration",
      "httpMethod": "delete",
      "tag": "admissionregistration_v1",
      "description": "delete a MutatingWebhookConfiguration",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}",
      "method": "readAdmissionregistrationV1MutatingWebhookConfiguration",
      "httpMethod": "get",
      "tag": "admissionregistration_v1",
      "description": "read the specified MutatingWebhookConfiguration",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}",
      "method": "patchAdmissionregistrationV1MutatingWebhookConfiguration",
      "httpMethod": "patch",
      "tag": "admissionregistration_v1",
      "description": "partially update the specified MutatingWebhookConfiguration",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object."
        },
        {
          "statusCode": "201",
          "description": "MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}",
      "method": "replaceAdmissionregistrationV1MutatingWebhookConfiguration",
      "httpMethod": "put",
      "tag": "admissionregistration_v1",
      "description": "replace the specified MutatingWebhookConfiguration",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "webhooks",
          "schema": "array",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object."
        },
        {
          "statusCode": "201",
          "description": "MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations",
      "method": "deleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration",
      "httpMethod": "delete",
      "tag": "admissionregistration_v1",
      "description": "delete collection of ValidatingWebhookConfiguration",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations",
      "method": "listAdmissionregistrationV1ValidatingWebhookConfiguration",
      "httpMethod": "get",
      "tag": "admissionregistration_v1",
      "description": "list or watch objects of kind ValidatingWebhookConfiguration",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations",
      "method": "createAdmissionregistrationV1ValidatingWebhookConfiguration",
      "httpMethod": "post",
      "tag": "admissionregistration_v1",
      "description": "create a ValidatingWebhookConfiguration",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "webhooks",
          "schema": "array",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it."
        },
        {
          "statusCode": "201",
          "description": "ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it."
        },
        {
          "statusCode": "202",
          "description": "ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}",
      "method": "deleteAdmissionregistrationV1ValidatingWebhookConfiguration",
      "httpMethod": "delete",
      "tag": "admissionregistration_v1",
      "description": "delete a ValidatingWebhookConfiguration",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}",
      "method": "readAdmissionregistrationV1ValidatingWebhookConfiguration",
      "httpMethod": "get",
      "tag": "admissionregistration_v1",
      "description": "read the specified ValidatingWebhookConfiguration",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}",
      "method": "patchAdmissionregistrationV1ValidatingWebhookConfiguration",
      "httpMethod": "patch",
      "tag": "admissionregistration_v1",
      "description": "partially update the specified ValidatingWebhookConfiguration",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it."
        },
        {
          "statusCode": "201",
          "description": "ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}",
      "method": "replaceAdmissionregistrationV1ValidatingWebhookConfiguration",
      "httpMethod": "put",
      "tag": "admissionregistration_v1",
      "description": "replace the specified ValidatingWebhookConfiguration",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "webhooks",
          "schema": "array",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it."
        },
        {
          "statusCode": "201",
          "description": "ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1/watch/mutatingwebhookconfigurations",
      "method": "watchAdmissionregistrationV1MutatingWebhookConfigurationList",
      "httpMethod": "get",
      "tag": "admissionregistration_v1",
      "description": "watch individual changes to a list of MutatingWebhookConfiguration. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1/watch/mutatingwebhookconfigurations/{name}",
      "method": "watchAdmissionregistrationV1MutatingWebhookConfiguration",
      "httpMethod": "get",
      "tag": "admissionregistration_v1",
      "description": "watch changes to an object of kind MutatingWebhookConfiguration. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1/watch/validatingwebhookconfigurations",
      "method": "watchAdmissionregistrationV1ValidatingWebhookConfigurationList",
      "httpMethod": "get",
      "tag": "admissionregistration_v1",
      "description": "watch individual changes to a list of ValidatingWebhookConfiguration. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1/watch/validatingwebhookconfigurations/{name}",
      "method": "watchAdmissionregistrationV1ValidatingWebhookConfiguration",
      "httpMethod": "get",
      "tag": "admissionregistration_v1",
      "description": "watch changes to an object of kind ValidatingWebhookConfiguration. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/",
      "method": "getAdmissionregistrationV1Alpha1ApiResources",
      "httpMethod": "get",
      "tag": "admissionregistration_v1alpha1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicies",
      "method": "deleteAdmissionregistrationV1Alpha1CollectionValidatingAdmissionPolicy",
      "httpMethod": "delete",
      "tag": "admissionregistration_v1alpha1",
      "description": "delete collection of ValidatingAdmissionPolicy",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicies",
      "method": "listAdmissionregistrationV1Alpha1ValidatingAdmissionPolicy",
      "httpMethod": "get",
      "tag": "admissionregistration_v1alpha1",
      "description": "list or watch objects of kind ValidatingAdmissionPolicy",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingAdmissionPolicyList is a list of ValidatingAdmissionPolicy."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicies",
      "method": "createAdmissionregistrationV1Alpha1ValidatingAdmissionPolicy",
      "httpMethod": "post",
      "tag": "admissionregistration_v1alpha1",
      "description": "create a ValidatingAdmissionPolicy",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it."
        },
        {
          "statusCode": "201",
          "description": "ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it."
        },
        {
          "statusCode": "202",
          "description": "ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicies/{name}",
      "method": "deleteAdmissionregistrationV1Alpha1ValidatingAdmissionPolicy",
      "httpMethod": "delete",
      "tag": "admissionregistration_v1alpha1",
      "description": "delete a ValidatingAdmissionPolicy",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicies/{name}",
      "method": "readAdmissionregistrationV1Alpha1ValidatingAdmissionPolicy",
      "httpMethod": "get",
      "tag": "admissionregistration_v1alpha1",
      "description": "read the specified ValidatingAdmissionPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicies/{name}",
      "method": "patchAdmissionregistrationV1Alpha1ValidatingAdmissionPolicy",
      "httpMethod": "patch",
      "tag": "admissionregistration_v1alpha1",
      "description": "partially update the specified ValidatingAdmissionPolicy",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it."
        },
        {
          "statusCode": "201",
          "description": "ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicies/{name}",
      "method": "replaceAdmissionregistrationV1Alpha1ValidatingAdmissionPolicy",
      "httpMethod": "put",
      "tag": "admissionregistration_v1alpha1",
      "description": "replace the specified ValidatingAdmissionPolicy",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it."
        },
        {
          "statusCode": "201",
          "description": "ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicies/{name}/status",
      "method": "readAdmissionregistrationV1Alpha1ValidatingAdmissionPolicyStatus",
      "httpMethod": "get",
      "tag": "admissionregistration_v1alpha1",
      "description": "read status of the specified ValidatingAdmissionPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicies/{name}/status",
      "method": "patchAdmissionregistrationV1Alpha1ValidatingAdmissionPolicyStatus",
      "httpMethod": "patch",
      "tag": "admissionregistration_v1alpha1",
      "description": "partially update status of the specified ValidatingAdmissionPolicy",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it."
        },
        {
          "statusCode": "201",
          "description": "ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicies/{name}/status",
      "method": "replaceAdmissionregistrationV1Alpha1ValidatingAdmissionPolicyStatus",
      "httpMethod": "put",
      "tag": "admissionregistration_v1alpha1",
      "description": "replace status of the specified ValidatingAdmissionPolicy",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it."
        },
        {
          "statusCode": "201",
          "description": "ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicybindings",
      "method": "deleteAdmissionregistrationV1Alpha1CollectionValidatingAdmissionPolicyBinding",
      "httpMethod": "delete",
      "tag": "admissionregistration_v1alpha1",
      "description": "delete collection of ValidatingAdmissionPolicyBinding",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicybindings",
      "method": "listAdmissionregistrationV1Alpha1ValidatingAdmissionPolicyBinding",
      "httpMethod": "get",
      "tag": "admissionregistration_v1alpha1",
      "description": "list or watch objects of kind ValidatingAdmissionPolicyBinding",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingAdmissionPolicyBindingList is a list of ValidatingAdmissionPolicyBinding."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicybindings",
      "method": "createAdmissionregistrationV1Alpha1ValidatingAdmissionPolicyBinding",
      "httpMethod": "post",
      "tag": "admissionregistration_v1alpha1",
      "description": "create a ValidatingAdmissionPolicyBinding",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources. ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters."
        },
        {
          "statusCode": "201",
          "description": "ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources. ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters."
        },
        {
          "statusCode": "202",
          "description": "ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources. ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicybindings/{name}",
      "method": "deleteAdmissionregistrationV1Alpha1ValidatingAdmissionPolicyBinding",
      "httpMethod": "delete",
      "tag": "admissionregistration_v1alpha1",
      "description": "delete a ValidatingAdmissionPolicyBinding",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicybindings/{name}",
      "method": "readAdmissionregistrationV1Alpha1ValidatingAdmissionPolicyBinding",
      "httpMethod": "get",
      "tag": "admissionregistration_v1alpha1",
      "description": "read the specified ValidatingAdmissionPolicyBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources. ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicybindings/{name}",
      "method": "patchAdmissionregistrationV1Alpha1ValidatingAdmissionPolicyBinding",
      "httpMethod": "patch",
      "tag": "admissionregistration_v1alpha1",
      "description": "partially update the specified ValidatingAdmissionPolicyBinding",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources. ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters."
        },
        {
          "statusCode": "201",
          "description": "ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources. ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/validatingadmissionpolicybindings/{name}",
      "method": "replaceAdmissionregistrationV1Alpha1ValidatingAdmissionPolicyBinding",
      "httpMethod": "put",
      "tag": "admissionregistration_v1alpha1",
      "description": "replace the specified ValidatingAdmissionPolicyBinding",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources. ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters."
        },
        {
          "statusCode": "201",
          "description": "ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources. ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/watch/validatingadmissionpolicies",
      "method": "watchAdmissionregistrationV1Alpha1ValidatingAdmissionPolicyList",
      "httpMethod": "get",
      "tag": "admissionregistration_v1alpha1",
      "description": "watch individual changes to a list of ValidatingAdmissionPolicy. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/watch/validatingadmissionpolicies/{name}",
      "method": "watchAdmissionregistrationV1Alpha1ValidatingAdmissionPolicy",
      "httpMethod": "get",
      "tag": "admissionregistration_v1alpha1",
      "description": "watch changes to an object of kind ValidatingAdmissionPolicy. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/watch/validatingadmissionpolicybindings",
      "method": "watchAdmissionregistrationV1Alpha1ValidatingAdmissionPolicyBindingList",
      "httpMethod": "get",
      "tag": "admissionregistration_v1alpha1",
      "description": "watch individual changes to a list of ValidatingAdmissionPolicyBinding. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/watch/validatingadmissionpolicybindings/{name}",
      "method": "watchAdmissionregistrationV1Alpha1ValidatingAdmissionPolicyBinding",
      "httpMethod": "get",
      "tag": "admissionregistration_v1alpha1",
      "description": "watch changes to an object of kind ValidatingAdmissionPolicyBinding. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/",
      "method": "getApiextensionsApiGroup",
      "httpMethod": "get",
      "tag": "apiextensions",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1/",
      "method": "getApiextensionsV1ApiResources",
      "httpMethod": "get",
      "tag": "apiextensions_v1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1/customresourcedefinitions",
      "method": "deleteApiextensionsV1CollectionCustomResourceDefinition",
      "httpMethod": "delete",
      "tag": "apiextensions_v1",
      "description": "delete collection of CustomResourceDefinition",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1/customresourcedefinitions",
      "method": "listApiextensionsV1CustomResourceDefinition",
      "httpMethod": "get",
      "tag": "apiextensions_v1",
      "description": "list or watch objects of kind CustomResourceDefinition",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CustomResourceDefinitionList is a list of CustomResourceDefinition objects."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1/customresourcedefinitions",
      "method": "createApiextensionsV1CustomResourceDefinition",
      "httpMethod": "post",
      "tag": "apiextensions_v1",
      "description": "create a CustomResourceDefinition",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        },
        {
          "statusCode": "201",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        },
        {
          "statusCode": "202",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}",
      "method": "deleteApiextensionsV1CustomResourceDefinition",
      "httpMethod": "delete",
      "tag": "apiextensions_v1",
      "description": "delete a CustomResourceDefinition",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}",
      "method": "readApiextensionsV1CustomResourceDefinition",
      "httpMethod": "get",
      "tag": "apiextensions_v1",
      "description": "read the specified CustomResourceDefinition",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}",
      "method": "patchApiextensionsV1CustomResourceDefinition",
      "httpMethod": "patch",
      "tag": "apiextensions_v1",
      "description": "partially update the specified CustomResourceDefinition",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        },
        {
          "statusCode": "201",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}",
      "method": "replaceApiextensionsV1CustomResourceDefinition",
      "httpMethod": "put",
      "tag": "apiextensions_v1",
      "description": "replace the specified CustomResourceDefinition",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        },
        {
          "statusCode": "201",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}/status",
      "method": "readApiextensionsV1CustomResourceDefinitionStatus",
      "httpMethod": "get",
      "tag": "apiextensions_v1",
      "description": "read status of the specified CustomResourceDefinition",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}/status",
      "method": "patchApiextensionsV1CustomResourceDefinitionStatus",
      "httpMethod": "patch",
      "tag": "apiextensions_v1",
      "description": "partially update status of the specified CustomResourceDefinition",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        },
        {
          "statusCode": "201",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}/status",
      "method": "replaceApiextensionsV1CustomResourceDefinitionStatus",
      "httpMethod": "put",
      "tag": "apiextensions_v1",
      "description": "replace status of the specified CustomResourceDefinition",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        },
        {
          "statusCode": "201",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1/watch/customresourcedefinitions",
      "method": "watchApiextensionsV1CustomResourceDefinitionList",
      "httpMethod": "get",
      "tag": "apiextensions_v1",
      "description": "watch individual changes to a list of CustomResourceDefinition. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1/watch/customresourcedefinitions/{name}",
      "method": "watchApiextensionsV1CustomResourceDefinition",
      "httpMethod": "get",
      "tag": "apiextensions_v1",
      "description": "watch changes to an object of kind CustomResourceDefinition. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/",
      "method": "getApiregistrationApiGroup",
      "httpMethod": "get",
      "tag": "apiregistration",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/",
      "method": "getApiregistrationV1ApiResources",
      "httpMethod": "get",
      "tag": "apiregistration_v1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/apiservices",
      "method": "deleteApiregistrationV1CollectionApiService",
      "httpMethod": "delete",
      "tag": "apiregistration_v1",
      "description": "delete collection of APIService",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/apiservices",
      "method": "listApiregistrationV1ApiService",
      "httpMethod": "get",
      "tag": "apiregistration_v1",
      "description": "list or watch objects of kind APIService",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIServiceList is a list of APIService objects."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/apiservices",
      "method": "createApiregistrationV1ApiService",
      "httpMethod": "post",
      "tag": "apiregistration_v1",
      "description": "create an APIService",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        },
        {
          "statusCode": "201",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        },
        {
          "statusCode": "202",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/apiservices/{name}",
      "method": "deleteApiregistrationV1ApiService",
      "httpMethod": "delete",
      "tag": "apiregistration_v1",
      "description": "delete an APIService",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/apiservices/{name}",
      "method": "readApiregistrationV1ApiService",
      "httpMethod": "get",
      "tag": "apiregistration_v1",
      "description": "read the specified APIService",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/apiservices/{name}",
      "method": "patchApiregistrationV1ApiService",
      "httpMethod": "patch",
      "tag": "apiregistration_v1",
      "description": "partially update the specified APIService",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        },
        {
          "statusCode": "201",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/apiservices/{name}",
      "method": "replaceApiregistrationV1ApiService",
      "httpMethod": "put",
      "tag": "apiregistration_v1",
      "description": "replace the specified APIService",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        },
        {
          "statusCode": "201",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/apiservices/{name}/status",
      "method": "readApiregistrationV1ApiServiceStatus",
      "httpMethod": "get",
      "tag": "apiregistration_v1",
      "description": "read status of the specified APIService",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/apiservices/{name}/status",
      "method": "patchApiregistrationV1ApiServiceStatus",
      "httpMethod": "patch",
      "tag": "apiregistration_v1",
      "description": "partially update status of the specified APIService",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        },
        {
          "statusCode": "201",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/apiservices/{name}/status",
      "method": "replaceApiregistrationV1ApiServiceStatus",
      "httpMethod": "put",
      "tag": "apiregistration_v1",
      "description": "replace status of the specified APIService",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        },
        {
          "statusCode": "201",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/watch/apiservices",
      "method": "watchApiregistrationV1ApiServiceList",
      "httpMethod": "get",
      "tag": "apiregistration_v1",
      "description": "watch individual changes to a list of APIService. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/watch/apiservices/{name}",
      "method": "watchApiregistrationV1ApiService",
      "httpMethod": "get",
      "tag": "apiregistration_v1",
      "description": "watch changes to an object of kind APIService. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/",
      "method": "getAppsApiGroup",
      "httpMethod": "get",
      "tag": "apps",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/",
      "method": "getAppsV1ApiResources",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/controllerrevisions",
      "method": "listAppsV1ControllerRevisionForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "list or watch objects of kind ControllerRevision",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ControllerRevisionList is a resource containing a list of ControllerRevision objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/daemonsets",
      "method": "listAppsV1DaemonSetForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "list or watch objects of kind DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSetList is a collection of daemon sets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/deployments",
      "method": "listAppsV1DeploymentForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "list or watch objects of kind Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DeploymentList is a list of Deployments."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/controllerrevisions",
      "method": "deleteAppsV1CollectionNamespacedControllerRevision",
      "httpMethod": "delete",
      "tag": "apps_v1",
      "description": "delete collection of ControllerRevision",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/controllerrevisions",
      "method": "listAppsV1NamespacedControllerRevision",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "list or watch objects of kind ControllerRevision",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ControllerRevisionList is a resource containing a list of ControllerRevision objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/controllerrevisions",
      "method": "createAppsV1NamespacedControllerRevision",
      "httpMethod": "post",
      "tag": "apps_v1",
      "description": "create a ControllerRevision",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "data",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "revision",
          "schema": "integer",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        },
        {
          "statusCode": "201",
          "description": "ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        },
        {
          "statusCode": "202",
          "description": "ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}",
      "method": "deleteAppsV1NamespacedControllerRevision",
      "httpMethod": "delete",
      "tag": "apps_v1",
      "description": "delete a ControllerRevision",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}",
      "method": "readAppsV1NamespacedControllerRevision",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "read the specified ControllerRevision",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}",
      "method": "patchAppsV1NamespacedControllerRevision",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "description": "partially update the specified ControllerRevision",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        },
        {
          "statusCode": "201",
          "description": "ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}",
      "method": "replaceAppsV1NamespacedControllerRevision",
      "httpMethod": "put",
      "tag": "apps_v1",
      "description": "replace the specified ControllerRevision",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "data",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "revision",
          "schema": "integer",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        },
        {
          "statusCode": "201",
          "description": "ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/daemonsets",
      "method": "deleteAppsV1CollectionNamespacedDaemonSet",
      "httpMethod": "delete",
      "tag": "apps_v1",
      "description": "delete collection of DaemonSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/daemonsets",
      "method": "listAppsV1NamespacedDaemonSet",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "list or watch objects of kind DaemonSet",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSetList is a collection of daemon sets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/daemonsets",
      "method": "createAppsV1NamespacedDaemonSet",
      "httpMethod": "post",
      "tag": "apps_v1",
      "description": "create a DaemonSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSet represents the configuration of a daemon set."
        },
        {
          "statusCode": "201",
          "description": "DaemonSet represents the configuration of a daemon set."
        },
        {
          "statusCode": "202",
          "description": "DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}",
      "method": "deleteAppsV1NamespacedDaemonSet",
      "httpMethod": "delete",
      "tag": "apps_v1",
      "description": "delete a DaemonSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}",
      "method": "readAppsV1NamespacedDaemonSet",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "read the specified DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}",
      "method": "patchAppsV1NamespacedDaemonSet",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "description": "partially update the specified DaemonSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSet represents the configuration of a daemon set."
        },
        {
          "statusCode": "201",
          "description": "DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}",
      "method": "replaceAppsV1NamespacedDaemonSet",
      "httpMethod": "put",
      "tag": "apps_v1",
      "description": "replace the specified DaemonSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSet represents the configuration of a daemon set."
        },
        {
          "statusCode": "201",
          "description": "DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status",
      "method": "readAppsV1NamespacedDaemonSetStatus",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "read status of the specified DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status",
      "method": "patchAppsV1NamespacedDaemonSetStatus",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "description": "partially update status of the specified DaemonSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSet represents the configuration of a daemon set."
        },
        {
          "statusCode": "201",
          "description": "DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status",
      "method": "replaceAppsV1NamespacedDaemonSetStatus",
      "httpMethod": "put",
      "tag": "apps_v1",
      "description": "replace status of the specified DaemonSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSet represents the configuration of a daemon set."
        },
        {
          "statusCode": "201",
          "description": "DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments",
      "method": "deleteAppsV1CollectionNamespacedDeployment",
      "httpMethod": "delete",
      "tag": "apps_v1",
      "description": "delete collection of Deployment",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments",
      "method": "listAppsV1NamespacedDeployment",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "list or watch objects of kind Deployment",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DeploymentList is a list of Deployments."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments",
      "method": "createAppsV1NamespacedDeployment",
      "httpMethod": "post",
      "tag": "apps_v1",
      "description": "create a Deployment",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "201",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "202",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments/{name}",
      "method": "deleteAppsV1NamespacedDeployment",
      "httpMethod": "delete",
      "tag": "apps_v1",
      "description": "delete a Deployment",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments/{name}",
      "method": "readAppsV1NamespacedDeployment",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "read the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments/{name}",
      "method": "patchAppsV1NamespacedDeployment",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "description": "partially update the specified Deployment",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "201",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments/{name}",
      "method": "replaceAppsV1NamespacedDeployment",
      "httpMethod": "put",
      "tag": "apps_v1",
      "description": "replace the specified Deployment",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "201",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale",
      "method": "readAppsV1NamespacedDeploymentScale",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "read scale of the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale",
      "method": "patchAppsV1NamespacedDeploymentScale",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "description": "partially update scale of the specified Deployment",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        },
        {
          "statusCode": "201",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale",
      "method": "replaceAppsV1NamespacedDeploymentScale",
      "httpMethod": "put",
      "tag": "apps_v1",
      "description": "replace scale of the specified Deployment",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        },
        {
          "statusCode": "201",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status",
      "method": "readAppsV1NamespacedDeploymentStatus",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "read status of the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status",
      "method": "patchAppsV1NamespacedDeploymentStatus",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "description": "partially update status of the specified Deployment",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "201",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status",
      "method": "replaceAppsV1NamespacedDeploymentStatus",
      "httpMethod": "put",
      "tag": "apps_v1",
      "description": "replace status of the specified Deployment",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "201",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets",
      "method": "deleteAppsV1CollectionNamespacedReplicaSet",
      "httpMethod": "delete",
      "tag": "apps_v1",
      "description": "delete collection of ReplicaSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets",
      "method": "listAppsV1NamespacedReplicaSet",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "list or watch objects of kind ReplicaSet",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSetList is a collection of ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets",
      "method": "createAppsV1NamespacedReplicaSet",
      "httpMethod": "post",
      "tag": "apps_v1",
      "description": "create a ReplicaSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        },
        {
          "statusCode": "201",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        },
        {
          "statusCode": "202",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}",
      "method": "deleteAppsV1NamespacedReplicaSet",
      "httpMethod": "delete",
      "tag": "apps_v1",
      "description": "delete a ReplicaSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}",
      "method": "readAppsV1NamespacedReplicaSet",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "read the specified ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}",
      "method": "patchAppsV1NamespacedReplicaSet",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "description": "partially update the specified ReplicaSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        },
        {
          "statusCode": "201",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}",
      "method": "replaceAppsV1NamespacedReplicaSet",
      "httpMethod": "put",
      "tag": "apps_v1",
      "description": "replace the specified ReplicaSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        },
        {
          "statusCode": "201",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale",
      "method": "readAppsV1NamespacedReplicaSetScale",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "read scale of the specified ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale",
      "method": "patchAppsV1NamespacedReplicaSetScale",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "description": "partially update scale of the specified ReplicaSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        },
        {
          "statusCode": "201",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale",
      "method": "replaceAppsV1NamespacedReplicaSetScale",
      "httpMethod": "put",
      "tag": "apps_v1",
      "description": "replace scale of the specified ReplicaSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        },
        {
          "statusCode": "201",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status",
      "method": "readAppsV1NamespacedReplicaSetStatus",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "read status of the specified ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status",
      "method": "patchAppsV1NamespacedReplicaSetStatus",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "description": "partially update status of the specified ReplicaSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        },
        {
          "statusCode": "201",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status",
      "method": "replaceAppsV1NamespacedReplicaSetStatus",
      "httpMethod": "put",
      "tag": "apps_v1",
      "description": "replace status of the specified ReplicaSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        },
        {
          "statusCode": "201",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets",
      "method": "deleteAppsV1CollectionNamespacedStatefulSet",
      "httpMethod": "delete",
      "tag": "apps_v1",
      "description": "delete collection of StatefulSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets",
      "method": "listAppsV1NamespacedStatefulSet",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "list or watch objects of kind StatefulSet",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSetList is a collection of StatefulSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets",
      "method": "createAppsV1NamespacedStatefulSet",
      "httpMethod": "post",
      "tag": "apps_v1",
      "description": "create a StatefulSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n  - Network: A single stable DNS and hostname.\n  - Storage: As many VolumeClaims as requested.\n\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        },
        {
          "statusCode": "201",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n  - Network: A single stable DNS and hostname.\n  - Storage: As many VolumeClaims as requested.\n\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        },
        {
          "statusCode": "202",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n  - Network: A single stable DNS and hostname.\n  - Storage: As many VolumeClaims as requested.\n\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}",
      "method": "deleteAppsV1NamespacedStatefulSet",
      "httpMethod": "delete",
      "tag": "apps_v1",
      "description": "delete a StatefulSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}",
      "method": "readAppsV1NamespacedStatefulSet",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "read the specified StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n  - Network: A single stable DNS and hostname.\n  - Storage: As many VolumeClaims as requested.\n\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}",
      "method": "patchAppsV1NamespacedStatefulSet",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "description": "partially update the specified StatefulSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n  - Network: A single stable DNS and hostname.\n  - Storage: As many VolumeClaims as requested.\n\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        },
        {
          "statusCode": "201",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n  - Network: A single stable DNS and hostname.\n  - Storage: As many VolumeClaims as requested.\n\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}",
      "method": "replaceAppsV1NamespacedStatefulSet",
      "httpMethod": "put",
      "tag": "apps_v1",
      "description": "replace the specified StatefulSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n  - Network: A single stable DNS and hostname.\n  - Storage: As many VolumeClaims as requested.\n\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        },
        {
          "statusCode": "201",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n  - Network: A single stable DNS and hostname.\n  - Storage: As many VolumeClaims as requested.\n\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale",
      "method": "readAppsV1NamespacedStatefulSetScale",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "read scale of the specified StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale",
      "method": "patchAppsV1NamespacedStatefulSetScale",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "description": "partially update scale of the specified StatefulSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        },
        {
          "statusCode": "201",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale",
      "method": "replaceAppsV1NamespacedStatefulSetScale",
      "httpMethod": "put",
      "tag": "apps_v1",
      "description": "replace scale of the specified StatefulSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        },
        {
          "statusCode": "201",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status",
      "method": "readAppsV1NamespacedStatefulSetStatus",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "read status of the specified StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n  - Network: A single stable DNS and hostname.\n  - Storage: As many VolumeClaims as requested.\n\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status",
      "method": "patchAppsV1NamespacedStatefulSetStatus",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "description": "partially update status of the specified StatefulSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n  - Network: A single stable DNS and hostname.\n  - Storage: As many VolumeClaims as requested.\n\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        },
        {
          "statusCode": "201",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n  - Network: A single stable DNS and hostname.\n  - Storage: As many VolumeClaims as requested.\n\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status",
      "method": "replaceAppsV1NamespacedStatefulSetStatus",
      "httpMethod": "put",
      "tag": "apps_v1",
      "description": "replace status of the specified StatefulSet",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n  - Network: A single stable DNS and hostname.\n  - Storage: As many VolumeClaims as requested.\n\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        },
        {
          "statusCode": "201",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n  - Network: A single stable DNS and hostname.\n  - Storage: As many VolumeClaims as requested.\n\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/replicasets",
      "method": "listAppsV1ReplicaSetForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "list or watch objects of kind ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSetList is a collection of ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/statefulsets",
      "method": "listAppsV1StatefulSetForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "list or watch objects of kind StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSetList is a collection of StatefulSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/controllerrevisions",
      "method": "watchAppsV1ControllerRevisionListForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "watch individual changes to a list of ControllerRevision. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/daemonsets",
      "method": "watchAppsV1DaemonSetListForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "watch individual changes to a list of DaemonSet. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/deployments",
      "method": "watchAppsV1DeploymentListForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "watch individual changes to a list of Deployment. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/namespaces/{namespace}/controllerrevisions",
      "method": "watchAppsV1NamespacedControllerRevisionList",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "watch individual changes to a list of ControllerRevision. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/namespaces/{namespace}/controllerrevisions/{name}",
      "method": "watchAppsV1NamespacedControllerRevision",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "watch changes to an object of kind ControllerRevision. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/namespaces/{namespace}/daemonsets",
      "method": "watchAppsV1NamespacedDaemonSetList",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "watch individual changes to a list of DaemonSet. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/namespaces/{namespace}/daemonsets/{name}",
      "method": "watchAppsV1NamespacedDaemonSet",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "watch changes to an object of kind DaemonSet. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/namespaces/{namespace}/deployments",
      "method": "watchAppsV1NamespacedDeploymentList",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "watch individual changes to a list of Deployment. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/namespaces/{namespace}/deployments/{name}",
      "method": "watchAppsV1NamespacedDeployment",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "watch changes to an object of kind Deployment. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/namespaces/{namespace}/replicasets",
      "method": "watchAppsV1NamespacedReplicaSetList",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "watch individual changes to a list of ReplicaSet. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/namespaces/{namespace}/replicasets/{name}",
      "method": "watchAppsV1NamespacedReplicaSet",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "watch changes to an object of kind ReplicaSet. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/namespaces/{namespace}/statefulsets",
      "method": "watchAppsV1NamespacedStatefulSetList",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "watch individual changes to a list of StatefulSet. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/namespaces/{namespace}/statefulsets/{name}",
      "method": "watchAppsV1NamespacedStatefulSet",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "watch changes to an object of kind StatefulSet. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/replicasets",
      "method": "watchAppsV1ReplicaSetListForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "watch individual changes to a list of ReplicaSet. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/statefulsets",
      "method": "watchAppsV1StatefulSetListForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1",
      "description": "watch individual changes to a list of StatefulSet. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/authentication.k8s.io/",
      "method": "getAuthenticationApiGroup",
      "httpMethod": "get",
      "tag": "authentication",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/authentication.k8s.io/v1/",
      "method": "getAuthenticationV1ApiResources",
      "httpMethod": "get",
      "tag": "authentication_v1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/authentication.k8s.io/v1/tokenreviews",
      "method": "createAuthenticationV1TokenReview",
      "httpMethod": "post",
      "tag": "authentication_v1",
      "description": "create a TokenReview",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver."
        },
        {
          "statusCode": "201",
          "description": "TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver."
        },
        {
          "statusCode": "202",
          "description": "TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver."
        }
      ]
    },
    {
      "url": "/apis/authentication.k8s.io/v1alpha1/",
      "method": "getAuthenticationV1Alpha1ApiResources",
      "httpMethod": "get",
      "tag": "authentication_v1alpha1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/authentication.k8s.io/v1alpha1/selfsubjectreviews",
      "method": "createAuthenticationV1Alpha1SelfSubjectReview",
      "httpMethod": "post",
      "tag": "authentication_v1alpha1",
      "description": "create a SelfSubjectReview",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "SelfSubjectReview contains the user information that the kube-apiserver has about the user making this request. When using impersonation, users will receive the user info of the user being impersonated.  If impersonation or request header authentication is used, any extra keys will have their case ignored and returned as lowercase."
        },
        {
          "statusCode": "201",
          "description": "SelfSubjectReview contains the user information that the kube-apiserver has about the user making this request. When using impersonation, users will receive the user info of the user being impersonated.  If impersonation or request header authentication is used, any extra keys will have their case ignored and returned as lowercase."
        },
        {
          "statusCode": "202",
          "description": "SelfSubjectReview contains the user information that the kube-apiserver has about the user making this request. When using impersonation, users will receive the user info of the user being impersonated.  If impersonation or request header authentication is used, any extra keys will have their case ignored and returned as lowercase."
        }
      ]
    },
    {
      "url": "/apis/authentication.k8s.io/v1beta1/",
      "method": "getAuthenticationV1Beta1ApiResources",
      "httpMethod": "get",
      "tag": "authentication_v1beta1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/authentication.k8s.io/v1beta1/selfsubjectreviews",
      "method": "createAuthenticationV1Beta1SelfSubjectReview",
      "httpMethod": "post",
      "tag": "authentication_v1beta1",
      "description": "create a SelfSubjectReview",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "SelfSubjectReview contains the user information that the kube-apiserver has about the user making this request. When using impersonation, users will receive the user info of the user being impersonated.  If impersonation or request header authentication is used, any extra keys will have their case ignored and returned as lowercase."
        },
        {
          "statusCode": "201",
          "description": "SelfSubjectReview contains the user information that the kube-apiserver has about the user making this request. When using impersonation, users will receive the user info of the user being impersonated.  If impersonation or request header authentication is used, any extra keys will have their case ignored and returned as lowercase."
        },
        {
          "statusCode": "202",
          "description": "SelfSubjectReview contains the user information that the kube-apiserver has about the user making this request. When using impersonation, users will receive the user info of the user being impersonated.  If impersonation or request header authentication is used, any extra keys will have their case ignored and returned as lowercase."
        }
      ]
    },
    {
      "url": "/apis/authorization.k8s.io/",
      "method": "getAuthorizationApiGroup",
      "httpMethod": "get",
      "tag": "authorization",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/authorization.k8s.io/v1/",
      "method": "getAuthorizationV1ApiResources",
      "httpMethod": "get",
      "tag": "authorization_v1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/authorization.k8s.io/v1/namespaces/{namespace}/localsubjectaccessreviews",
      "method": "createAuthorizationV1NamespacedLocalSubjectAccessReview",
      "httpMethod": "post",
      "tag": "authorization_v1",
      "description": "create a LocalSubjectAccessReview",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking."
        },
        {
          "statusCode": "201",
          "description": "LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking."
        },
        {
          "statusCode": "202",
          "description": "LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking."
        }
      ]
    },
    {
      "url": "/apis/authorization.k8s.io/v1/selfsubjectaccessreviews",
      "method": "createAuthorizationV1SelfSubjectAccessReview",
      "httpMethod": "post",
      "tag": "authorization_v1",
      "description": "create a SelfSubjectAccessReview",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means \"in all namespaces\".  Self is a special case, because users should always be able to check whether they can perform an action"
        },
        {
          "statusCode": "201",
          "description": "SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means \"in all namespaces\".  Self is a special case, because users should always be able to check whether they can perform an action"
        },
        {
          "statusCode": "202",
          "description": "SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means \"in all namespaces\".  Self is a special case, because users should always be able to check whether they can perform an action"
        }
      ]
    },
    {
      "url": "/apis/authorization.k8s.io/v1/selfsubjectrulesreviews",
      "method": "createAuthorizationV1SelfSubjectRulesReview",
      "httpMethod": "post",
      "tag": "authorization_v1",
      "description": "create a SelfSubjectRulesReview",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace. The returned list of actions may be incomplete depending on the server's authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview should be used by UIs to show/hide actions, or to quickly let an end user reason about their permissions. It should NOT Be used by external systems to drive authorization decisions as this raises confused deputy, cache lifetime/revocation, and correctness concerns. SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization decisions to the API server."
        },
        {
          "statusCode": "201",
          "description": "SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace. The returned list of actions may be incomplete depending on the server's authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview should be used by UIs to show/hide actions, or to quickly let an end user reason about their permissions. It should NOT Be used by external systems to drive authorization decisions as this raises confused deputy, cache lifetime/revocation, and correctness concerns. SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization decisions to the API server."
        },
        {
          "statusCode": "202",
          "description": "SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace. The returned list of actions may be incomplete depending on the server's authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview should be used by UIs to show/hide actions, or to quickly let an end user reason about their permissions. It should NOT Be used by external systems to drive authorization decisions as this raises confused deputy, cache lifetime/revocation, and correctness concerns. SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization decisions to the API server."
        }
      ]
    },
    {
      "url": "/apis/authorization.k8s.io/v1/subjectaccessreviews",
      "method": "createAuthorizationV1SubjectAccessReview",
      "httpMethod": "post",
      "tag": "authorization_v1",
      "description": "create a SubjectAccessReview",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "SubjectAccessReview checks whether or not a user or group can perform an action."
        },
        {
          "statusCode": "201",
          "description": "SubjectAccessReview checks whether or not a user or group can perform an action."
        },
        {
          "statusCode": "202",
          "description": "SubjectAccessReview checks whether or not a user or group can perform an action."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/",
      "method": "getAutoscalingApiGroup",
      "httpMethod": "get",
      "tag": "autoscaling",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/",
      "method": "getAutoscalingV1ApiResources",
      "httpMethod": "get",
      "tag": "autoscaling_v1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/horizontalpodautoscalers",
      "method": "listAutoscalingV1HorizontalPodAutoscalerForAllNamespaces",
      "httpMethod": "get",
      "tag": "autoscaling_v1",
      "description": "list or watch objects of kind HorizontalPodAutoscaler",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "list of horizontal pod autoscaler objects."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers",
      "method": "deleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler",
      "httpMethod": "delete",
      "tag": "autoscaling_v1",
      "description": "delete collection of HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers",
      "method": "listAutoscalingV1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "get",
      "tag": "autoscaling_v1",
      "description": "list or watch objects of kind HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "list of horizontal pod autoscaler objects."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers",
      "method": "createAutoscalingV1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "post",
      "tag": "autoscaling_v1",
      "description": "create a HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "configuration of a horizontal pod autoscaler."
        },
        {
          "statusCode": "201",
          "description": "configuration of a horizontal pod autoscaler."
        },
        {
          "statusCode": "202",
          "description": "configuration of a horizontal pod autoscaler."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}",
      "method": "deleteAutoscalingV1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "delete",
      "tag": "autoscaling_v1",
      "description": "delete a HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}",
      "method": "readAutoscalingV1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "get",
      "tag": "autoscaling_v1",
      "description": "read the specified HorizontalPodAutoscaler",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "configuration of a horizontal pod autoscaler."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}",
      "method": "patchAutoscalingV1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "patch",
      "tag": "autoscaling_v1",
      "description": "partially update the specified HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "configuration of a horizontal pod autoscaler."
        },
        {
          "statusCode": "201",
          "description": "configuration of a horizontal pod autoscaler."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}",
      "method": "replaceAutoscalingV1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "put",
      "tag": "autoscaling_v1",
      "description": "replace the specified HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "configuration of a horizontal pod autoscaler."
        },
        {
          "statusCode": "201",
          "description": "configuration of a horizontal pod autoscaler."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status",
      "method": "readAutoscalingV1NamespacedHorizontalPodAutoscalerStatus",
      "httpMethod": "get",
      "tag": "autoscaling_v1",
      "description": "read status of the specified HorizontalPodAutoscaler",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "configuration of a horizontal pod autoscaler."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status",
      "method": "patchAutoscalingV1NamespacedHorizontalPodAutoscalerStatus",
      "httpMethod": "patch",
      "tag": "autoscaling_v1",
      "description": "partially update status of the specified HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "configuration of a horizontal pod autoscaler."
        },
        {
          "statusCode": "201",
          "description": "configuration of a horizontal pod autoscaler."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status",
      "method": "replaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatus",
      "httpMethod": "put",
      "tag": "autoscaling_v1",
      "description": "replace status of the specified HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "configuration of a horizontal pod autoscaler."
        },
        {
          "statusCode": "201",
          "description": "configuration of a horizontal pod autoscaler."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/watch/horizontalpodautoscalers",
      "method": "watchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces",
      "httpMethod": "get",
      "tag": "autoscaling_v1",
      "description": "watch individual changes to a list of HorizontalPodAutoscaler. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/watch/namespaces/{namespace}/horizontalpodautoscalers",
      "method": "watchAutoscalingV1NamespacedHorizontalPodAutoscalerList",
      "httpMethod": "get",
      "tag": "autoscaling_v1",
      "description": "watch individual changes to a list of HorizontalPodAutoscaler. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}",
      "method": "watchAutoscalingV1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "get",
      "tag": "autoscaling_v1",
      "description": "watch changes to an object of kind HorizontalPodAutoscaler. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2/",
      "method": "getAutoscalingV2ApiResources",
      "httpMethod": "get",
      "tag": "autoscaling_v2",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2/horizontalpodautoscalers",
      "method": "listAutoscalingV2HorizontalPodAutoscalerForAllNamespaces",
      "httpMethod": "get",
      "tag": "autoscaling_v2",
      "description": "list or watch objects of kind HorizontalPodAutoscaler",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "HorizontalPodAutoscalerList is a list of horizontal pod autoscaler objects."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2/namespaces/{namespace}/horizontalpodautoscalers",
      "method": "deleteAutoscalingV2CollectionNamespacedHorizontalPodAutoscaler",
      "httpMethod": "delete",
      "tag": "autoscaling_v2",
      "description": "delete collection of HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2/namespaces/{namespace}/horizontalpodautoscalers",
      "method": "listAutoscalingV2NamespacedHorizontalPodAutoscaler",
      "httpMethod": "get",
      "tag": "autoscaling_v2",
      "description": "list or watch objects of kind HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "HorizontalPodAutoscalerList is a list of horizontal pod autoscaler objects."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2/namespaces/{namespace}/horizontalpodautoscalers",
      "method": "createAutoscalingV2NamespacedHorizontalPodAutoscaler",
      "httpMethod": "post",
      "tag": "autoscaling_v2",
      "description": "create a HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        },
        {
          "statusCode": "201",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        },
        {
          "statusCode": "202",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2/namespaces/{namespace}/horizontalpodautoscalers/{name}",
      "method": "deleteAutoscalingV2NamespacedHorizontalPodAutoscaler",
      "httpMethod": "delete",
      "tag": "autoscaling_v2",
      "description": "delete a HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2/namespaces/{namespace}/horizontalpodautoscalers/{name}",
      "method": "readAutoscalingV2NamespacedHorizontalPodAutoscaler",
      "httpMethod": "get",
      "tag": "autoscaling_v2",
      "description": "read the specified HorizontalPodAutoscaler",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2/namespaces/{namespace}/horizontalpodautoscalers/{name}",
      "method": "patchAutoscalingV2NamespacedHorizontalPodAutoscaler",
      "httpMethod": "patch",
      "tag": "autoscaling_v2",
      "description": "partially update the specified HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        },
        {
          "statusCode": "201",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2/namespaces/{namespace}/horizontalpodautoscalers/{name}",
      "method": "replaceAutoscalingV2NamespacedHorizontalPodAutoscaler",
      "httpMethod": "put",
      "tag": "autoscaling_v2",
      "description": "replace the specified HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        },
        {
          "statusCode": "201",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2/namespaces/{namespace}/horizontalpodautoscalers/{name}/status",
      "method": "readAutoscalingV2NamespacedHorizontalPodAutoscalerStatus",
      "httpMethod": "get",
      "tag": "autoscaling_v2",
      "description": "read status of the specified HorizontalPodAutoscaler",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2/namespaces/{namespace}/horizontalpodautoscalers/{name}/status",
      "method": "patchAutoscalingV2NamespacedHorizontalPodAutoscalerStatus",
      "httpMethod": "patch",
      "tag": "autoscaling_v2",
      "description": "partially update status of the specified HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        },
        {
          "statusCode": "201",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2/namespaces/{namespace}/horizontalpodautoscalers/{name}/status",
      "method": "replaceAutoscalingV2NamespacedHorizontalPodAutoscalerStatus",
      "httpMethod": "put",
      "tag": "autoscaling_v2",
      "description": "replace status of the specified HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        },
        {
          "statusCode": "201",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2/watch/horizontalpodautoscalers",
      "method": "watchAutoscalingV2HorizontalPodAutoscalerListForAllNamespaces",
      "httpMethod": "get",
      "tag": "autoscaling_v2",
      "description": "watch individual changes to a list of HorizontalPodAutoscaler. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2/watch/namespaces/{namespace}/horizontalpodautoscalers",
      "method": "watchAutoscalingV2NamespacedHorizontalPodAutoscalerList",
      "httpMethod": "get",
      "tag": "autoscaling_v2",
      "description": "watch individual changes to a list of HorizontalPodAutoscaler. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}",
      "method": "watchAutoscalingV2NamespacedHorizontalPodAutoscaler",
      "httpMethod": "get",
      "tag": "autoscaling_v2",
      "description": "watch changes to an object of kind HorizontalPodAutoscaler. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/batch/",
      "method": "getBatchApiGroup",
      "httpMethod": "get",
      "tag": "batch",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/",
      "method": "getBatchV1ApiResources",
      "httpMethod": "get",
      "tag": "batch_v1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/cronjobs",
      "method": "listBatchV1CronJobForAllNamespaces",
      "httpMethod": "get",
      "tag": "batch_v1",
      "description": "list or watch objects of kind CronJob",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJobList is a collection of cron jobs."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/jobs",
      "method": "listBatchV1JobForAllNamespaces",
      "httpMethod": "get",
      "tag": "batch_v1",
      "description": "list or watch objects of kind Job",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "JobList is a collection of jobs."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/cronjobs",
      "method": "deleteBatchV1CollectionNamespacedCronJob",
      "httpMethod": "delete",
      "tag": "batch_v1",
      "description": "delete collection of CronJob",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/cronjobs",
      "method": "listBatchV1NamespacedCronJob",
      "httpMethod": "get",
      "tag": "batch_v1",
      "description": "list or watch objects of kind CronJob",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJobList is a collection of cron jobs."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/cronjobs",
      "method": "createBatchV1NamespacedCronJob",
      "httpMethod": "post",
      "tag": "batch_v1",
      "description": "create a CronJob",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        },
        {
          "statusCode": "201",
          "description": "CronJob represents the configuration of a single cron job."
        },
        {
          "statusCode": "202",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/cronjobs/{name}",
      "method": "deleteBatchV1NamespacedCronJob",
      "httpMethod": "delete",
      "tag": "batch_v1",
      "description": "delete a CronJob",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/cronjobs/{name}",
      "method": "readBatchV1NamespacedCronJob",
      "httpMethod": "get",
      "tag": "batch_v1",
      "description": "read the specified CronJob",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/cronjobs/{name}",
      "method": "patchBatchV1NamespacedCronJob",
      "httpMethod": "patch",
      "tag": "batch_v1",
      "description": "partially update the specified CronJob",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        },
        {
          "statusCode": "201",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/cronjobs/{name}",
      "method": "replaceBatchV1NamespacedCronJob",
      "httpMethod": "put",
      "tag": "batch_v1",
      "description": "replace the specified CronJob",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        },
        {
          "statusCode": "201",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/cronjobs/{name}/status",
      "method": "readBatchV1NamespacedCronJobStatus",
      "httpMethod": "get",
      "tag": "batch_v1",
      "description": "read status of the specified CronJob",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/cronjobs/{name}/status",
      "method": "patchBatchV1NamespacedCronJobStatus",
      "httpMethod": "patch",
      "tag": "batch_v1",
      "description": "partially update status of the specified CronJob",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        },
        {
          "statusCode": "201",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/cronjobs/{name}/status",
      "method": "replaceBatchV1NamespacedCronJobStatus",
      "httpMethod": "put",
      "tag": "batch_v1",
      "description": "replace status of the specified CronJob",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        },
        {
          "statusCode": "201",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/jobs",
      "method": "deleteBatchV1CollectionNamespacedJob",
      "httpMethod": "delete",
      "tag": "batch_v1",
      "description": "delete collection of Job",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/jobs",
      "method": "listBatchV1NamespacedJob",
      "httpMethod": "get",
      "tag": "batch_v1",
      "description": "list or watch objects of kind Job",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "JobList is a collection of jobs."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/jobs",
      "method": "createBatchV1NamespacedJob",
      "httpMethod": "post",
      "tag": "batch_v1",
      "description": "create a Job",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Job represents the configuration of a single job."
        },
        {
          "statusCode": "201",
          "description": "Job represents the configuration of a single job."
        },
        {
          "statusCode": "202",
          "description": "Job represents the configuration of a single job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/jobs/{name}",
      "method": "deleteBatchV1NamespacedJob",
      "httpMethod": "delete",
      "tag": "batch_v1",
      "description": "delete a Job",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/jobs/{name}",
      "method": "readBatchV1NamespacedJob",
      "httpMethod": "get",
      "tag": "batch_v1",
      "description": "read the specified Job",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Job represents the configuration of a single job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/jobs/{name}",
      "method": "patchBatchV1NamespacedJob",
      "httpMethod": "patch",
      "tag": "batch_v1",
      "description": "partially update the specified Job",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Job represents the configuration of a single job."
        },
        {
          "statusCode": "201",
          "description": "Job represents the configuration of a single job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/jobs/{name}",
      "method": "replaceBatchV1NamespacedJob",
      "httpMethod": "put",
      "tag": "batch_v1",
      "description": "replace the specified Job",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Job represents the configuration of a single job."
        },
        {
          "statusCode": "201",
          "description": "Job represents the configuration of a single job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status",
      "method": "readBatchV1NamespacedJobStatus",
      "httpMethod": "get",
      "tag": "batch_v1",
      "description": "read status of the specified Job",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Job represents the configuration of a single job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status",
      "method": "patchBatchV1NamespacedJobStatus",
      "httpMethod": "patch",
      "tag": "batch_v1",
      "description": "partially update status of the specified Job",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Job represents the configuration of a single job."
        },
        {
          "statusCode": "201",
          "description": "Job represents the configuration of a single job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status",
      "method": "replaceBatchV1NamespacedJobStatus",
      "httpMethod": "put",
      "tag": "batch_v1",
      "description": "replace status of the specified Job",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Job represents the configuration of a single job."
        },
        {
          "statusCode": "201",
          "description": "Job represents the configuration of a single job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/watch/cronjobs",
      "method": "watchBatchV1CronJobListForAllNamespaces",
      "httpMethod": "get",
      "tag": "batch_v1",
      "description": "watch individual changes to a list of CronJob. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/watch/jobs",
      "method": "watchBatchV1JobListForAllNamespaces",
      "httpMethod": "get",
      "tag": "batch_v1",
      "description": "watch individual changes to a list of Job. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/watch/namespaces/{namespace}/cronjobs",
      "method": "watchBatchV1NamespacedCronJobList",
      "httpMethod": "get",
      "tag": "batch_v1",
      "description": "watch individual changes to a list of CronJob. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/watch/namespaces/{namespace}/cronjobs/{name}",
      "method": "watchBatchV1NamespacedCronJob",
      "httpMethod": "get",
      "tag": "batch_v1",
      "description": "watch changes to an object of kind CronJob. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/watch/namespaces/{namespace}/jobs",
      "method": "watchBatchV1NamespacedJobList",
      "httpMethod": "get",
      "tag": "batch_v1",
      "description": "watch individual changes to a list of Job. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/watch/namespaces/{namespace}/jobs/{name}",
      "method": "watchBatchV1NamespacedJob",
      "httpMethod": "get",
      "tag": "batch_v1",
      "description": "watch changes to an object of kind Job. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/",
      "method": "getCertificatesApiGroup",
      "httpMethod": "get",
      "tag": "certificates",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1/",
      "method": "getCertificatesV1ApiResources",
      "httpMethod": "get",
      "tag": "certificates_v1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1/certificatesigningrequests",
      "method": "deleteCertificatesV1CollectionCertificateSigningRequest",
      "httpMethod": "delete",
      "tag": "certificates_v1",
      "description": "delete collection of CertificateSigningRequest",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1/certificatesigningrequests",
      "method": "listCertificatesV1CertificateSigningRequest",
      "httpMethod": "get",
      "tag": "certificates_v1",
      "description": "list or watch objects of kind CertificateSigningRequest",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CertificateSigningRequestList is a collection of CertificateSigningRequest objects"
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1/certificatesigningrequests",
      "method": "createCertificatesV1CertificateSigningRequest",
      "httpMethod": "post",
      "tag": "certificates_v1",
      "description": "create a CertificateSigningRequest",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers."
        },
        {
          "statusCode": "201",
          "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers."
        },
        {
          "statusCode": "202",
          "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}",
      "method": "deleteCertificatesV1CertificateSigningRequest",
      "httpMethod": "delete",
      "tag": "certificates_v1",
      "description": "delete a CertificateSigningRequest",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}",
      "method": "readCertificatesV1CertificateSigningRequest",
      "httpMethod": "get",
      "tag": "certificates_v1",
      "description": "read the specified CertificateSigningRequest",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}",
      "method": "patchCertificatesV1CertificateSigningRequest",
      "httpMethod": "patch",
      "tag": "certificates_v1",
      "description": "partially update the specified CertificateSigningRequest",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers."
        },
        {
          "statusCode": "201",
          "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}",
      "method": "replaceCertificatesV1CertificateSigningRequest",
      "httpMethod": "put",
      "tag": "certificates_v1",
      "description": "replace the specified CertificateSigningRequest",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers."
        },
        {
          "statusCode": "201",
          "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/approval",
      "method": "readCertificatesV1CertificateSigningRequestApproval",
      "httpMethod": "get",
      "tag": "certificates_v1",
      "description": "read approval of the specified CertificateSigningRequest",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/approval",
      "method": "patchCertificatesV1CertificateSigningRequestApproval",
      "httpMethod": "patch",
      "tag": "certificates_v1",
      "description": "partially update approval of the specified CertificateSigningRequest",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers."
        },
        {
          "statusCode": "201",
          "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/approval",
      "method": "replaceCertificatesV1CertificateSigningRequestApproval",
      "httpMethod": "put",
      "tag": "certificates_v1",
      "description": "replace approval of the specified CertificateSigningRequest",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers."
        },
        {
          "statusCode": "201",
          "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/status",
      "method": "readCertificatesV1CertificateSigningRequestStatus",
      "httpMethod": "get",
      "tag": "certificates_v1",
      "description": "read status of the specified CertificateSigningRequest",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/status",
      "method": "patchCertificatesV1CertificateSigningRequestStatus",
      "httpMethod": "patch",
      "tag": "certificates_v1",
      "description": "partially update status of the specified CertificateSigningRequest",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers."
        },
        {
          "statusCode": "201",
          "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1/certificatesigningrequests/{name}/status",
      "method": "replaceCertificatesV1CertificateSigningRequestStatus",
      "httpMethod": "put",
      "tag": "certificates_v1",
      "description": "replace status of the specified CertificateSigningRequest",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers."
        },
        {
          "statusCode": "201",
          "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1/watch/certificatesigningrequests",
      "method": "watchCertificatesV1CertificateSigningRequestList",
      "httpMethod": "get",
      "tag": "certificates_v1",
      "description": "watch individual changes to a list of CertificateSigningRequest. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1/watch/certificatesigningrequests/{name}",
      "method": "watchCertificatesV1CertificateSigningRequest",
      "httpMethod": "get",
      "tag": "certificates_v1",
      "description": "watch changes to an object of kind CertificateSigningRequest. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1alpha1/",
      "method": "getCertificatesV1Alpha1ApiResources",
      "httpMethod": "get",
      "tag": "certificates_v1alpha1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1alpha1/clustertrustbundles",
      "method": "deleteCertificatesV1Alpha1CollectionClusterTrustBundle",
      "httpMethod": "delete",
      "tag": "certificates_v1alpha1",
      "description": "delete collection of ClusterTrustBundle",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1alpha1/clustertrustbundles",
      "method": "listCertificatesV1Alpha1ClusterTrustBundle",
      "httpMethod": "get",
      "tag": "certificates_v1alpha1",
      "description": "list or watch objects of kind ClusterTrustBundle",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterTrustBundleList is a collection of ClusterTrustBundle objects"
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1alpha1/clustertrustbundles",
      "method": "createCertificatesV1Alpha1ClusterTrustBundle",
      "httpMethod": "post",
      "tag": "certificates_v1alpha1",
      "description": "create a ClusterTrustBundle",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterTrustBundle is a cluster-scoped container for X.509 trust anchors (root certificates).\n\nClusterTrustBundle objects are considered to be readable by any authenticated user in the cluster, because they can be mounted by pods using the `clusterTrustBundle` projection.  All service accounts have read access to ClusterTrustBundles by default.  Users who only have namespace-level access to a cluster can read ClusterTrustBundles by impersonating a serviceaccount that they have access to.\n\nIt can be optionally associated with a particular assigner, in which case it contains one valid set of trust anchors for that signer. Signers may have multiple associated ClusterTrustBundles; each is an independent set of trust anchors for that signer. Admission control is used to enforce that only users with permissions on the signer can create or modify the corresponding bundle."
        },
        {
          "statusCode": "201",
          "description": "ClusterTrustBundle is a cluster-scoped container for X.509 trust anchors (root certificates).\n\nClusterTrustBundle objects are considered to be readable by any authenticated user in the cluster, because they can be mounted by pods using the `clusterTrustBundle` projection.  All service accounts have read access to ClusterTrustBundles by default.  Users who only have namespace-level access to a cluster can read ClusterTrustBundles by impersonating a serviceaccount that they have access to.\n\nIt can be optionally associated with a particular assigner, in which case it contains one valid set of trust anchors for that signer. Signers may have multiple associated ClusterTrustBundles; each is an independent set of trust anchors for that signer. Admission control is used to enforce that only users with permissions on the signer can create or modify the corresponding bundle."
        },
        {
          "statusCode": "202",
          "description": "ClusterTrustBundle is a cluster-scoped container for X.509 trust anchors (root certificates).\n\nClusterTrustBundle objects are considered to be readable by any authenticated user in the cluster, because they can be mounted by pods using the `clusterTrustBundle` projection.  All service accounts have read access to ClusterTrustBundles by default.  Users who only have namespace-level access to a cluster can read ClusterTrustBundles by impersonating a serviceaccount that they have access to.\n\nIt can be optionally associated with a particular assigner, in which case it contains one valid set of trust anchors for that signer. Signers may have multiple associated ClusterTrustBundles; each is an independent set of trust anchors for that signer. Admission control is used to enforce that only users with permissions on the signer can create or modify the corresponding bundle."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1alpha1/clustertrustbundles/{name}",
      "method": "deleteCertificatesV1Alpha1ClusterTrustBundle",
      "httpMethod": "delete",
      "tag": "certificates_v1alpha1",
      "description": "delete a ClusterTrustBundle",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1alpha1/clustertrustbundles/{name}",
      "method": "readCertificatesV1Alpha1ClusterTrustBundle",
      "httpMethod": "get",
      "tag": "certificates_v1alpha1",
      "description": "read the specified ClusterTrustBundle",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterTrustBundle is a cluster-scoped container for X.509 trust anchors (root certificates).\n\nClusterTrustBundle objects are considered to be readable by any authenticated user in the cluster, because they can be mounted by pods using the `clusterTrustBundle` projection.  All service accounts have read access to ClusterTrustBundles by default.  Users who only have namespace-level access to a cluster can read ClusterTrustBundles by impersonating a serviceaccount that they have access to.\n\nIt can be optionally associated with a particular assigner, in which case it contains one valid set of trust anchors for that signer. Signers may have multiple associated ClusterTrustBundles; each is an independent set of trust anchors for that signer. Admission control is used to enforce that only users with permissions on the signer can create or modify the corresponding bundle."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1alpha1/clustertrustbundles/{name}",
      "method": "patchCertificatesV1Alpha1ClusterTrustBundle",
      "httpMethod": "patch",
      "tag": "certificates_v1alpha1",
      "description": "partially update the specified ClusterTrustBundle",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterTrustBundle is a cluster-scoped container for X.509 trust anchors (root certificates).\n\nClusterTrustBundle objects are considered to be readable by any authenticated user in the cluster, because they can be mounted by pods using the `clusterTrustBundle` projection.  All service accounts have read access to ClusterTrustBundles by default.  Users who only have namespace-level access to a cluster can read ClusterTrustBundles by impersonating a serviceaccount that they have access to.\n\nIt can be optionally associated with a particular assigner, in which case it contains one valid set of trust anchors for that signer. Signers may have multiple associated ClusterTrustBundles; each is an independent set of trust anchors for that signer. Admission control is used to enforce that only users with permissions on the signer can create or modify the corresponding bundle."
        },
        {
          "statusCode": "201",
          "description": "ClusterTrustBundle is a cluster-scoped container for X.509 trust anchors (root certificates).\n\nClusterTrustBundle objects are considered to be readable by any authenticated user in the cluster, because they can be mounted by pods using the `clusterTrustBundle` projection.  All service accounts have read access to ClusterTrustBundles by default.  Users who only have namespace-level access to a cluster can read ClusterTrustBundles by impersonating a serviceaccount that they have access to.\n\nIt can be optionally associated with a particular assigner, in which case it contains one valid set of trust anchors for that signer. Signers may have multiple associated ClusterTrustBundles; each is an independent set of trust anchors for that signer. Admission control is used to enforce that only users with permissions on the signer can create or modify the corresponding bundle."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1alpha1/clustertrustbundles/{name}",
      "method": "replaceCertificatesV1Alpha1ClusterTrustBundle",
      "httpMethod": "put",
      "tag": "certificates_v1alpha1",
      "description": "replace the specified ClusterTrustBundle",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterTrustBundle is a cluster-scoped container for X.509 trust anchors (root certificates).\n\nClusterTrustBundle objects are considered to be readable by any authenticated user in the cluster, because they can be mounted by pods using the `clusterTrustBundle` projection.  All service accounts have read access to ClusterTrustBundles by default.  Users who only have namespace-level access to a cluster can read ClusterTrustBundles by impersonating a serviceaccount that they have access to.\n\nIt can be optionally associated with a particular assigner, in which case it contains one valid set of trust anchors for that signer. Signers may have multiple associated ClusterTrustBundles; each is an independent set of trust anchors for that signer. Admission control is used to enforce that only users with permissions on the signer can create or modify the corresponding bundle."
        },
        {
          "statusCode": "201",
          "description": "ClusterTrustBundle is a cluster-scoped container for X.509 trust anchors (root certificates).\n\nClusterTrustBundle objects are considered to be readable by any authenticated user in the cluster, because they can be mounted by pods using the `clusterTrustBundle` projection.  All service accounts have read access to ClusterTrustBundles by default.  Users who only have namespace-level access to a cluster can read ClusterTrustBundles by impersonating a serviceaccount that they have access to.\n\nIt can be optionally associated with a particular assigner, in which case it contains one valid set of trust anchors for that signer. Signers may have multiple associated ClusterTrustBundles; each is an independent set of trust anchors for that signer. Admission control is used to enforce that only users with permissions on the signer can create or modify the corresponding bundle."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1alpha1/watch/clustertrustbundles",
      "method": "watchCertificatesV1Alpha1ClusterTrustBundleList",
      "httpMethod": "get",
      "tag": "certificates_v1alpha1",
      "description": "watch individual changes to a list of ClusterTrustBundle. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1alpha1/watch/clustertrustbundles/{name}",
      "method": "watchCertificatesV1Alpha1ClusterTrustBundle",
      "httpMethod": "get",
      "tag": "certificates_v1alpha1",
      "description": "watch changes to an object of kind ClusterTrustBundle. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/coordination.k8s.io/",
      "method": "getCoordinationApiGroup",
      "httpMethod": "get",
      "tag": "coordination",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/coordination.k8s.io/v1/",
      "method": "getCoordinationV1ApiResources",
      "httpMethod": "get",
      "tag": "coordination_v1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/coordination.k8s.io/v1/leases",
      "method": "listCoordinationV1LeaseForAllNamespaces",
      "httpMethod": "get",
      "tag": "coordination_v1",
      "description": "list or watch objects of kind Lease",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "LeaseList is a list of Lease objects."
        }
      ]
    },
    {
      "url": "/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases",
      "method": "deleteCoordinationV1CollectionNamespacedLease",
      "httpMethod": "delete",
      "tag": "coordination_v1",
      "description": "delete collection of Lease",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases",
      "method": "listCoordinationV1NamespacedLease",
      "httpMethod": "get",
      "tag": "coordination_v1",
      "description": "list or watch objects of kind Lease",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "LeaseList is a list of Lease objects."
        }
      ]
    },
    {
      "url": "/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases",
      "method": "createCoordinationV1NamespacedLease",
      "httpMethod": "post",
      "tag": "coordination_v1",
      "description": "create a Lease",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Lease defines a lease concept."
        },
        {
          "statusCode": "201",
          "description": "Lease defines a lease concept."
        },
        {
          "statusCode": "202",
          "description": "Lease defines a lease concept."
        }
      ]
    },
    {
      "url": "/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}",
      "method": "deleteCoordinationV1NamespacedLease",
      "httpMethod": "delete",
      "tag": "coordination_v1",
      "description": "delete a Lease",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}",
      "method": "readCoordinationV1NamespacedLease",
      "httpMethod": "get",
      "tag": "coordination_v1",
      "description": "read the specified Lease",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Lease defines a lease concept."
        }
      ]
    },
    {
      "url": "/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}",
      "method": "patchCoordinationV1NamespacedLease",
      "httpMethod": "patch",
      "tag": "coordination_v1",
      "description": "partially update the specified Lease",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Lease defines a lease concept."
        },
        {
          "statusCode": "201",
          "description": "Lease defines a lease concept."
        }
      ]
    },
    {
      "url": "/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}",
      "method": "replaceCoordinationV1NamespacedLease",
      "httpMethod": "put",
      "tag": "coordination_v1",
      "description": "replace the specified Lease",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Lease defines a lease concept."
        },
        {
          "statusCode": "201",
          "description": "Lease defines a lease concept."
        }
      ]
    },
    {
      "url": "/apis/coordination.k8s.io/v1/watch/leases",
      "method": "watchCoordinationV1LeaseListForAllNamespaces",
      "httpMethod": "get",
      "tag": "coordination_v1",
      "description": "watch individual changes to a list of Lease. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/coordination.k8s.io/v1/watch/namespaces/{namespace}/leases",
      "method": "watchCoordinationV1NamespacedLeaseList",
      "httpMethod": "get",
      "tag": "coordination_v1",
      "description": "watch individual changes to a list of Lease. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/coordination.k8s.io/v1/watch/namespaces/{namespace}/leases/{name}",
      "method": "watchCoordinationV1NamespacedLease",
      "httpMethod": "get",
      "tag": "coordination_v1",
      "description": "watch changes to an object of kind Lease. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/discovery.k8s.io/",
      "method": "getDiscoveryApiGroup",
      "httpMethod": "get",
      "tag": "discovery",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/discovery.k8s.io/v1/",
      "method": "getDiscoveryV1ApiResources",
      "httpMethod": "get",
      "tag": "discovery_v1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/discovery.k8s.io/v1/endpointslices",
      "method": "listDiscoveryV1EndpointSliceForAllNamespaces",
      "httpMethod": "get",
      "tag": "discovery_v1",
      "description": "list or watch objects of kind EndpointSlice",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "EndpointSliceList represents a list of endpoint slices"
        }
      ]
    },
    {
      "url": "/apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices",
      "method": "deleteDiscoveryV1CollectionNamespacedEndpointSlice",
      "httpMethod": "delete",
      "tag": "discovery_v1",
      "description": "delete collection of EndpointSlice",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices",
      "method": "listDiscoveryV1NamespacedEndpointSlice",
      "httpMethod": "get",
      "tag": "discovery_v1",
      "description": "list or watch objects of kind EndpointSlice",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "EndpointSliceList represents a list of endpoint slices"
        }
      ]
    },
    {
      "url": "/apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices",
      "method": "createDiscoveryV1NamespacedEndpointSlice",
      "httpMethod": "post",
      "tag": "discovery_v1",
      "description": "create an EndpointSlice",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "addressType",
          "schema": "string",
          "required": true,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "endpoints",
          "schema": "array",
          "required": true,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "ports",
          "schema": "array",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "EndpointSlice represents a subset of the endpoints that implement a service. For a given service there may be multiple EndpointSlice objects, selected by labels, which must be joined to produce the full set of endpoints."
        },
        {
          "statusCode": "201",
          "description": "EndpointSlice represents a subset of the endpoints that implement a service. For a given service there may be multiple EndpointSlice objects, selected by labels, which must be joined to produce the full set of endpoints."
        },
        {
          "statusCode": "202",
          "description": "EndpointSlice represents a subset of the endpoints that implement a service. For a given service there may be multiple EndpointSlice objects, selected by labels, which must be joined to produce the full set of endpoints."
        }
      ]
    },
    {
      "url": "/apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices/{name}",
      "method": "deleteDiscoveryV1NamespacedEndpointSlice",
      "httpMethod": "delete",
      "tag": "discovery_v1",
      "description": "delete an EndpointSlice",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices/{name}",
      "method": "readDiscoveryV1NamespacedEndpointSlice",
      "httpMethod": "get",
      "tag": "discovery_v1",
      "description": "read the specified EndpointSlice",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "EndpointSlice represents a subset of the endpoints that implement a service. For a given service there may be multiple EndpointSlice objects, selected by labels, which must be joined to produce the full set of endpoints."
        }
      ]
    },
    {
      "url": "/apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices/{name}",
      "method": "patchDiscoveryV1NamespacedEndpointSlice",
      "httpMethod": "patch",
      "tag": "discovery_v1",
      "description": "partially update the specified EndpointSlice",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "EndpointSlice represents a subset of the endpoints that implement a service. For a given service there may be multiple EndpointSlice objects, selected by labels, which must be joined to produce the full set of endpoints."
        },
        {
          "statusCode": "201",
          "description": "EndpointSlice represents a subset of the endpoints that implement a service. For a given service there may be multiple EndpointSlice objects, selected by labels, which must be joined to produce the full set of endpoints."
        }
      ]
    },
    {
      "url": "/apis/discovery.k8s.io/v1/namespaces/{namespace}/endpointslices/{name}",
      "method": "replaceDiscoveryV1NamespacedEndpointSlice",
      "httpMethod": "put",
      "tag": "discovery_v1",
      "description": "replace the specified EndpointSlice",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "addressType",
          "schema": "string",
          "required": true,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "endpoints",
          "schema": "array",
          "required": true,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "ports",
          "schema": "array",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "EndpointSlice represents a subset of the endpoints that implement a service. For a given service there may be multiple EndpointSlice objects, selected by labels, which must be joined to produce the full set of endpoints."
        },
        {
          "statusCode": "201",
          "description": "EndpointSlice represents a subset of the endpoints that implement a service. For a given service there may be multiple EndpointSlice objects, selected by labels, which must be joined to produce the full set of endpoints."
        }
      ]
    },
    {
      "url": "/apis/discovery.k8s.io/v1/watch/endpointslices",
      "method": "watchDiscoveryV1EndpointSliceListForAllNamespaces",
      "httpMethod": "get",
      "tag": "discovery_v1",
      "description": "watch individual changes to a list of EndpointSlice. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/discovery.k8s.io/v1/watch/namespaces/{namespace}/endpointslices",
      "method": "watchDiscoveryV1NamespacedEndpointSliceList",
      "httpMethod": "get",
      "tag": "discovery_v1",
      "description": "watch individual changes to a list of EndpointSlice. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/discovery.k8s.io/v1/watch/namespaces/{namespace}/endpointslices/{name}",
      "method": "watchDiscoveryV1NamespacedEndpointSlice",
      "httpMethod": "get",
      "tag": "discovery_v1",
      "description": "watch changes to an object of kind EndpointSlice. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/",
      "method": "getEventsApiGroup",
      "httpMethod": "get",
      "tag": "events",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1/",
      "method": "getEventsV1ApiResources",
      "httpMethod": "get",
      "tag": "events_v1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1/events",
      "method": "listEventsV1EventForAllNamespaces",
      "httpMethod": "get",
      "tag": "events_v1",
      "description": "list or watch objects of kind Event",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "EventList is a list of Event objects."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1/namespaces/{namespace}/events",
      "method": "deleteEventsV1CollectionNamespacedEvent",
      "httpMethod": "delete",
      "tag": "events_v1",
      "description": "delete collection of Event",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1/namespaces/{namespace}/events",
      "method": "listEventsV1NamespacedEvent",
      "httpMethod": "get",
      "tag": "events_v1",
      "description": "list or watch objects of kind Event",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "EventList is a list of Event objects."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1/namespaces/{namespace}/events",
      "method": "createEventsV1NamespacedEvent",
      "httpMethod": "post",
      "tag": "events_v1",
      "description": "create an Event",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "action",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "deprecatedCount",
          "schema": "integer",
          "required": false,
          "description": ""
        },
        {
          "name": "deprecatedFirstTimestamp",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "deprecatedLastTimestamp",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "deprecatedSource",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "eventTime",
          "schema": "string",
          "required": true,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "note",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "reason",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "regarding",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "related",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "reportingController",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "reportingInstance",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "series",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "type",
          "schema": "string",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system. Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data."
        },
        {
          "statusCode": "201",
          "description": "Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system. Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data."
        },
        {
          "statusCode": "202",
          "description": "Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system. Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1/namespaces/{namespace}/events/{name}",
      "method": "deleteEventsV1NamespacedEvent",
      "httpMethod": "delete",
      "tag": "events_v1",
      "description": "delete an Event",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1/namespaces/{namespace}/events/{name}",
      "method": "readEventsV1NamespacedEvent",
      "httpMethod": "get",
      "tag": "events_v1",
      "description": "read the specified Event",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system. Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1/namespaces/{namespace}/events/{name}",
      "method": "patchEventsV1NamespacedEvent",
      "httpMethod": "patch",
      "tag": "events_v1",
      "description": "partially update the specified Event",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system. Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data."
        },
        {
          "statusCode": "201",
          "description": "Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system. Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1/namespaces/{namespace}/events/{name}",
      "method": "replaceEventsV1NamespacedEvent",
      "httpMethod": "put",
      "tag": "events_v1",
      "description": "replace the specified Event",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "action",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "deprecatedCount",
          "schema": "integer",
          "required": false,
          "description": ""
        },
        {
          "name": "deprecatedFirstTimestamp",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "deprecatedLastTimestamp",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "deprecatedSource",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "eventTime",
          "schema": "string",
          "required": true,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "note",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "reason",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "regarding",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "related",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "reportingController",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "reportingInstance",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "series",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "type",
          "schema": "string",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system. Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data."
        },
        {
          "statusCode": "201",
          "description": "Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system. Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1/watch/events",
      "method": "watchEventsV1EventListForAllNamespaces",
      "httpMethod": "get",
      "tag": "events_v1",
      "description": "watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1/watch/namespaces/{namespace}/events",
      "method": "watchEventsV1NamespacedEventList",
      "httpMethod": "get",
      "tag": "events_v1",
      "description": "watch individual changes to a list of Event. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1/watch/namespaces/{namespace}/events/{name}",
      "method": "watchEventsV1NamespacedEvent",
      "httpMethod": "get",
      "tag": "events_v1",
      "description": "watch changes to an object of kind Event. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/",
      "method": "getFlowcontrolApiserverApiGroup",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/",
      "method": "getFlowcontrolApiserverV1Beta2ApiResources",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas",
      "method": "deleteFlowcontrolApiserverV1Beta2CollectionFlowSchema",
      "httpMethod": "delete",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "delete collection of FlowSchema",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas",
      "method": "listFlowcontrolApiserverV1Beta2FlowSchema",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "list or watch objects of kind FlowSchema",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "FlowSchemaList is a list of FlowSchema objects."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas",
      "method": "createFlowcontrolApiserverV1Beta2FlowSchema",
      "httpMethod": "post",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "create a FlowSchema",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        },
        {
          "statusCode": "201",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        },
        {
          "statusCode": "202",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}",
      "method": "deleteFlowcontrolApiserverV1Beta2FlowSchema",
      "httpMethod": "delete",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "delete a FlowSchema",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}",
      "method": "readFlowcontrolApiserverV1Beta2FlowSchema",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "read the specified FlowSchema",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}",
      "method": "patchFlowcontrolApiserverV1Beta2FlowSchema",
      "httpMethod": "patch",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "partially update the specified FlowSchema",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        },
        {
          "statusCode": "201",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}",
      "method": "replaceFlowcontrolApiserverV1Beta2FlowSchema",
      "httpMethod": "put",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "replace the specified FlowSchema",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        },
        {
          "statusCode": "201",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}/status",
      "method": "readFlowcontrolApiserverV1Beta2FlowSchemaStatus",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "read status of the specified FlowSchema",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}/status",
      "method": "patchFlowcontrolApiserverV1Beta2FlowSchemaStatus",
      "httpMethod": "patch",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "partially update status of the specified FlowSchema",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        },
        {
          "statusCode": "201",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/{name}/status",
      "method": "replaceFlowcontrolApiserverV1Beta2FlowSchemaStatus",
      "httpMethod": "put",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "replace status of the specified FlowSchema",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        },
        {
          "statusCode": "201",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations",
      "method": "deleteFlowcontrolApiserverV1Beta2CollectionPriorityLevelConfiguration",
      "httpMethod": "delete",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "delete collection of PriorityLevelConfiguration",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations",
      "method": "listFlowcontrolApiserverV1Beta2PriorityLevelConfiguration",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "list or watch objects of kind PriorityLevelConfiguration",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityLevelConfigurationList is a list of PriorityLevelConfiguration objects."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations",
      "method": "createFlowcontrolApiserverV1Beta2PriorityLevelConfiguration",
      "httpMethod": "post",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "create a PriorityLevelConfiguration",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        },
        {
          "statusCode": "201",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        },
        {
          "statusCode": "202",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}",
      "method": "deleteFlowcontrolApiserverV1Beta2PriorityLevelConfiguration",
      "httpMethod": "delete",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "delete a PriorityLevelConfiguration",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}",
      "method": "readFlowcontrolApiserverV1Beta2PriorityLevelConfiguration",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "read the specified PriorityLevelConfiguration",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}",
      "method": "patchFlowcontrolApiserverV1Beta2PriorityLevelConfiguration",
      "httpMethod": "patch",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "partially update the specified PriorityLevelConfiguration",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        },
        {
          "statusCode": "201",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}",
      "method": "replaceFlowcontrolApiserverV1Beta2PriorityLevelConfiguration",
      "httpMethod": "put",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "replace the specified PriorityLevelConfiguration",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        },
        {
          "statusCode": "201",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}/status",
      "method": "readFlowcontrolApiserverV1Beta2PriorityLevelConfigurationStatus",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "read status of the specified PriorityLevelConfiguration",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}/status",
      "method": "patchFlowcontrolApiserverV1Beta2PriorityLevelConfigurationStatus",
      "httpMethod": "patch",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "partially update status of the specified PriorityLevelConfiguration",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        },
        {
          "statusCode": "201",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/{name}/status",
      "method": "replaceFlowcontrolApiserverV1Beta2PriorityLevelConfigurationStatus",
      "httpMethod": "put",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "replace status of the specified PriorityLevelConfiguration",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        },
        {
          "statusCode": "201",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/flowschemas",
      "method": "watchFlowcontrolApiserverV1Beta2FlowSchemaList",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "watch individual changes to a list of FlowSchema. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/flowschemas/{name}",
      "method": "watchFlowcontrolApiserverV1Beta2FlowSchema",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "watch changes to an object of kind FlowSchema. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/prioritylevelconfigurations",
      "method": "watchFlowcontrolApiserverV1Beta2PriorityLevelConfigurationList",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "watch individual changes to a list of PriorityLevelConfiguration. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/prioritylevelconfigurations/{name}",
      "method": "watchFlowcontrolApiserverV1Beta2PriorityLevelConfiguration",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta2",
      "description": "watch changes to an object of kind PriorityLevelConfiguration. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/",
      "method": "getFlowcontrolApiserverV1Beta3ApiResources",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/flowschemas",
      "method": "deleteFlowcontrolApiserverV1Beta3CollectionFlowSchema",
      "httpMethod": "delete",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "delete collection of FlowSchema",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/flowschemas",
      "method": "listFlowcontrolApiserverV1Beta3FlowSchema",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "list or watch objects of kind FlowSchema",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "FlowSchemaList is a list of FlowSchema objects."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/flowschemas",
      "method": "createFlowcontrolApiserverV1Beta3FlowSchema",
      "httpMethod": "post",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "create a FlowSchema",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        },
        {
          "statusCode": "201",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        },
        {
          "statusCode": "202",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/flowschemas/{name}",
      "method": "deleteFlowcontrolApiserverV1Beta3FlowSchema",
      "httpMethod": "delete",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "delete a FlowSchema",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/flowschemas/{name}",
      "method": "readFlowcontrolApiserverV1Beta3FlowSchema",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "read the specified FlowSchema",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/flowschemas/{name}",
      "method": "patchFlowcontrolApiserverV1Beta3FlowSchema",
      "httpMethod": "patch",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "partially update the specified FlowSchema",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        },
        {
          "statusCode": "201",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/flowschemas/{name}",
      "method": "replaceFlowcontrolApiserverV1Beta3FlowSchema",
      "httpMethod": "put",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "replace the specified FlowSchema",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        },
        {
          "statusCode": "201",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/flowschemas/{name}/status",
      "method": "readFlowcontrolApiserverV1Beta3FlowSchemaStatus",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "read status of the specified FlowSchema",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/flowschemas/{name}/status",
      "method": "patchFlowcontrolApiserverV1Beta3FlowSchemaStatus",
      "httpMethod": "patch",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "partially update status of the specified FlowSchema",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        },
        {
          "statusCode": "201",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/flowschemas/{name}/status",
      "method": "replaceFlowcontrolApiserverV1Beta3FlowSchemaStatus",
      "httpMethod": "put",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "replace status of the specified FlowSchema",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        },
        {
          "statusCode": "201",
          "description": "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\"."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/prioritylevelconfigurations",
      "method": "deleteFlowcontrolApiserverV1Beta3CollectionPriorityLevelConfiguration",
      "httpMethod": "delete",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "delete collection of PriorityLevelConfiguration",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/prioritylevelconfigurations",
      "method": "listFlowcontrolApiserverV1Beta3PriorityLevelConfiguration",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "list or watch objects of kind PriorityLevelConfiguration",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityLevelConfigurationList is a list of PriorityLevelConfiguration objects."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/prioritylevelconfigurations",
      "method": "createFlowcontrolApiserverV1Beta3PriorityLevelConfiguration",
      "httpMethod": "post",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "create a PriorityLevelConfiguration",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        },
        {
          "statusCode": "201",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        },
        {
          "statusCode": "202",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/prioritylevelconfigurations/{name}",
      "method": "deleteFlowcontrolApiserverV1Beta3PriorityLevelConfiguration",
      "httpMethod": "delete",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "delete a PriorityLevelConfiguration",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/prioritylevelconfigurations/{name}",
      "method": "readFlowcontrolApiserverV1Beta3PriorityLevelConfiguration",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "read the specified PriorityLevelConfiguration",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/prioritylevelconfigurations/{name}",
      "method": "patchFlowcontrolApiserverV1Beta3PriorityLevelConfiguration",
      "httpMethod": "patch",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "partially update the specified PriorityLevelConfiguration",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        },
        {
          "statusCode": "201",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/prioritylevelconfigurations/{name}",
      "method": "replaceFlowcontrolApiserverV1Beta3PriorityLevelConfiguration",
      "httpMethod": "put",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "replace the specified PriorityLevelConfiguration",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        },
        {
          "statusCode": "201",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/prioritylevelconfigurations/{name}/status",
      "method": "readFlowcontrolApiserverV1Beta3PriorityLevelConfigurationStatus",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "read status of the specified PriorityLevelConfiguration",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/prioritylevelconfigurations/{name}/status",
      "method": "patchFlowcontrolApiserverV1Beta3PriorityLevelConfigurationStatus",
      "httpMethod": "patch",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "partially update status of the specified PriorityLevelConfiguration",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        },
        {
          "statusCode": "201",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/prioritylevelconfigurations/{name}/status",
      "method": "replaceFlowcontrolApiserverV1Beta3PriorityLevelConfigurationStatus",
      "httpMethod": "put",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "replace status of the specified PriorityLevelConfiguration",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        },
        {
          "statusCode": "201",
          "description": "PriorityLevelConfiguration represents the configuration of a priority level."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/watch/flowschemas",
      "method": "watchFlowcontrolApiserverV1Beta3FlowSchemaList",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "watch individual changes to a list of FlowSchema. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/watch/flowschemas/{name}",
      "method": "watchFlowcontrolApiserverV1Beta3FlowSchema",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "watch changes to an object of kind FlowSchema. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/watch/prioritylevelconfigurations",
      "method": "watchFlowcontrolApiserverV1Beta3PriorityLevelConfigurationList",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "watch individual changes to a list of PriorityLevelConfiguration. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/flowcontrol.apiserver.k8s.io/v1beta3/watch/prioritylevelconfigurations/{name}",
      "method": "watchFlowcontrolApiserverV1Beta3PriorityLevelConfiguration",
      "httpMethod": "get",
      "tag": "flowcontrolApiserver_v1beta3",
      "description": "watch changes to an object of kind PriorityLevelConfiguration. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/internal.apiserver.k8s.io/",
      "method": "getInternalApiserverApiGroup",
      "httpMethod": "get",
      "tag": "internalApiserver",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/internal.apiserver.k8s.io/v1alpha1/",
      "method": "getInternalApiserverV1Alpha1ApiResources",
      "httpMethod": "get",
      "tag": "internalApiserver_v1alpha1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/internal.apiserver.k8s.io/v1alpha1/storageversions",
      "method": "deleteInternalApiserverV1Alpha1CollectionStorageVersion",
      "httpMethod": "delete",
      "tag": "internalApiserver_v1alpha1",
      "description": "delete collection of StorageVersion",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/internal.apiserver.k8s.io/v1alpha1/storageversions",
      "method": "listInternalApiserverV1Alpha1StorageVersion",
      "httpMethod": "get",
      "tag": "internalApiserver_v1alpha1",
      "description": "list or watch objects of kind StorageVersion",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "A list of StorageVersions."
        }
      ]
    },
    {
      "url": "/apis/internal.apiserver.k8s.io/v1alpha1/storageversions",
      "method": "createInternalApiserverV1Alpha1StorageVersion",
      "httpMethod": "post",
      "tag": "internalApiserver_v1alpha1",
      "description": "create a StorageVersion",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Storage version of a specific resource."
        },
        {
          "statusCode": "201",
          "description": "Storage version of a specific resource."
        },
        {
          "statusCode": "202",
          "description": "Storage version of a specific resource."
        }
      ]
    },
    {
      "url": "/apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}",
      "method": "deleteInternalApiserverV1Alpha1StorageVersion",
      "httpMethod": "delete",
      "tag": "internalApiserver_v1alpha1",
      "description": "delete a StorageVersion",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}",
      "method": "readInternalApiserverV1Alpha1StorageVersion",
      "httpMethod": "get",
      "tag": "internalApiserver_v1alpha1",
      "description": "read the specified StorageVersion",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Storage version of a specific resource."
        }
      ]
    },
    {
      "url": "/apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}",
      "method": "patchInternalApiserverV1Alpha1StorageVersion",
      "httpMethod": "patch",
      "tag": "internalApiserver_v1alpha1",
      "description": "partially update the specified StorageVersion",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Storage version of a specific resource."
        },
        {
          "statusCode": "201",
          "description": "Storage version of a specific resource."
        }
      ]
    },
    {
      "url": "/apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}",
      "method": "replaceInternalApiserverV1Alpha1StorageVersion",
      "httpMethod": "put",
      "tag": "internalApiserver_v1alpha1",
      "description": "replace the specified StorageVersion",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Storage version of a specific resource."
        },
        {
          "statusCode": "201",
          "description": "Storage version of a specific resource."
        }
      ]
    },
    {
      "url": "/apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}/status",
      "method": "readInternalApiserverV1Alpha1StorageVersionStatus",
      "httpMethod": "get",
      "tag": "internalApiserver_v1alpha1",
      "description": "read status of the specified StorageVersion",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Storage version of a specific resource."
        }
      ]
    },
    {
      "url": "/apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}/status",
      "method": "patchInternalApiserverV1Alpha1StorageVersionStatus",
      "httpMethod": "patch",
      "tag": "internalApiserver_v1alpha1",
      "description": "partially update status of the specified StorageVersion",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Storage version of a specific resource."
        },
        {
          "statusCode": "201",
          "description": "Storage version of a specific resource."
        }
      ]
    },
    {
      "url": "/apis/internal.apiserver.k8s.io/v1alpha1/storageversions/{name}/status",
      "method": "replaceInternalApiserverV1Alpha1StorageVersionStatus",
      "httpMethod": "put",
      "tag": "internalApiserver_v1alpha1",
      "description": "replace status of the specified StorageVersion",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Storage version of a specific resource."
        },
        {
          "statusCode": "201",
          "description": "Storage version of a specific resource."
        }
      ]
    },
    {
      "url": "/apis/internal.apiserver.k8s.io/v1alpha1/watch/storageversions",
      "method": "watchInternalApiserverV1Alpha1StorageVersionList",
      "httpMethod": "get",
      "tag": "internalApiserver_v1alpha1",
      "description": "watch individual changes to a list of StorageVersion. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/internal.apiserver.k8s.io/v1alpha1/watch/storageversions/{name}",
      "method": "watchInternalApiserverV1Alpha1StorageVersion",
      "httpMethod": "get",
      "tag": "internalApiserver_v1alpha1",
      "description": "watch changes to an object of kind StorageVersion. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/",
      "method": "getNetworkingApiGroup",
      "httpMethod": "get",
      "tag": "networking",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/",
      "method": "getNetworkingV1ApiResources",
      "httpMethod": "get",
      "tag": "networking_v1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/ingressclasses",
      "method": "deleteNetworkingV1CollectionIngressClass",
      "httpMethod": "delete",
      "tag": "networking_v1",
      "description": "delete collection of IngressClass",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/ingressclasses",
      "method": "listNetworkingV1IngressClass",
      "httpMethod": "get",
      "tag": "networking_v1",
      "description": "list or watch objects of kind IngressClass",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "IngressClassList is a collection of IngressClasses."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/ingressclasses",
      "method": "createNetworkingV1IngressClass",
      "httpMethod": "post",
      "tag": "networking_v1",
      "description": "create an IngressClass",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "IngressClass represents the class of the Ingress, referenced by the Ingress Spec. The `ingressclass.kubernetes.io/is-default-class` annotation can be used to indicate that an IngressClass should be considered default. When a single IngressClass resource has this annotation set to true, new Ingress resources without a class specified will be assigned this default class."
        },
        {
          "statusCode": "201",
          "description": "IngressClass represents the class of the Ingress, referenced by the Ingress Spec. The `ingressclass.kubernetes.io/is-default-class` annotation can be used to indicate that an IngressClass should be considered default. When a single IngressClass resource has this annotation set to true, new Ingress resources without a class specified will be assigned this default class."
        },
        {
          "statusCode": "202",
          "description": "IngressClass represents the class of the Ingress, referenced by the Ingress Spec. The `ingressclass.kubernetes.io/is-default-class` annotation can be used to indicate that an IngressClass should be considered default. When a single IngressClass resource has this annotation set to true, new Ingress resources without a class specified will be assigned this default class."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/ingressclasses/{name}",
      "method": "deleteNetworkingV1IngressClass",
      "httpMethod": "delete",
      "tag": "networking_v1",
      "description": "delete an IngressClass",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/ingressclasses/{name}",
      "method": "readNetworkingV1IngressClass",
      "httpMethod": "get",
      "tag": "networking_v1",
      "description": "read the specified IngressClass",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "IngressClass represents the class of the Ingress, referenced by the Ingress Spec. The `ingressclass.kubernetes.io/is-default-class` annotation can be used to indicate that an IngressClass should be considered default. When a single IngressClass resource has this annotation set to true, new Ingress resources without a class specified will be assigned this default class."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/ingressclasses/{name}",
      "method": "patchNetworkingV1IngressClass",
      "httpMethod": "patch",
      "tag": "networking_v1",
      "description": "partially update the specified IngressClass",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "IngressClass represents the class of the Ingress, referenced by the Ingress Spec. The `ingressclass.kubernetes.io/is-default-class` annotation can be used to indicate that an IngressClass should be considered default. When a single IngressClass resource has this annotation set to true, new Ingress resources without a class specified will be assigned this default class."
        },
        {
          "statusCode": "201",
          "description": "IngressClass represents the class of the Ingress, referenced by the Ingress Spec. The `ingressclass.kubernetes.io/is-default-class` annotation can be used to indicate that an IngressClass should be considered default. When a single IngressClass resource has this annotation set to true, new Ingress resources without a class specified will be assigned this default class."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/ingressclasses/{name}",
      "method": "replaceNetworkingV1IngressClass",
      "httpMethod": "put",
      "tag": "networking_v1",
      "description": "replace the specified IngressClass",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "IngressClass represents the class of the Ingress, referenced by the Ingress Spec. The `ingressclass.kubernetes.io/is-default-class` annotation can be used to indicate that an IngressClass should be considered default. When a single IngressClass resource has this annotation set to true, new Ingress resources without a class specified will be assigned this default class."
        },
        {
          "statusCode": "201",
          "description": "IngressClass represents the class of the Ingress, referenced by the Ingress Spec. The `ingressclass.kubernetes.io/is-default-class` annotation can be used to indicate that an IngressClass should be considered default. When a single IngressClass resource has this annotation set to true, new Ingress resources without a class specified will be assigned this default class."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/ingresses",
      "method": "listNetworkingV1IngressForAllNamespaces",
      "httpMethod": "get",
      "tag": "networking_v1",
      "description": "list or watch objects of kind Ingress",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "IngressList is a collection of Ingress."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses",
      "method": "deleteNetworkingV1CollectionNamespacedIngress",
      "httpMethod": "delete",
      "tag": "networking_v1",
      "description": "delete collection of Ingress",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses",
      "method": "listNetworkingV1NamespacedIngress",
      "httpMethod": "get",
      "tag": "networking_v1",
      "description": "list or watch objects of kind Ingress",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "IngressList is a collection of Ingress."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses",
      "method": "createNetworkingV1NamespacedIngress",
      "httpMethod": "post",
      "tag": "networking_v1",
      "description": "create an Ingress",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        },
        {
          "statusCode": "201",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        },
        {
          "statusCode": "202",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}",
      "method": "deleteNetworkingV1NamespacedIngress",
      "httpMethod": "delete",
      "tag": "networking_v1",
      "description": "delete an Ingress",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}",
      "method": "readNetworkingV1NamespacedIngress",
      "httpMethod": "get",
      "tag": "networking_v1",
      "description": "read the specified Ingress",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}",
      "method": "patchNetworkingV1NamespacedIngress",
      "httpMethod": "patch",
      "tag": "networking_v1",
      "description": "partially update the specified Ingress",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        },
        {
          "statusCode": "201",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}",
      "method": "replaceNetworkingV1NamespacedIngress",
      "httpMethod": "put",
      "tag": "networking_v1",
      "description": "replace the specified Ingress",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        },
        {
          "statusCode": "201",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}/status",
      "method": "readNetworkingV1NamespacedIngressStatus",
      "httpMethod": "get",
      "tag": "networking_v1",
      "description": "read status of the specified Ingress",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}/status",
      "method": "patchNetworkingV1NamespacedIngressStatus",
      "httpMethod": "patch",
      "tag": "networking_v1",
      "description": "partially update status of the specified Ingress",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        },
        {
          "statusCode": "201",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/{name}/status",
      "method": "replaceNetworkingV1NamespacedIngressStatus",
      "httpMethod": "put",
      "tag": "networking_v1",
      "description": "replace status of the specified Ingress",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        },
        {
          "statusCode": "201",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies",
      "method": "deleteNetworkingV1CollectionNamespacedNetworkPolicy",
      "httpMethod": "delete",
      "tag": "networking_v1",
      "description": "delete collection of NetworkPolicy",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies",
      "method": "listNetworkingV1NamespacedNetworkPolicy",
      "httpMethod": "get",
      "tag": "networking_v1",
      "description": "list or watch objects of kind NetworkPolicy",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "NetworkPolicyList is a list of NetworkPolicy objects."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies",
      "method": "createNetworkingV1NamespacedNetworkPolicy",
      "httpMethod": "post",
      "tag": "networking_v1",
      "description": "create a NetworkPolicy",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
        },
        {
          "statusCode": "201",
          "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
        },
        {
          "statusCode": "202",
          "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}",
      "method": "deleteNetworkingV1NamespacedNetworkPolicy",
      "httpMethod": "delete",
      "tag": "networking_v1",
      "description": "delete a NetworkPolicy",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}",
      "method": "readNetworkingV1NamespacedNetworkPolicy",
      "httpMethod": "get",
      "tag": "networking_v1",
      "description": "read the specified NetworkPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}",
      "method": "patchNetworkingV1NamespacedNetworkPolicy",
      "httpMethod": "patch",
      "tag": "networking_v1",
      "description": "partially update the specified NetworkPolicy",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
        },
        {
          "statusCode": "201",
          "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}",
      "method": "replaceNetworkingV1NamespacedNetworkPolicy",
      "httpMethod": "put",
      "tag": "networking_v1",
      "description": "replace the specified NetworkPolicy",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
        },
        {
          "statusCode": "201",
          "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}/status",
      "method": "readNetworkingV1NamespacedNetworkPolicyStatus",
      "httpMethod": "get",
      "tag": "networking_v1",
      "description": "read status of the specified NetworkPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}/status",
      "method": "patchNetworkingV1NamespacedNetworkPolicyStatus",
      "httpMethod": "patch",
      "tag": "networking_v1",
      "description": "partially update status of the specified NetworkPolicy",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
        },
        {
          "statusCode": "201",
          "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}/status",
      "method": "replaceNetworkingV1NamespacedNetworkPolicyStatus",
      "httpMethod": "put",
      "tag": "networking_v1",
      "description": "replace status of the specified NetworkPolicy",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
        },
        {
          "statusCode": "201",
          "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/networkpolicies",
      "method": "listNetworkingV1NetworkPolicyForAllNamespaces",
      "httpMethod": "get",
      "tag": "networking_v1",
      "description": "list or watch objects of kind NetworkPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "NetworkPolicyList is a list of NetworkPolicy objects."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/watch/ingressclasses",
      "method": "watchNetworkingV1IngressClassList",
      "httpMethod": "get",
      "tag": "networking_v1",
      "description": "watch individual changes to a list of IngressClass. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/watch/ingressclasses/{name}",
      "method": "watchNetworkingV1IngressClass",
      "httpMethod": "get",
      "tag": "networking_v1",
      "description": "watch changes to an object of kind IngressClass. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/watch/ingresses",
      "method": "watchNetworkingV1IngressListForAllNamespaces",
      "httpMethod": "get",
      "tag": "networking_v1",
      "description": "watch individual changes to a list of Ingress. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/watch/namespaces/{namespace}/ingresses",
      "method": "watchNetworkingV1NamespacedIngressList",
      "httpMethod": "get",
      "tag": "networking_v1",
      "description": "watch individual changes to a list of Ingress. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/watch/namespaces/{namespace}/ingresses/{name}",
      "method": "watchNetworkingV1NamespacedIngress",
      "httpMethod": "get",
      "tag": "networking_v1",
      "description": "watch changes to an object of kind Ingress. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/watch/namespaces/{namespace}/networkpolicies",
      "method": "watchNetworkingV1NamespacedNetworkPolicyList",
      "httpMethod": "get",
      "tag": "networking_v1",
      "description": "watch individual changes to a list of NetworkPolicy. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/watch/namespaces/{namespace}/networkpolicies/{name}",
      "method": "watchNetworkingV1NamespacedNetworkPolicy",
      "httpMethod": "get",
      "tag": "networking_v1",
      "description": "watch changes to an object of kind NetworkPolicy. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/watch/networkpolicies",
      "method": "watchNetworkingV1NetworkPolicyListForAllNamespaces",
      "httpMethod": "get",
      "tag": "networking_v1",
      "description": "watch individual changes to a list of NetworkPolicy. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1alpha1/",
      "method": "getNetworkingV1Alpha1ApiResources",
      "httpMethod": "get",
      "tag": "networking_v1alpha1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1alpha1/clustercidrs",
      "method": "deleteNetworkingV1Alpha1CollectionClusterCidr",
      "httpMethod": "delete",
      "tag": "networking_v1alpha1",
      "description": "delete collection of ClusterCIDR",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1alpha1/clustercidrs",
      "method": "listNetworkingV1Alpha1ClusterCidr",
      "httpMethod": "get",
      "tag": "networking_v1alpha1",
      "description": "list or watch objects of kind ClusterCIDR",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterCIDRList contains a list of ClusterCIDR."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1alpha1/clustercidrs",
      "method": "createNetworkingV1Alpha1ClusterCidr",
      "httpMethod": "post",
      "tag": "networking_v1alpha1",
      "description": "create a ClusterCIDR",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterCIDR represents a single configuration for per-Node Pod CIDR allocations when the MultiCIDRRangeAllocator is enabled (see the config for kube-controller-manager).  A cluster may have any number of ClusterCIDR resources, all of which will be considered when allocating a CIDR for a Node.  A ClusterCIDR is eligible to be used for a given Node when the node selector matches the node in question and has free CIDRs to allocate.  In case of multiple matching ClusterCIDR resources, the allocator will attempt to break ties using internal heuristics, but any ClusterCIDR whose node selector matches the Node may be used."
        },
        {
          "statusCode": "201",
          "description": "ClusterCIDR represents a single configuration for per-Node Pod CIDR allocations when the MultiCIDRRangeAllocator is enabled (see the config for kube-controller-manager).  A cluster may have any number of ClusterCIDR resources, all of which will be considered when allocating a CIDR for a Node.  A ClusterCIDR is eligible to be used for a given Node when the node selector matches the node in question and has free CIDRs to allocate.  In case of multiple matching ClusterCIDR resources, the allocator will attempt to break ties using internal heuristics, but any ClusterCIDR whose node selector matches the Node may be used."
        },
        {
          "statusCode": "202",
          "description": "ClusterCIDR represents a single configuration for per-Node Pod CIDR allocations when the MultiCIDRRangeAllocator is enabled (see the config for kube-controller-manager).  A cluster may have any number of ClusterCIDR resources, all of which will be considered when allocating a CIDR for a Node.  A ClusterCIDR is eligible to be used for a given Node when the node selector matches the node in question and has free CIDRs to allocate.  In case of multiple matching ClusterCIDR resources, the allocator will attempt to break ties using internal heuristics, but any ClusterCIDR whose node selector matches the Node may be used."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1alpha1/clustercidrs/{name}",
      "method": "deleteNetworkingV1Alpha1ClusterCidr",
      "httpMethod": "delete",
      "tag": "networking_v1alpha1",
      "description": "delete a ClusterCIDR",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1alpha1/clustercidrs/{name}",
      "method": "readNetworkingV1Alpha1ClusterCidr",
      "httpMethod": "get",
      "tag": "networking_v1alpha1",
      "description": "read the specified ClusterCIDR",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterCIDR represents a single configuration for per-Node Pod CIDR allocations when the MultiCIDRRangeAllocator is enabled (see the config for kube-controller-manager).  A cluster may have any number of ClusterCIDR resources, all of which will be considered when allocating a CIDR for a Node.  A ClusterCIDR is eligible to be used for a given Node when the node selector matches the node in question and has free CIDRs to allocate.  In case of multiple matching ClusterCIDR resources, the allocator will attempt to break ties using internal heuristics, but any ClusterCIDR whose node selector matches the Node may be used."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1alpha1/clustercidrs/{name}",
      "method": "patchNetworkingV1Alpha1ClusterCidr",
      "httpMethod": "patch",
      "tag": "networking_v1alpha1",
      "description": "partially update the specified ClusterCIDR",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterCIDR represents a single configuration for per-Node Pod CIDR allocations when the MultiCIDRRangeAllocator is enabled (see the config for kube-controller-manager).  A cluster may have any number of ClusterCIDR resources, all of which will be considered when allocating a CIDR for a Node.  A ClusterCIDR is eligible to be used for a given Node when the node selector matches the node in question and has free CIDRs to allocate.  In case of multiple matching ClusterCIDR resources, the allocator will attempt to break ties using internal heuristics, but any ClusterCIDR whose node selector matches the Node may be used."
        },
        {
          "statusCode": "201",
          "description": "ClusterCIDR represents a single configuration for per-Node Pod CIDR allocations when the MultiCIDRRangeAllocator is enabled (see the config for kube-controller-manager).  A cluster may have any number of ClusterCIDR resources, all of which will be considered when allocating a CIDR for a Node.  A ClusterCIDR is eligible to be used for a given Node when the node selector matches the node in question and has free CIDRs to allocate.  In case of multiple matching ClusterCIDR resources, the allocator will attempt to break ties using internal heuristics, but any ClusterCIDR whose node selector matches the Node may be used."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1alpha1/clustercidrs/{name}",
      "method": "replaceNetworkingV1Alpha1ClusterCidr",
      "httpMethod": "put",
      "tag": "networking_v1alpha1",
      "description": "replace the specified ClusterCIDR",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterCIDR represents a single configuration for per-Node Pod CIDR allocations when the MultiCIDRRangeAllocator is enabled (see the config for kube-controller-manager).  A cluster may have any number of ClusterCIDR resources, all of which will be considered when allocating a CIDR for a Node.  A ClusterCIDR is eligible to be used for a given Node when the node selector matches the node in question and has free CIDRs to allocate.  In case of multiple matching ClusterCIDR resources, the allocator will attempt to break ties using internal heuristics, but any ClusterCIDR whose node selector matches the Node may be used."
        },
        {
          "statusCode": "201",
          "description": "ClusterCIDR represents a single configuration for per-Node Pod CIDR allocations when the MultiCIDRRangeAllocator is enabled (see the config for kube-controller-manager).  A cluster may have any number of ClusterCIDR resources, all of which will be considered when allocating a CIDR for a Node.  A ClusterCIDR is eligible to be used for a given Node when the node selector matches the node in question and has free CIDRs to allocate.  In case of multiple matching ClusterCIDR resources, the allocator will attempt to break ties using internal heuristics, but any ClusterCIDR whose node selector matches the Node may be used."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1alpha1/ipaddresses",
      "method": "deleteNetworkingV1Alpha1CollectionIpAddress",
      "httpMethod": "delete",
      "tag": "networking_v1alpha1",
      "description": "delete collection of IPAddress",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1alpha1/ipaddresses",
      "method": "listNetworkingV1Alpha1IpAddress",
      "httpMethod": "get",
      "tag": "networking_v1alpha1",
      "description": "list or watch objects of kind IPAddress",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "IPAddressList contains a list of IPAddress."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1alpha1/ipaddresses",
      "method": "createNetworkingV1Alpha1IpAddress",
      "httpMethod": "post",
      "tag": "networking_v1alpha1",
      "description": "create an IPAddress",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "IPAddress represents a single IP of a single IP Family. The object is designed to be used by APIs that operate on IP addresses. The object is used by the Service core API for allocation of IP addresses. An IP address can be represented in different formats, to guarantee the uniqueness of the IP, the name of the object is the IP address in canonical format, four decimal digits separated by dots suppressing leading zeros for IPv4 and the representation defined by RFC 5952 for IPv6. Valid: 192.168.1.5 or 2001:db8::1 or 2001:db8:aaaa:bbbb:cccc:dddd:eeee:1 Invalid: 10.01.2.3 or 2001:db8:0:0:0::1"
        },
        {
          "statusCode": "201",
          "description": "IPAddress represents a single IP of a single IP Family. The object is designed to be used by APIs that operate on IP addresses. The object is used by the Service core API for allocation of IP addresses. An IP address can be represented in different formats, to guarantee the uniqueness of the IP, the name of the object is the IP address in canonical format, four decimal digits separated by dots suppressing leading zeros for IPv4 and the representation defined by RFC 5952 for IPv6. Valid: 192.168.1.5 or 2001:db8::1 or 2001:db8:aaaa:bbbb:cccc:dddd:eeee:1 Invalid: 10.01.2.3 or 2001:db8:0:0:0::1"
        },
        {
          "statusCode": "202",
          "description": "IPAddress represents a single IP of a single IP Family. The object is designed to be used by APIs that operate on IP addresses. The object is used by the Service core API for allocation of IP addresses. An IP address can be represented in different formats, to guarantee the uniqueness of the IP, the name of the object is the IP address in canonical format, four decimal digits separated by dots suppressing leading zeros for IPv4 and the representation defined by RFC 5952 for IPv6. Valid: 192.168.1.5 or 2001:db8::1 or 2001:db8:aaaa:bbbb:cccc:dddd:eeee:1 Invalid: 10.01.2.3 or 2001:db8:0:0:0::1"
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1alpha1/ipaddresses/{name}",
      "method": "deleteNetworkingV1Alpha1IpAddress",
      "httpMethod": "delete",
      "tag": "networking_v1alpha1",
      "description": "delete an IPAddress",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1alpha1/ipaddresses/{name}",
      "method": "readNetworkingV1Alpha1IpAddress",
      "httpMethod": "get",
      "tag": "networking_v1alpha1",
      "description": "read the specified IPAddress",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "IPAddress represents a single IP of a single IP Family. The object is designed to be used by APIs that operate on IP addresses. The object is used by the Service core API for allocation of IP addresses. An IP address can be represented in different formats, to guarantee the uniqueness of the IP, the name of the object is the IP address in canonical format, four decimal digits separated by dots suppressing leading zeros for IPv4 and the representation defined by RFC 5952 for IPv6. Valid: 192.168.1.5 or 2001:db8::1 or 2001:db8:aaaa:bbbb:cccc:dddd:eeee:1 Invalid: 10.01.2.3 or 2001:db8:0:0:0::1"
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1alpha1/ipaddresses/{name}",
      "method": "patchNetworkingV1Alpha1IpAddress",
      "httpMethod": "patch",
      "tag": "networking_v1alpha1",
      "description": "partially update the specified IPAddress",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "IPAddress represents a single IP of a single IP Family. The object is designed to be used by APIs that operate on IP addresses. The object is used by the Service core API for allocation of IP addresses. An IP address can be represented in different formats, to guarantee the uniqueness of the IP, the name of the object is the IP address in canonical format, four decimal digits separated by dots suppressing leading zeros for IPv4 and the representation defined by RFC 5952 for IPv6. Valid: 192.168.1.5 or 2001:db8::1 or 2001:db8:aaaa:bbbb:cccc:dddd:eeee:1 Invalid: 10.01.2.3 or 2001:db8:0:0:0::1"
        },
        {
          "statusCode": "201",
          "description": "IPAddress represents a single IP of a single IP Family. The object is designed to be used by APIs that operate on IP addresses. The object is used by the Service core API for allocation of IP addresses. An IP address can be represented in different formats, to guarantee the uniqueness of the IP, the name of the object is the IP address in canonical format, four decimal digits separated by dots suppressing leading zeros for IPv4 and the representation defined by RFC 5952 for IPv6. Valid: 192.168.1.5 or 2001:db8::1 or 2001:db8:aaaa:bbbb:cccc:dddd:eeee:1 Invalid: 10.01.2.3 or 2001:db8:0:0:0::1"
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1alpha1/ipaddresses/{name}",
      "method": "replaceNetworkingV1Alpha1IpAddress",
      "httpMethod": "put",
      "tag": "networking_v1alpha1",
      "description": "replace the specified IPAddress",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "IPAddress represents a single IP of a single IP Family. The object is designed to be used by APIs that operate on IP addresses. The object is used by the Service core API for allocation of IP addresses. An IP address can be represented in different formats, to guarantee the uniqueness of the IP, the name of the object is the IP address in canonical format, four decimal digits separated by dots suppressing leading zeros for IPv4 and the representation defined by RFC 5952 for IPv6. Valid: 192.168.1.5 or 2001:db8::1 or 2001:db8:aaaa:bbbb:cccc:dddd:eeee:1 Invalid: 10.01.2.3 or 2001:db8:0:0:0::1"
        },
        {
          "statusCode": "201",
          "description": "IPAddress represents a single IP of a single IP Family. The object is designed to be used by APIs that operate on IP addresses. The object is used by the Service core API for allocation of IP addresses. An IP address can be represented in different formats, to guarantee the uniqueness of the IP, the name of the object is the IP address in canonical format, four decimal digits separated by dots suppressing leading zeros for IPv4 and the representation defined by RFC 5952 for IPv6. Valid: 192.168.1.5 or 2001:db8::1 or 2001:db8:aaaa:bbbb:cccc:dddd:eeee:1 Invalid: 10.01.2.3 or 2001:db8:0:0:0::1"
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1alpha1/watch/clustercidrs",
      "method": "watchNetworkingV1Alpha1ClusterCidrList",
      "httpMethod": "get",
      "tag": "networking_v1alpha1",
      "description": "watch individual changes to a list of ClusterCIDR. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1alpha1/watch/clustercidrs/{name}",
      "method": "watchNetworkingV1Alpha1ClusterCidr",
      "httpMethod": "get",
      "tag": "networking_v1alpha1",
      "description": "watch changes to an object of kind ClusterCIDR. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1alpha1/watch/ipaddresses",
      "method": "watchNetworkingV1Alpha1IpAddressList",
      "httpMethod": "get",
      "tag": "networking_v1alpha1",
      "description": "watch individual changes to a list of IPAddress. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1alpha1/watch/ipaddresses/{name}",
      "method": "watchNetworkingV1Alpha1IpAddress",
      "httpMethod": "get",
      "tag": "networking_v1alpha1",
      "description": "watch changes to an object of kind IPAddress. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/node.k8s.io/",
      "method": "getNodeApiGroup",
      "httpMethod": "get",
      "tag": "node",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/node.k8s.io/v1/",
      "method": "getNodeV1ApiResources",
      "httpMethod": "get",
      "tag": "node_v1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/node.k8s.io/v1/runtimeclasses",
      "method": "deleteNodeV1CollectionRuntimeClass",
      "httpMethod": "delete",
      "tag": "node_v1",
      "description": "delete collection of RuntimeClass",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/node.k8s.io/v1/runtimeclasses",
      "method": "listNodeV1RuntimeClass",
      "httpMethod": "get",
      "tag": "node_v1",
      "description": "list or watch objects of kind RuntimeClass",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RuntimeClassList is a list of RuntimeClass objects."
        }
      ]
    },
    {
      "url": "/apis/node.k8s.io/v1/runtimeclasses",
      "method": "createNodeV1RuntimeClass",
      "httpMethod": "post",
      "tag": "node_v1",
      "description": "create a RuntimeClass",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "handler",
          "schema": "string",
          "required": true,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "overhead",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "scheduling",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass is used to determine which container runtime is used to run all containers in a pod. RuntimeClasses are manually defined by a user or cluster provisioner, and referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName reference before running the pod.  For more details, see https://kubernetes.io/docs/concepts/containers/runtime-class/"
        },
        {
          "statusCode": "201",
          "description": "RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass is used to determine which container runtime is used to run all containers in a pod. RuntimeClasses are manually defined by a user or cluster provisioner, and referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName reference before running the pod.  For more details, see https://kubernetes.io/docs/concepts/containers/runtime-class/"
        },
        {
          "statusCode": "202",
          "description": "RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass is used to determine which container runtime is used to run all containers in a pod. RuntimeClasses are manually defined by a user or cluster provisioner, and referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName reference before running the pod.  For more details, see https://kubernetes.io/docs/concepts/containers/runtime-class/"
        }
      ]
    },
    {
      "url": "/apis/node.k8s.io/v1/runtimeclasses/{name}",
      "method": "deleteNodeV1RuntimeClass",
      "httpMethod": "delete",
      "tag": "node_v1",
      "description": "delete a RuntimeClass",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/node.k8s.io/v1/runtimeclasses/{name}",
      "method": "readNodeV1RuntimeClass",
      "httpMethod": "get",
      "tag": "node_v1",
      "description": "read the specified RuntimeClass",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass is used to determine which container runtime is used to run all containers in a pod. RuntimeClasses are manually defined by a user or cluster provisioner, and referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName reference before running the pod.  For more details, see https://kubernetes.io/docs/concepts/containers/runtime-class/"
        }
      ]
    },
    {
      "url": "/apis/node.k8s.io/v1/runtimeclasses/{name}",
      "method": "patchNodeV1RuntimeClass",
      "httpMethod": "patch",
      "tag": "node_v1",
      "description": "partially update the specified RuntimeClass",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass is used to determine which container runtime is used to run all containers in a pod. RuntimeClasses are manually defined by a user or cluster provisioner, and referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName reference before running the pod.  For more details, see https://kubernetes.io/docs/concepts/containers/runtime-class/"
        },
        {
          "statusCode": "201",
          "description": "RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass is used to determine which container runtime is used to run all containers in a pod. RuntimeClasses are manually defined by a user or cluster provisioner, and referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName reference before running the pod.  For more details, see https://kubernetes.io/docs/concepts/containers/runtime-class/"
        }
      ]
    },
    {
      "url": "/apis/node.k8s.io/v1/runtimeclasses/{name}",
      "method": "replaceNodeV1RuntimeClass",
      "httpMethod": "put",
      "tag": "node_v1",
      "description": "replace the specified RuntimeClass",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "handler",
          "schema": "string",
          "required": true,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "overhead",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "scheduling",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass is used to determine which container runtime is used to run all containers in a pod. RuntimeClasses are manually defined by a user or cluster provisioner, and referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName reference before running the pod.  For more details, see https://kubernetes.io/docs/concepts/containers/runtime-class/"
        },
        {
          "statusCode": "201",
          "description": "RuntimeClass defines a class of container runtime supported in the cluster. The RuntimeClass is used to determine which container runtime is used to run all containers in a pod. RuntimeClasses are manually defined by a user or cluster provisioner, and referenced in the PodSpec. The Kubelet is responsible for resolving the RuntimeClassName reference before running the pod.  For more details, see https://kubernetes.io/docs/concepts/containers/runtime-class/"
        }
      ]
    },
    {
      "url": "/apis/node.k8s.io/v1/watch/runtimeclasses",
      "method": "watchNodeV1RuntimeClassList",
      "httpMethod": "get",
      "tag": "node_v1",
      "description": "watch individual changes to a list of RuntimeClass. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/node.k8s.io/v1/watch/runtimeclasses/{name}",
      "method": "watchNodeV1RuntimeClass",
      "httpMethod": "get",
      "tag": "node_v1",
      "description": "watch changes to an object of kind RuntimeClass. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/policy/",
      "method": "getPolicyApiGroup",
      "httpMethod": "get",
      "tag": "policy",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/policy/v1/",
      "method": "getPolicyV1ApiResources",
      "httpMethod": "get",
      "tag": "policy_v1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets",
      "method": "deletePolicyV1CollectionNamespacedPodDisruptionBudget",
      "httpMethod": "delete",
      "tag": "policy_v1",
      "description": "delete collection of PodDisruptionBudget",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets",
      "method": "listPolicyV1NamespacedPodDisruptionBudget",
      "httpMethod": "get",
      "tag": "policy_v1",
      "description": "list or watch objects of kind PodDisruptionBudget",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodDisruptionBudgetList is a collection of PodDisruptionBudgets."
        }
      ]
    },
    {
      "url": "/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets",
      "method": "createPolicyV1NamespacedPodDisruptionBudget",
      "httpMethod": "post",
      "tag": "policy_v1",
      "description": "create a PodDisruptionBudget",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        },
        {
          "statusCode": "201",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        },
        {
          "statusCode": "202",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        }
      ]
    },
    {
      "url": "/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}",
      "method": "deletePolicyV1NamespacedPodDisruptionBudget",
      "httpMethod": "delete",
      "tag": "policy_v1",
      "description": "delete a PodDisruptionBudget",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}",
      "method": "readPolicyV1NamespacedPodDisruptionBudget",
      "httpMethod": "get",
      "tag": "policy_v1",
      "description": "read the specified PodDisruptionBudget",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        }
      ]
    },
    {
      "url": "/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}",
      "method": "patchPolicyV1NamespacedPodDisruptionBudget",
      "httpMethod": "patch",
      "tag": "policy_v1",
      "description": "partially update the specified PodDisruptionBudget",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        },
        {
          "statusCode": "201",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        }
      ]
    },
    {
      "url": "/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}",
      "method": "replacePolicyV1NamespacedPodDisruptionBudget",
      "httpMethod": "put",
      "tag": "policy_v1",
      "description": "replace the specified PodDisruptionBudget",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        },
        {
          "statusCode": "201",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        }
      ]
    },
    {
      "url": "/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}/status",
      "method": "readPolicyV1NamespacedPodDisruptionBudgetStatus",
      "httpMethod": "get",
      "tag": "policy_v1",
      "description": "read status of the specified PodDisruptionBudget",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        }
      ]
    },
    {
      "url": "/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}/status",
      "method": "patchPolicyV1NamespacedPodDisruptionBudgetStatus",
      "httpMethod": "patch",
      "tag": "policy_v1",
      "description": "partially update status of the specified PodDisruptionBudget",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        },
        {
          "statusCode": "201",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        }
      ]
    },
    {
      "url": "/apis/policy/v1/namespaces/{namespace}/poddisruptionbudgets/{name}/status",
      "method": "replacePolicyV1NamespacedPodDisruptionBudgetStatus",
      "httpMethod": "put",
      "tag": "policy_v1",
      "description": "replace status of the specified PodDisruptionBudget",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        },
        {
          "statusCode": "201",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        }
      ]
    },
    {
      "url": "/apis/policy/v1/poddisruptionbudgets",
      "method": "listPolicyV1PodDisruptionBudgetForAllNamespaces",
      "httpMethod": "get",
      "tag": "policy_v1",
      "description": "list or watch objects of kind PodDisruptionBudget",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodDisruptionBudgetList is a collection of PodDisruptionBudgets."
        }
      ]
    },
    {
      "url": "/apis/policy/v1/watch/namespaces/{namespace}/poddisruptionbudgets",
      "method": "watchPolicyV1NamespacedPodDisruptionBudgetList",
      "httpMethod": "get",
      "tag": "policy_v1",
      "description": "watch individual changes to a list of PodDisruptionBudget. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/policy/v1/watch/namespaces/{namespace}/poddisruptionbudgets/{name}",
      "method": "watchPolicyV1NamespacedPodDisruptionBudget",
      "httpMethod": "get",
      "tag": "policy_v1",
      "description": "watch changes to an object of kind PodDisruptionBudget. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/policy/v1/watch/poddisruptionbudgets",
      "method": "watchPolicyV1PodDisruptionBudgetListForAllNamespaces",
      "httpMethod": "get",
      "tag": "policy_v1",
      "description": "watch individual changes to a list of PodDisruptionBudget. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/",
      "method": "getRbacAuthorizationApiGroup",
      "httpMethod": "get",
      "tag": "rbacAuthorization",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/",
      "method": "getRbacAuthorizationV1ApiResources",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings",
      "method": "deleteRbacAuthorizationV1CollectionClusterRoleBinding",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1",
      "description": "delete collection of ClusterRoleBinding",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings",
      "method": "listRbacAuthorizationV1ClusterRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "list or watch objects of kind ClusterRoleBinding",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleBindingList is a collection of ClusterRoleBindings"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings",
      "method": "createRbacAuthorizationV1ClusterRoleBinding",
      "httpMethod": "post",
      "tag": "rbacAuthorization_v1",
      "description": "create a ClusterRoleBinding",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "roleRef",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "subjects",
          "schema": "array",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        },
        {
          "statusCode": "201",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        },
        {
          "statusCode": "202",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}",
      "method": "deleteRbacAuthorizationV1ClusterRoleBinding",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1",
      "description": "delete a ClusterRoleBinding",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}",
      "method": "readRbacAuthorizationV1ClusterRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "read the specified ClusterRoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}",
      "method": "patchRbacAuthorizationV1ClusterRoleBinding",
      "httpMethod": "patch",
      "tag": "rbacAuthorization_v1",
      "description": "partially update the specified ClusterRoleBinding",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        },
        {
          "statusCode": "201",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}",
      "method": "replaceRbacAuthorizationV1ClusterRoleBinding",
      "httpMethod": "put",
      "tag": "rbacAuthorization_v1",
      "description": "replace the specified ClusterRoleBinding",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "roleRef",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "subjects",
          "schema": "array",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        },
        {
          "statusCode": "201",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterroles",
      "method": "deleteRbacAuthorizationV1CollectionClusterRole",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1",
      "description": "delete collection of ClusterRole",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterroles",
      "method": "listRbacAuthorizationV1ClusterRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "list or watch objects of kind ClusterRole",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleList is a collection of ClusterRoles"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterroles",
      "method": "createRbacAuthorizationV1ClusterRole",
      "httpMethod": "post",
      "tag": "rbacAuthorization_v1",
      "description": "create a ClusterRole",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "aggregationRule",
          "schema": "object",
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "rules",
          "schema": "array",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        },
        {
          "statusCode": "201",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        },
        {
          "statusCode": "202",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}",
      "method": "deleteRbacAuthorizationV1ClusterRole",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1",
      "description": "delete a ClusterRole",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}",
      "method": "readRbacAuthorizationV1ClusterRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "read the specified ClusterRole",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}",
      "method": "patchRbacAuthorizationV1ClusterRole",
      "httpMethod": "patch",
      "tag": "rbacAuthorization_v1",
      "description": "partially update the specified ClusterRole",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        },
        {
          "statusCode": "201",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}",
      "method": "replaceRbacAuthorizationV1ClusterRole",
      "httpMethod": "put",
      "tag": "rbacAuthorization_v1",
      "description": "replace the specified ClusterRole",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "aggregationRule",
          "schema": "object",
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "rules",
          "schema": "array",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        },
        {
          "statusCode": "201",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings",
      "method": "deleteRbacAuthorizationV1CollectionNamespacedRoleBinding",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1",
      "description": "delete collection of RoleBinding",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings",
      "method": "listRbacAuthorizationV1NamespacedRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "list or watch objects of kind RoleBinding",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBindingList is a collection of RoleBindings"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings",
      "method": "createRbacAuthorizationV1NamespacedRoleBinding",
      "httpMethod": "post",
      "tag": "rbacAuthorization_v1",
      "description": "create a RoleBinding",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "roleRef",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "subjects",
          "schema": "array",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        },
        {
          "statusCode": "201",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        },
        {
          "statusCode": "202",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}",
      "method": "deleteRbacAuthorizationV1NamespacedRoleBinding",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1",
      "description": "delete a RoleBinding",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}",
      "method": "readRbacAuthorizationV1NamespacedRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "read the specified RoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}",
      "method": "patchRbacAuthorizationV1NamespacedRoleBinding",
      "httpMethod": "patch",
      "tag": "rbacAuthorization_v1",
      "description": "partially update the specified RoleBinding",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        },
        {
          "statusCode": "201",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}",
      "method": "replaceRbacAuthorizationV1NamespacedRoleBinding",
      "httpMethod": "put",
      "tag": "rbacAuthorization_v1",
      "description": "replace the specified RoleBinding",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "roleRef",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "subjects",
          "schema": "array",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        },
        {
          "statusCode": "201",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles",
      "method": "deleteRbacAuthorizationV1CollectionNamespacedRole",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1",
      "description": "delete collection of Role",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles",
      "method": "listRbacAuthorizationV1NamespacedRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "list or watch objects of kind Role",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleList is a collection of Roles"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles",
      "method": "createRbacAuthorizationV1NamespacedRole",
      "httpMethod": "post",
      "tag": "rbacAuthorization_v1",
      "description": "create a Role",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "rules",
          "schema": "array",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        },
        {
          "statusCode": "201",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        },
        {
          "statusCode": "202",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}",
      "method": "deleteRbacAuthorizationV1NamespacedRole",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1",
      "description": "delete a Role",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}",
      "method": "readRbacAuthorizationV1NamespacedRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "read the specified Role",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}",
      "method": "patchRbacAuthorizationV1NamespacedRole",
      "httpMethod": "patch",
      "tag": "rbacAuthorization_v1",
      "description": "partially update the specified Role",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        },
        {
          "statusCode": "201",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}",
      "method": "replaceRbacAuthorizationV1NamespacedRole",
      "httpMethod": "put",
      "tag": "rbacAuthorization_v1",
      "description": "replace the specified Role",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "description": ""
        },
        {
          "name": "rules",
          "schema": "array",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        },
        {
          "statusCode": "201",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/rolebindings",
      "method": "listRbacAuthorizationV1RoleBindingForAllNamespaces",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "list or watch objects of kind RoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBindingList is a collection of RoleBindings"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/roles",
      "method": "listRbacAuthorizationV1RoleForAllNamespaces",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "list or watch objects of kind Role",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleList is a collection of Roles"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/watch/clusterrolebindings",
      "method": "watchRbacAuthorizationV1ClusterRoleBindingList",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "watch individual changes to a list of ClusterRoleBinding. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/watch/clusterrolebindings/{name}",
      "method": "watchRbacAuthorizationV1ClusterRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "watch changes to an object of kind ClusterRoleBinding. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/watch/clusterroles",
      "method": "watchRbacAuthorizationV1ClusterRoleList",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "watch individual changes to a list of ClusterRole. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/watch/clusterroles/{name}",
      "method": "watchRbacAuthorizationV1ClusterRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "watch changes to an object of kind ClusterRole. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/rolebindings",
      "method": "watchRbacAuthorizationV1NamespacedRoleBindingList",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "watch individual changes to a list of RoleBinding. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/rolebindings/{name}",
      "method": "watchRbacAuthorizationV1NamespacedRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "watch changes to an object of kind RoleBinding. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/roles",
      "method": "watchRbacAuthorizationV1NamespacedRoleList",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "watch individual changes to a list of Role. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/roles/{name}",
      "method": "watchRbacAuthorizationV1NamespacedRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "watch changes to an object of kind Role. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/watch/rolebindings",
      "method": "watchRbacAuthorizationV1RoleBindingListForAllNamespaces",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "watch individual changes to a list of RoleBinding. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/watch/roles",
      "method": "watchRbacAuthorizationV1RoleListForAllNamespaces",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "description": "watch individual changes to a list of Role. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/",
      "method": "getResourceApiGroup",
      "httpMethod": "get",
      "tag": "resource",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/",
      "method": "getResourceV1Alpha2ApiResources",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/podschedulingcontexts",
      "method": "deleteResourceV1Alpha2CollectionNamespacedPodSchedulingContext",
      "httpMethod": "delete",
      "tag": "resource_v1alpha2",
      "description": "delete collection of PodSchedulingContext",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/podschedulingcontexts",
      "method": "listResourceV1Alpha2NamespacedPodSchedulingContext",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "list or watch objects of kind PodSchedulingContext",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodSchedulingContextList is a collection of Pod scheduling objects."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/podschedulingcontexts",
      "method": "createResourceV1Alpha2NamespacedPodSchedulingContext",
      "httpMethod": "post",
      "tag": "resource_v1alpha2",
      "description": "create a PodSchedulingContext",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use \"WaitForFirstConsumer\" allocation mode.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        },
        {
          "statusCode": "201",
          "description": "PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use \"WaitForFirstConsumer\" allocation mode.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        },
        {
          "statusCode": "202",
          "description": "PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use \"WaitForFirstConsumer\" allocation mode.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/podschedulingcontexts/{name}",
      "method": "deleteResourceV1Alpha2NamespacedPodSchedulingContext",
      "httpMethod": "delete",
      "tag": "resource_v1alpha2",
      "description": "delete a PodSchedulingContext",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use \"WaitForFirstConsumer\" allocation mode.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        },
        {
          "statusCode": "202",
          "description": "PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use \"WaitForFirstConsumer\" allocation mode.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/podschedulingcontexts/{name}",
      "method": "readResourceV1Alpha2NamespacedPodSchedulingContext",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "read the specified PodSchedulingContext",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use \"WaitForFirstConsumer\" allocation mode.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/podschedulingcontexts/{name}",
      "method": "patchResourceV1Alpha2NamespacedPodSchedulingContext",
      "httpMethod": "patch",
      "tag": "resource_v1alpha2",
      "description": "partially update the specified PodSchedulingContext",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use \"WaitForFirstConsumer\" allocation mode.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        },
        {
          "statusCode": "201",
          "description": "PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use \"WaitForFirstConsumer\" allocation mode.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/podschedulingcontexts/{name}",
      "method": "replaceResourceV1Alpha2NamespacedPodSchedulingContext",
      "httpMethod": "put",
      "tag": "resource_v1alpha2",
      "description": "replace the specified PodSchedulingContext",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use \"WaitForFirstConsumer\" allocation mode.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        },
        {
          "statusCode": "201",
          "description": "PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use \"WaitForFirstConsumer\" allocation mode.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/podschedulingcontexts/{name}/status",
      "method": "readResourceV1Alpha2NamespacedPodSchedulingContextStatus",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "read status of the specified PodSchedulingContext",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use \"WaitForFirstConsumer\" allocation mode.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/podschedulingcontexts/{name}/status",
      "method": "patchResourceV1Alpha2NamespacedPodSchedulingContextStatus",
      "httpMethod": "patch",
      "tag": "resource_v1alpha2",
      "description": "partially update status of the specified PodSchedulingContext",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use \"WaitForFirstConsumer\" allocation mode.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        },
        {
          "statusCode": "201",
          "description": "PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use \"WaitForFirstConsumer\" allocation mode.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/podschedulingcontexts/{name}/status",
      "method": "replaceResourceV1Alpha2NamespacedPodSchedulingContextStatus",
      "httpMethod": "put",
      "tag": "resource_v1alpha2",
      "description": "replace status of the specified PodSchedulingContext",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use \"WaitForFirstConsumer\" allocation mode.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        },
        {
          "statusCode": "201",
          "description": "PodSchedulingContext objects hold information that is needed to schedule a Pod with ResourceClaims that use \"WaitForFirstConsumer\" allocation mode.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/resourceclaims",
      "method": "deleteResourceV1Alpha2CollectionNamespacedResourceClaim",
      "httpMethod": "delete",
      "tag": "resource_v1alpha2",
      "description": "delete collection of ResourceClaim",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/resourceclaims",
      "method": "listResourceV1Alpha2NamespacedResourceClaim",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "list or watch objects of kind ResourceClaim",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClaimList is a collection of claims."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/resourceclaims",
      "method": "createResourceV1Alpha2NamespacedResourceClaim",
      "httpMethod": "post",
      "tag": "resource_v1alpha2",
      "description": "create a ResourceClaim",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClaim describes which resources are needed by a resource consumer. Its status tracks whether the resource has been allocated and what the resulting attributes are.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        },
        {
          "statusCode": "201",
          "description": "ResourceClaim describes which resources are needed by a resource consumer. Its status tracks whether the resource has been allocated and what the resulting attributes are.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        },
        {
          "statusCode": "202",
          "description": "ResourceClaim describes which resources are needed by a resource consumer. Its status tracks whether the resource has been allocated and what the resulting attributes are.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/resourceclaims/{name}",
      "method": "deleteResourceV1Alpha2NamespacedResourceClaim",
      "httpMethod": "delete",
      "tag": "resource_v1alpha2",
      "description": "delete a ResourceClaim",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClaim describes which resources are needed by a resource consumer. Its status tracks whether the resource has been allocated and what the resulting attributes are.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        },
        {
          "statusCode": "202",
          "description": "ResourceClaim describes which resources are needed by a resource consumer. Its status tracks whether the resource has been allocated and what the resulting attributes are.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/resourceclaims/{name}",
      "method": "readResourceV1Alpha2NamespacedResourceClaim",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "read the specified ResourceClaim",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClaim describes which resources are needed by a resource consumer. Its status tracks whether the resource has been allocated and what the resulting attributes are.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/resourceclaims/{name}",
      "method": "patchResourceV1Alpha2NamespacedResourceClaim",
      "httpMethod": "patch",
      "tag": "resource_v1alpha2",
      "description": "partially update the specified ResourceClaim",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClaim describes which resources are needed by a resource consumer. Its status tracks whether the resource has been allocated and what the resulting attributes are.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        },
        {
          "statusCode": "201",
          "description": "ResourceClaim describes which resources are needed by a resource consumer. Its status tracks whether the resource has been allocated and what the resulting attributes are.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/resourceclaims/{name}",
      "method": "replaceResourceV1Alpha2NamespacedResourceClaim",
      "httpMethod": "put",
      "tag": "resource_v1alpha2",
      "description": "replace the specified ResourceClaim",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClaim describes which resources are needed by a resource consumer. Its status tracks whether the resource has been allocated and what the resulting attributes are.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        },
        {
          "statusCode": "201",
          "description": "ResourceClaim describes which resources are needed by a resource consumer. Its status tracks whether the resource has been allocated and what the resulting attributes are.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/resourceclaims/{name}/status",
      "method": "readResourceV1Alpha2NamespacedResourceClaimStatus",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "read status of the specified ResourceClaim",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClaim describes which resources are needed by a resource consumer. Its status tracks whether the resource has been allocated and what the resulting attributes are.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/resourceclaims/{name}/status",
      "method": "patchResourceV1Alpha2NamespacedResourceClaimStatus",
      "httpMethod": "patch",
      "tag": "resource_v1alpha2",
      "description": "partially update status of the specified ResourceClaim",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClaim describes which resources are needed by a resource consumer. Its status tracks whether the resource has been allocated and what the resulting attributes are.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        },
        {
          "statusCode": "201",
          "description": "ResourceClaim describes which resources are needed by a resource consumer. Its status tracks whether the resource has been allocated and what the resulting attributes are.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/resourceclaims/{name}/status",
      "method": "replaceResourceV1Alpha2NamespacedResourceClaimStatus",
      "httpMethod": "put",
      "tag": "resource_v1alpha2",
      "description": "replace status of the specified ResourceClaim",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClaim describes which resources are needed by a resource consumer. Its status tracks whether the resource has been allocated and what the resulting attributes are.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        },
        {
          "statusCode": "201",
          "description": "ResourceClaim describes which resources are needed by a resource consumer. Its status tracks whether the resource has been allocated and what the resulting attributes are.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/resourceclaimtemplates",
      "method": "deleteResourceV1Alpha2CollectionNamespacedResourceClaimTemplate",
      "httpMethod": "delete",
      "tag": "resource_v1alpha2",
      "description": "delete collection of ResourceClaimTemplate",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/resourceclaimtemplates",
      "method": "listResourceV1Alpha2NamespacedResourceClaimTemplate",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "list or watch objects of kind ResourceClaimTemplate",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClaimTemplateList is a collection of claim templates."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/resourceclaimtemplates",
      "method": "createResourceV1Alpha2NamespacedResourceClaimTemplate",
      "httpMethod": "post",
      "tag": "resource_v1alpha2",
      "description": "create a ResourceClaimTemplate",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClaimTemplate is used to produce ResourceClaim objects."
        },
        {
          "statusCode": "201",
          "description": "ResourceClaimTemplate is used to produce ResourceClaim objects."
        },
        {
          "statusCode": "202",
          "description": "ResourceClaimTemplate is used to produce ResourceClaim objects."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/resourceclaimtemplates/{name}",
      "method": "deleteResourceV1Alpha2NamespacedResourceClaimTemplate",
      "httpMethod": "delete",
      "tag": "resource_v1alpha2",
      "description": "delete a ResourceClaimTemplate",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClaimTemplate is used to produce ResourceClaim objects."
        },
        {
          "statusCode": "202",
          "description": "ResourceClaimTemplate is used to produce ResourceClaim objects."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/resourceclaimtemplates/{name}",
      "method": "readResourceV1Alpha2NamespacedResourceClaimTemplate",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "read the specified ResourceClaimTemplate",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClaimTemplate is used to produce ResourceClaim objects."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/resourceclaimtemplates/{name}",
      "method": "patchResourceV1Alpha2NamespacedResourceClaimTemplate",
      "httpMethod": "patch",
      "tag": "resource_v1alpha2",
      "description": "partially update the specified ResourceClaimTemplate",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClaimTemplate is used to produce ResourceClaim objects."
        },
        {
          "statusCode": "201",
          "description": "ResourceClaimTemplate is used to produce ResourceClaim objects."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/namespaces/{namespace}/resourceclaimtemplates/{name}",
      "method": "replaceResourceV1Alpha2NamespacedResourceClaimTemplate",
      "httpMethod": "put",
      "tag": "resource_v1alpha2",
      "description": "replace the specified ResourceClaimTemplate",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClaimTemplate is used to produce ResourceClaim objects."
        },
        {
          "statusCode": "201",
          "description": "ResourceClaimTemplate is used to produce ResourceClaim objects."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/podschedulingcontexts",
      "method": "listResourceV1Alpha2PodSchedulingContextForAllNamespaces",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "list or watch objects of kind PodSchedulingContext",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodSchedulingContextList is a collection of Pod scheduling objects."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/resourceclaims",
      "method": "listResourceV1Alpha2ResourceClaimForAllNamespaces",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "list or watch objects of kind ResourceClaim",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClaimList is a collection of claims."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/resourceclaimtemplates",
      "method": "listResourceV1Alpha2ResourceClaimTemplateForAllNamespaces",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "list or watch objects of kind ResourceClaimTemplate",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClaimTemplateList is a collection of claim templates."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/resourceclasses",
      "method": "deleteResourceV1Alpha2CollectionResourceClass",
      "httpMethod": "delete",
      "tag": "resource_v1alpha2",
      "description": "delete collection of ResourceClass",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/resourceclasses",
      "method": "listResourceV1Alpha2ResourceClass",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "list or watch objects of kind ResourceClass",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClassList is a collection of classes."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/resourceclasses",
      "method": "createResourceV1Alpha2ResourceClass",
      "httpMethod": "post",
      "tag": "resource_v1alpha2",
      "description": "create a ResourceClass",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "driverName",
          "schema": "string",
          "required": true,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "parametersRef",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "suitableNodes",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClass is used by administrators to influence how resources are allocated.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        },
        {
          "statusCode": "201",
          "description": "ResourceClass is used by administrators to influence how resources are allocated.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        },
        {
          "statusCode": "202",
          "description": "ResourceClass is used by administrators to influence how resources are allocated.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/resourceclasses/{name}",
      "method": "deleteResourceV1Alpha2ResourceClass",
      "httpMethod": "delete",
      "tag": "resource_v1alpha2",
      "description": "delete a ResourceClass",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClass is used by administrators to influence how resources are allocated.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        },
        {
          "statusCode": "202",
          "description": "ResourceClass is used by administrators to influence how resources are allocated.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/resourceclasses/{name}",
      "method": "readResourceV1Alpha2ResourceClass",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "read the specified ResourceClass",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClass is used by administrators to influence how resources are allocated.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/resourceclasses/{name}",
      "method": "patchResourceV1Alpha2ResourceClass",
      "httpMethod": "patch",
      "tag": "resource_v1alpha2",
      "description": "partially update the specified ResourceClass",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClass is used by administrators to influence how resources are allocated.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        },
        {
          "statusCode": "201",
          "description": "ResourceClass is used by administrators to influence how resources are allocated.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/resourceclasses/{name}",
      "method": "replaceResourceV1Alpha2ResourceClass",
      "httpMethod": "put",
      "tag": "resource_v1alpha2",
      "description": "replace the specified ResourceClass",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "driverName",
          "schema": "string",
          "required": true,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "parametersRef",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "suitableNodes",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceClass is used by administrators to influence how resources are allocated.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        },
        {
          "statusCode": "201",
          "description": "ResourceClass is used by administrators to influence how resources are allocated.\n\nThis is an alpha type and requires enabling the DynamicResourceAllocation feature gate."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/watch/namespaces/{namespace}/podschedulingcontexts",
      "method": "watchResourceV1Alpha2NamespacedPodSchedulingContextList",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "watch individual changes to a list of PodSchedulingContext. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/watch/namespaces/{namespace}/podschedulingcontexts/{name}",
      "method": "watchResourceV1Alpha2NamespacedPodSchedulingContext",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "watch changes to an object of kind PodSchedulingContext. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/watch/namespaces/{namespace}/resourceclaims",
      "method": "watchResourceV1Alpha2NamespacedResourceClaimList",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "watch individual changes to a list of ResourceClaim. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/watch/namespaces/{namespace}/resourceclaims/{name}",
      "method": "watchResourceV1Alpha2NamespacedResourceClaim",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "watch changes to an object of kind ResourceClaim. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/watch/namespaces/{namespace}/resourceclaimtemplates",
      "method": "watchResourceV1Alpha2NamespacedResourceClaimTemplateList",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "watch individual changes to a list of ResourceClaimTemplate. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/watch/namespaces/{namespace}/resourceclaimtemplates/{name}",
      "method": "watchResourceV1Alpha2NamespacedResourceClaimTemplate",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "watch changes to an object of kind ResourceClaimTemplate. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/watch/podschedulingcontexts",
      "method": "watchResourceV1Alpha2PodSchedulingContextListForAllNamespaces",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "watch individual changes to a list of PodSchedulingContext. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/watch/resourceclaims",
      "method": "watchResourceV1Alpha2ResourceClaimListForAllNamespaces",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "watch individual changes to a list of ResourceClaim. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/watch/resourceclaimtemplates",
      "method": "watchResourceV1Alpha2ResourceClaimTemplateListForAllNamespaces",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "watch individual changes to a list of ResourceClaimTemplate. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/watch/resourceclasses",
      "method": "watchResourceV1Alpha2ResourceClassList",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "watch individual changes to a list of ResourceClass. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/resource.k8s.io/v1alpha2/watch/resourceclasses/{name}",
      "method": "watchResourceV1Alpha2ResourceClass",
      "httpMethod": "get",
      "tag": "resource_v1alpha2",
      "description": "watch changes to an object of kind ResourceClass. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/",
      "method": "getSchedulingApiGroup",
      "httpMethod": "get",
      "tag": "scheduling",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/v1/",
      "method": "getSchedulingV1ApiResources",
      "httpMethod": "get",
      "tag": "scheduling_v1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/v1/priorityclasses",
      "method": "deleteSchedulingV1CollectionPriorityClass",
      "httpMethod": "delete",
      "tag": "scheduling_v1",
      "description": "delete collection of PriorityClass",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/v1/priorityclasses",
      "method": "listSchedulingV1PriorityClass",
      "httpMethod": "get",
      "tag": "scheduling_v1",
      "description": "list or watch objects of kind PriorityClass",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityClassList is a collection of priority classes."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/v1/priorityclasses",
      "method": "createSchedulingV1PriorityClass",
      "httpMethod": "post",
      "tag": "scheduling_v1",
      "description": "create a PriorityClass",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "description",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "globalDefault",
          "schema": "boolean",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "preemptionPolicy",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "value",
          "schema": "integer",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer."
        },
        {
          "statusCode": "201",
          "description": "PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer."
        },
        {
          "statusCode": "202",
          "description": "PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/v1/priorityclasses/{name}",
      "method": "deleteSchedulingV1PriorityClass",
      "httpMethod": "delete",
      "tag": "scheduling_v1",
      "description": "delete a PriorityClass",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/v1/priorityclasses/{name}",
      "method": "readSchedulingV1PriorityClass",
      "httpMethod": "get",
      "tag": "scheduling_v1",
      "description": "read the specified PriorityClass",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/v1/priorityclasses/{name}",
      "method": "patchSchedulingV1PriorityClass",
      "httpMethod": "patch",
      "tag": "scheduling_v1",
      "description": "partially update the specified PriorityClass",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer."
        },
        {
          "statusCode": "201",
          "description": "PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/v1/priorityclasses/{name}",
      "method": "replaceSchedulingV1PriorityClass",
      "httpMethod": "put",
      "tag": "scheduling_v1",
      "description": "replace the specified PriorityClass",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "description",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "globalDefault",
          "schema": "boolean",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "preemptionPolicy",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "value",
          "schema": "integer",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer."
        },
        {
          "statusCode": "201",
          "description": "PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/v1/watch/priorityclasses",
      "method": "watchSchedulingV1PriorityClassList",
      "httpMethod": "get",
      "tag": "scheduling_v1",
      "description": "watch individual changes to a list of PriorityClass. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/v1/watch/priorityclasses/{name}",
      "method": "watchSchedulingV1PriorityClass",
      "httpMethod": "get",
      "tag": "scheduling_v1",
      "description": "watch changes to an object of kind PriorityClass. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/",
      "method": "getStorageApiGroup",
      "httpMethod": "get",
      "tag": "storage",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/",
      "method": "getStorageV1ApiResources",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/csidrivers",
      "method": "deleteStorageV1CollectionCsiDriver",
      "httpMethod": "delete",
      "tag": "storage_v1",
      "description": "delete collection of CSIDriver",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/csidrivers",
      "method": "listStorageV1CsiDriver",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "list or watch objects of kind CSIDriver",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CSIDriverList is a collection of CSIDriver objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/csidrivers",
      "method": "createStorageV1CsiDriver",
      "httpMethod": "post",
      "tag": "storage_v1",
      "description": "create a CSIDriver",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CSIDriver captures information about a Container Storage Interface (CSI) volume driver deployed on the cluster. Kubernetes attach detach controller uses this object to determine whether attach is required. Kubelet uses this object to determine whether pod information needs to be passed on mount. CSIDriver objects are non-namespaced."
        },
        {
          "statusCode": "201",
          "description": "CSIDriver captures information about a Container Storage Interface (CSI) volume driver deployed on the cluster. Kubernetes attach detach controller uses this object to determine whether attach is required. Kubelet uses this object to determine whether pod information needs to be passed on mount. CSIDriver objects are non-namespaced."
        },
        {
          "statusCode": "202",
          "description": "CSIDriver captures information about a Container Storage Interface (CSI) volume driver deployed on the cluster. Kubernetes attach detach controller uses this object to determine whether attach is required. Kubelet uses this object to determine whether pod information needs to be passed on mount. CSIDriver objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/csidrivers/{name}",
      "method": "deleteStorageV1CsiDriver",
      "httpMethod": "delete",
      "tag": "storage_v1",
      "description": "delete a CSIDriver",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CSIDriver captures information about a Container Storage Interface (CSI) volume driver deployed on the cluster. Kubernetes attach detach controller uses this object to determine whether attach is required. Kubelet uses this object to determine whether pod information needs to be passed on mount. CSIDriver objects are non-namespaced."
        },
        {
          "statusCode": "202",
          "description": "CSIDriver captures information about a Container Storage Interface (CSI) volume driver deployed on the cluster. Kubernetes attach detach controller uses this object to determine whether attach is required. Kubelet uses this object to determine whether pod information needs to be passed on mount. CSIDriver objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/csidrivers/{name}",
      "method": "readStorageV1CsiDriver",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "read the specified CSIDriver",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CSIDriver captures information about a Container Storage Interface (CSI) volume driver deployed on the cluster. Kubernetes attach detach controller uses this object to determine whether attach is required. Kubelet uses this object to determine whether pod information needs to be passed on mount. CSIDriver objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/csidrivers/{name}",
      "method": "patchStorageV1CsiDriver",
      "httpMethod": "patch",
      "tag": "storage_v1",
      "description": "partially update the specified CSIDriver",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CSIDriver captures information about a Container Storage Interface (CSI) volume driver deployed on the cluster. Kubernetes attach detach controller uses this object to determine whether attach is required. Kubelet uses this object to determine whether pod information needs to be passed on mount. CSIDriver objects are non-namespaced."
        },
        {
          "statusCode": "201",
          "description": "CSIDriver captures information about a Container Storage Interface (CSI) volume driver deployed on the cluster. Kubernetes attach detach controller uses this object to determine whether attach is required. Kubelet uses this object to determine whether pod information needs to be passed on mount. CSIDriver objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/csidrivers/{name}",
      "method": "replaceStorageV1CsiDriver",
      "httpMethod": "put",
      "tag": "storage_v1",
      "description": "replace the specified CSIDriver",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CSIDriver captures information about a Container Storage Interface (CSI) volume driver deployed on the cluster. Kubernetes attach detach controller uses this object to determine whether attach is required. Kubelet uses this object to determine whether pod information needs to be passed on mount. CSIDriver objects are non-namespaced."
        },
        {
          "statusCode": "201",
          "description": "CSIDriver captures information about a Container Storage Interface (CSI) volume driver deployed on the cluster. Kubernetes attach detach controller uses this object to determine whether attach is required. Kubelet uses this object to determine whether pod information needs to be passed on mount. CSIDriver objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/csinodes",
      "method": "deleteStorageV1CollectionCsiNode",
      "httpMethod": "delete",
      "tag": "storage_v1",
      "description": "delete collection of CSINode",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/csinodes",
      "method": "listStorageV1CsiNode",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "list or watch objects of kind CSINode",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CSINodeList is a collection of CSINode objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/csinodes",
      "method": "createStorageV1CsiNode",
      "httpMethod": "post",
      "tag": "storage_v1",
      "description": "create a CSINode",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need to create the CSINode object directly. As long as they use the node-driver-registrar sidecar container, the kubelet will automatically populate the CSINode object for the CSI driver as part of kubelet plugin registration. CSINode has the same name as a node. If the object is missing, it means either there are no CSI Drivers available on the node, or the Kubelet version is low enough that it doesn't create this object. CSINode has an OwnerReference that points to the corresponding node object."
        },
        {
          "statusCode": "201",
          "description": "CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need to create the CSINode object directly. As long as they use the node-driver-registrar sidecar container, the kubelet will automatically populate the CSINode object for the CSI driver as part of kubelet plugin registration. CSINode has the same name as a node. If the object is missing, it means either there are no CSI Drivers available on the node, or the Kubelet version is low enough that it doesn't create this object. CSINode has an OwnerReference that points to the corresponding node object."
        },
        {
          "statusCode": "202",
          "description": "CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need to create the CSINode object directly. As long as they use the node-driver-registrar sidecar container, the kubelet will automatically populate the CSINode object for the CSI driver as part of kubelet plugin registration. CSINode has the same name as a node. If the object is missing, it means either there are no CSI Drivers available on the node, or the Kubelet version is low enough that it doesn't create this object. CSINode has an OwnerReference that points to the corresponding node object."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/csinodes/{name}",
      "method": "deleteStorageV1CsiNode",
      "httpMethod": "delete",
      "tag": "storage_v1",
      "description": "delete a CSINode",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need to create the CSINode object directly. As long as they use the node-driver-registrar sidecar container, the kubelet will automatically populate the CSINode object for the CSI driver as part of kubelet plugin registration. CSINode has the same name as a node. If the object is missing, it means either there are no CSI Drivers available on the node, or the Kubelet version is low enough that it doesn't create this object. CSINode has an OwnerReference that points to the corresponding node object."
        },
        {
          "statusCode": "202",
          "description": "CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need to create the CSINode object directly. As long as they use the node-driver-registrar sidecar container, the kubelet will automatically populate the CSINode object for the CSI driver as part of kubelet plugin registration. CSINode has the same name as a node. If the object is missing, it means either there are no CSI Drivers available on the node, or the Kubelet version is low enough that it doesn't create this object. CSINode has an OwnerReference that points to the corresponding node object."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/csinodes/{name}",
      "method": "readStorageV1CsiNode",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "read the specified CSINode",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need to create the CSINode object directly. As long as they use the node-driver-registrar sidecar container, the kubelet will automatically populate the CSINode object for the CSI driver as part of kubelet plugin registration. CSINode has the same name as a node. If the object is missing, it means either there are no CSI Drivers available on the node, or the Kubelet version is low enough that it doesn't create this object. CSINode has an OwnerReference that points to the corresponding node object."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/csinodes/{name}",
      "method": "patchStorageV1CsiNode",
      "httpMethod": "patch",
      "tag": "storage_v1",
      "description": "partially update the specified CSINode",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need to create the CSINode object directly. As long as they use the node-driver-registrar sidecar container, the kubelet will automatically populate the CSINode object for the CSI driver as part of kubelet plugin registration. CSINode has the same name as a node. If the object is missing, it means either there are no CSI Drivers available on the node, or the Kubelet version is low enough that it doesn't create this object. CSINode has an OwnerReference that points to the corresponding node object."
        },
        {
          "statusCode": "201",
          "description": "CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need to create the CSINode object directly. As long as they use the node-driver-registrar sidecar container, the kubelet will automatically populate the CSINode object for the CSI driver as part of kubelet plugin registration. CSINode has the same name as a node. If the object is missing, it means either there are no CSI Drivers available on the node, or the Kubelet version is low enough that it doesn't create this object. CSINode has an OwnerReference that points to the corresponding node object."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/csinodes/{name}",
      "method": "replaceStorageV1CsiNode",
      "httpMethod": "put",
      "tag": "storage_v1",
      "description": "replace the specified CSINode",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need to create the CSINode object directly. As long as they use the node-driver-registrar sidecar container, the kubelet will automatically populate the CSINode object for the CSI driver as part of kubelet plugin registration. CSINode has the same name as a node. If the object is missing, it means either there are no CSI Drivers available on the node, or the Kubelet version is low enough that it doesn't create this object. CSINode has an OwnerReference that points to the corresponding node object."
        },
        {
          "statusCode": "201",
          "description": "CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need to create the CSINode object directly. As long as they use the node-driver-registrar sidecar container, the kubelet will automatically populate the CSINode object for the CSI driver as part of kubelet plugin registration. CSINode has the same name as a node. If the object is missing, it means either there are no CSI Drivers available on the node, or the Kubelet version is low enough that it doesn't create this object. CSINode has an OwnerReference that points to the corresponding node object."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/csistoragecapacities",
      "method": "listStorageV1CsiStorageCapacityForAllNamespaces",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "list or watch objects of kind CSIStorageCapacity",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CSIStorageCapacityList is a collection of CSIStorageCapacity objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/namespaces/{namespace}/csistoragecapacities",
      "method": "deleteStorageV1CollectionNamespacedCsiStorageCapacity",
      "httpMethod": "delete",
      "tag": "storage_v1",
      "description": "delete collection of CSIStorageCapacity",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/namespaces/{namespace}/csistoragecapacities",
      "method": "listStorageV1NamespacedCsiStorageCapacity",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "list or watch objects of kind CSIStorageCapacity",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CSIStorageCapacityList is a collection of CSIStorageCapacity objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/namespaces/{namespace}/csistoragecapacities",
      "method": "createStorageV1NamespacedCsiStorageCapacity",
      "httpMethod": "post",
      "tag": "storage_v1",
      "description": "create a CSIStorageCapacity",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "capacity",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "maximumVolumeSize",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "nodeTopology",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "storageClassName",
          "schema": "string",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CSIStorageCapacity stores the result of one CSI GetCapacity call. For a given StorageClass, this describes the available capacity in a particular topology segment.  This can be used when considering where to instantiate new PersistentVolumes.\n\nFor example this can express things like: - StorageClass \"standard\" has \"1234 GiB\" available in \"topology.kubernetes.io/zone=us-east1\" - StorageClass \"localssd\" has \"10 GiB\" available in \"kubernetes.io/hostname=knode-abc123\"\n\nThe following three cases all imply that no capacity is available for a certain combination: - no object exists with suitable topology and storage class name - such an object exists, but the capacity is unset - such an object exists, but the capacity is zero\n\nThe producer of these objects can decide which approach is more suitable.\n\nThey are consumed by the kube-scheduler when a CSI driver opts into capacity-aware scheduling with CSIDriverSpec.StorageCapacity. The scheduler compares the MaximumVolumeSize against the requested size of pending volumes to filter out unsuitable nodes. If MaximumVolumeSize is unset, it falls back to a comparison against the less precise Capacity. If that is also unset, the scheduler assumes that capacity is insufficient and tries some other node."
        },
        {
          "statusCode": "201",
          "description": "CSIStorageCapacity stores the result of one CSI GetCapacity call. For a given StorageClass, this describes the available capacity in a particular topology segment.  This can be used when considering where to instantiate new PersistentVolumes.\n\nFor example this can express things like: - StorageClass \"standard\" has \"1234 GiB\" available in \"topology.kubernetes.io/zone=us-east1\" - StorageClass \"localssd\" has \"10 GiB\" available in \"kubernetes.io/hostname=knode-abc123\"\n\nThe following three cases all imply that no capacity is available for a certain combination: - no object exists with suitable topology and storage class name - such an object exists, but the capacity is unset - such an object exists, but the capacity is zero\n\nThe producer of these objects can decide which approach is more suitable.\n\nThey are consumed by the kube-scheduler when a CSI driver opts into capacity-aware scheduling with CSIDriverSpec.StorageCapacity. The scheduler compares the MaximumVolumeSize against the requested size of pending volumes to filter out unsuitable nodes. If MaximumVolumeSize is unset, it falls back to a comparison against the less precise Capacity. If that is also unset, the scheduler assumes that capacity is insufficient and tries some other node."
        },
        {
          "statusCode": "202",
          "description": "CSIStorageCapacity stores the result of one CSI GetCapacity call. For a given StorageClass, this describes the available capacity in a particular topology segment.  This can be used when considering where to instantiate new PersistentVolumes.\n\nFor example this can express things like: - StorageClass \"standard\" has \"1234 GiB\" available in \"topology.kubernetes.io/zone=us-east1\" - StorageClass \"localssd\" has \"10 GiB\" available in \"kubernetes.io/hostname=knode-abc123\"\n\nThe following three cases all imply that no capacity is available for a certain combination: - no object exists with suitable topology and storage class name - such an object exists, but the capacity is unset - such an object exists, but the capacity is zero\n\nThe producer of these objects can decide which approach is more suitable.\n\nThey are consumed by the kube-scheduler when a CSI driver opts into capacity-aware scheduling with CSIDriverSpec.StorageCapacity. The scheduler compares the MaximumVolumeSize against the requested size of pending volumes to filter out unsuitable nodes. If MaximumVolumeSize is unset, it falls back to a comparison against the less precise Capacity. If that is also unset, the scheduler assumes that capacity is insufficient and tries some other node."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/namespaces/{namespace}/csistoragecapacities/{name}",
      "method": "deleteStorageV1NamespacedCsiStorageCapacity",
      "httpMethod": "delete",
      "tag": "storage_v1",
      "description": "delete a CSIStorageCapacity",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        },
        {
          "statusCode": "202",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/namespaces/{namespace}/csistoragecapacities/{name}",
      "method": "readStorageV1NamespacedCsiStorageCapacity",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "read the specified CSIStorageCapacity",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CSIStorageCapacity stores the result of one CSI GetCapacity call. For a given StorageClass, this describes the available capacity in a particular topology segment.  This can be used when considering where to instantiate new PersistentVolumes.\n\nFor example this can express things like: - StorageClass \"standard\" has \"1234 GiB\" available in \"topology.kubernetes.io/zone=us-east1\" - StorageClass \"localssd\" has \"10 GiB\" available in \"kubernetes.io/hostname=knode-abc123\"\n\nThe following three cases all imply that no capacity is available for a certain combination: - no object exists with suitable topology and storage class name - such an object exists, but the capacity is unset - such an object exists, but the capacity is zero\n\nThe producer of these objects can decide which approach is more suitable.\n\nThey are consumed by the kube-scheduler when a CSI driver opts into capacity-aware scheduling with CSIDriverSpec.StorageCapacity. The scheduler compares the MaximumVolumeSize against the requested size of pending volumes to filter out unsuitable nodes. If MaximumVolumeSize is unset, it falls back to a comparison against the less precise Capacity. If that is also unset, the scheduler assumes that capacity is insufficient and tries some other node."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/namespaces/{namespace}/csistoragecapacities/{name}",
      "method": "patchStorageV1NamespacedCsiStorageCapacity",
      "httpMethod": "patch",
      "tag": "storage_v1",
      "description": "partially update the specified CSIStorageCapacity",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CSIStorageCapacity stores the result of one CSI GetCapacity call. For a given StorageClass, this describes the available capacity in a particular topology segment.  This can be used when considering where to instantiate new PersistentVolumes.\n\nFor example this can express things like: - StorageClass \"standard\" has \"1234 GiB\" available in \"topology.kubernetes.io/zone=us-east1\" - StorageClass \"localssd\" has \"10 GiB\" available in \"kubernetes.io/hostname=knode-abc123\"\n\nThe following three cases all imply that no capacity is available for a certain combination: - no object exists with suitable topology and storage class name - such an object exists, but the capacity is unset - such an object exists, but the capacity is zero\n\nThe producer of these objects can decide which approach is more suitable.\n\nThey are consumed by the kube-scheduler when a CSI driver opts into capacity-aware scheduling with CSIDriverSpec.StorageCapacity. The scheduler compares the MaximumVolumeSize against the requested size of pending volumes to filter out unsuitable nodes. If MaximumVolumeSize is unset, it falls back to a comparison against the less precise Capacity. If that is also unset, the scheduler assumes that capacity is insufficient and tries some other node."
        },
        {
          "statusCode": "201",
          "description": "CSIStorageCapacity stores the result of one CSI GetCapacity call. For a given StorageClass, this describes the available capacity in a particular topology segment.  This can be used when considering where to instantiate new PersistentVolumes.\n\nFor example this can express things like: - StorageClass \"standard\" has \"1234 GiB\" available in \"topology.kubernetes.io/zone=us-east1\" - StorageClass \"localssd\" has \"10 GiB\" available in \"kubernetes.io/hostname=knode-abc123\"\n\nThe following three cases all imply that no capacity is available for a certain combination: - no object exists with suitable topology and storage class name - such an object exists, but the capacity is unset - such an object exists, but the capacity is zero\n\nThe producer of these objects can decide which approach is more suitable.\n\nThey are consumed by the kube-scheduler when a CSI driver opts into capacity-aware scheduling with CSIDriverSpec.StorageCapacity. The scheduler compares the MaximumVolumeSize against the requested size of pending volumes to filter out unsuitable nodes. If MaximumVolumeSize is unset, it falls back to a comparison against the less precise Capacity. If that is also unset, the scheduler assumes that capacity is insufficient and tries some other node."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/namespaces/{namespace}/csistoragecapacities/{name}",
      "method": "replaceStorageV1NamespacedCsiStorageCapacity",
      "httpMethod": "put",
      "tag": "storage_v1",
      "description": "replace the specified CSIStorageCapacity",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "capacity",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "maximumVolumeSize",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "nodeTopology",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "storageClassName",
          "schema": "string",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CSIStorageCapacity stores the result of one CSI GetCapacity call. For a given StorageClass, this describes the available capacity in a particular topology segment.  This can be used when considering where to instantiate new PersistentVolumes.\n\nFor example this can express things like: - StorageClass \"standard\" has \"1234 GiB\" available in \"topology.kubernetes.io/zone=us-east1\" - StorageClass \"localssd\" has \"10 GiB\" available in \"kubernetes.io/hostname=knode-abc123\"\n\nThe following three cases all imply that no capacity is available for a certain combination: - no object exists with suitable topology and storage class name - such an object exists, but the capacity is unset - such an object exists, but the capacity is zero\n\nThe producer of these objects can decide which approach is more suitable.\n\nThey are consumed by the kube-scheduler when a CSI driver opts into capacity-aware scheduling with CSIDriverSpec.StorageCapacity. The scheduler compares the MaximumVolumeSize against the requested size of pending volumes to filter out unsuitable nodes. If MaximumVolumeSize is unset, it falls back to a comparison against the less precise Capacity. If that is also unset, the scheduler assumes that capacity is insufficient and tries some other node."
        },
        {
          "statusCode": "201",
          "description": "CSIStorageCapacity stores the result of one CSI GetCapacity call. For a given StorageClass, this describes the available capacity in a particular topology segment.  This can be used when considering where to instantiate new PersistentVolumes.\n\nFor example this can express things like: - StorageClass \"standard\" has \"1234 GiB\" available in \"topology.kubernetes.io/zone=us-east1\" - StorageClass \"localssd\" has \"10 GiB\" available in \"kubernetes.io/hostname=knode-abc123\"\n\nThe following three cases all imply that no capacity is available for a certain combination: - no object exists with suitable topology and storage class name - such an object exists, but the capacity is unset - such an object exists, but the capacity is zero\n\nThe producer of these objects can decide which approach is more suitable.\n\nThey are consumed by the kube-scheduler when a CSI driver opts into capacity-aware scheduling with CSIDriverSpec.StorageCapacity. The scheduler compares the MaximumVolumeSize against the requested size of pending volumes to filter out unsuitable nodes. If MaximumVolumeSize is unset, it falls back to a comparison against the less precise Capacity. If that is also unset, the scheduler assumes that capacity is insufficient and tries some other node."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/storageclasses",
      "method": "deleteStorageV1CollectionStorageClass",
      "httpMethod": "delete",
      "tag": "storage_v1",
      "description": "delete collection of StorageClass",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/storageclasses",
      "method": "listStorageV1StorageClass",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "list or watch objects of kind StorageClass",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StorageClassList is a collection of storage classes."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/storageclasses",
      "method": "createStorageV1StorageClass",
      "httpMethod": "post",
      "tag": "storage_v1",
      "description": "create a StorageClass",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "allowVolumeExpansion",
          "schema": "boolean",
          "required": false,
          "description": ""
        },
        {
          "name": "allowedTopologies",
          "schema": "array",
          "required": false,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "mountOptions",
          "schema": "array",
          "required": false,
          "description": ""
        },
        {
          "name": "parameters",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "provisioner",
          "schema": "string",
          "required": true,
          "description": ""
        },
        {
          "name": "reclaimPolicy",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "volumeBindingMode",
          "schema": "string",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        },
        {
          "statusCode": "201",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        },
        {
          "statusCode": "202",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/storageclasses/{name}",
      "method": "deleteStorageV1StorageClass",
      "httpMethod": "delete",
      "tag": "storage_v1",
      "description": "delete a StorageClass",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        },
        {
          "statusCode": "202",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/storageclasses/{name}",
      "method": "readStorageV1StorageClass",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "read the specified StorageClass",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/storageclasses/{name}",
      "method": "patchStorageV1StorageClass",
      "httpMethod": "patch",
      "tag": "storage_v1",
      "description": "partially update the specified StorageClass",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        },
        {
          "statusCode": "201",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/storageclasses/{name}",
      "method": "replaceStorageV1StorageClass",
      "httpMethod": "put",
      "tag": "storage_v1",
      "description": "replace the specified StorageClass",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "allowVolumeExpansion",
          "schema": "boolean",
          "required": false,
          "description": ""
        },
        {
          "name": "allowedTopologies",
          "schema": "array",
          "required": false,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "mountOptions",
          "schema": "array",
          "required": false,
          "description": ""
        },
        {
          "name": "parameters",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "provisioner",
          "schema": "string",
          "required": true,
          "description": ""
        },
        {
          "name": "reclaimPolicy",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "volumeBindingMode",
          "schema": "string",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        },
        {
          "statusCode": "201",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/volumeattachments",
      "method": "deleteStorageV1CollectionVolumeAttachment",
      "httpMethod": "delete",
      "tag": "storage_v1",
      "description": "delete collection of VolumeAttachment",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/volumeattachments",
      "method": "listStorageV1VolumeAttachment",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "list or watch objects of kind VolumeAttachment",
      "parameters": [
        {
          "name": "allowWatchBookmarks",
          "schema": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored."
        },
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "resourceVersionMatch",
          "schema": "string",
          "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset"
        },
        {
          "name": "sendInitialEvents",
          "schema": "boolean",
          "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "VolumeAttachmentList is a collection of VolumeAttachment objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/volumeattachments",
      "method": "createStorageV1VolumeAttachment",
      "httpMethod": "post",
      "tag": "storage_v1",
      "description": "create a VolumeAttachment",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        },
        {
          "statusCode": "201",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        },
        {
          "statusCode": "202",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/volumeattachments/{name}",
      "method": "deleteStorageV1VolumeAttachment",
      "httpMethod": "delete",
      "tag": "storage_v1",
      "description": "delete a VolumeAttachment",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "dryRun",
          "schema": "array",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "object",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        },
        {
          "statusCode": "202",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/volumeattachments/{name}",
      "method": "readStorageV1VolumeAttachment",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "read the specified VolumeAttachment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/volumeattachments/{name}",
      "method": "patchStorageV1VolumeAttachment",
      "httpMethod": "patch",
      "tag": "storage_v1",
      "description": "partially update the specified VolumeAttachment",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        },
        {
          "statusCode": "201",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/volumeattachments/{name}",
      "method": "replaceStorageV1VolumeAttachment",
      "httpMethod": "put",
      "tag": "storage_v1",
      "description": "replace the specified VolumeAttachment",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        },
        {
          "statusCode": "201",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/volumeattachments/{name}/status",
      "method": "readStorageV1VolumeAttachmentStatus",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "read status of the specified VolumeAttachment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/volumeattachments/{name}/status",
      "method": "patchStorageV1VolumeAttachmentStatus",
      "httpMethod": "patch",
      "tag": "storage_v1",
      "description": "partially update status of the specified VolumeAttachment",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch)."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "force",
          "schema": "boolean",
          "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        },
        {
          "statusCode": "201",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/volumeattachments/{name}/status",
      "method": "replaceStorageV1VolumeAttachmentStatus",
      "httpMethod": "put",
      "tag": "storage_v1",
      "description": "replace status of the specified VolumeAttachment",
      "parameters": [
        {
          "name": "dryRun",
          "schema": "string",
          "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed"
        },
        {
          "name": "fieldManager",
          "schema": "string",
          "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
        },
        {
          "name": "fieldValidation",
          "schema": "string",
          "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "object",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        },
        {
          "statusCode": "201",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/watch/csidrivers",
      "method": "watchStorageV1CsiDriverList",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "watch individual changes to a list of CSIDriver. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/watch/csidrivers/{name}",
      "method": "watchStorageV1CsiDriver",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "watch changes to an object of kind CSIDriver. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/watch/csinodes",
      "method": "watchStorageV1CsiNodeList",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "watch individual changes to a list of CSINode. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/watch/csinodes/{name}",
      "method": "watchStorageV1CsiNode",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "watch changes to an object of kind CSINode. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/watch/csistoragecapacities",
      "method": "watchStorageV1CsiStorageCapacityListForAllNamespaces",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "watch individual changes to a list of CSIStorageCapacity. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/watch/namespaces/{namespace}/csistoragecapacities",
      "method": "watchStorageV1NamespacedCsiStorageCapacityList",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "watch individual changes to a list of CSIStorageCapacity. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/watch/namespaces/{namespace}/csistoragecapacities/{name}",
      "method": "watchStorageV1NamespacedCsiStorageCapacity",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "watch changes to an object of kind CSIStorageCapacity. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/watch/storageclasses",
      "method": "watchStorageV1StorageClassList",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "watch individual changes to a list of StorageClass. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/watch/storageclasses/{name}",
      "method": "watchStorageV1StorageClass",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "watch changes to an object of kind StorageClass. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/watch/volumeattachments",
      "method": "watchStorageV1VolumeAttachmentList",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "watch individual changes to a list of VolumeAttachment. deprecated: use the 'watch' parameter with a list operation instead.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/watch/volumeattachments/{name}",
      "method": "watchStorageV1VolumeAttachment",
      "httpMethod": "get",
      "tag": "storage_v1",
      "description": "watch changes to an object of kind VolumeAttachment. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/logs/",
      "method": "logFileListHandler",
      "httpMethod": "get",
      "tag": "logs",
      "description": "",
      "parameters": [],
      "responses": []
    },
    {
      "url": "/logs/{logpath}",
      "method": "logFileHandler",
      "httpMethod": "get",
      "tag": "logs",
      "description": "",
      "parameters": [],
      "responses": []
    },
    {
      "url": "/openid/v1/jwks/",
      "method": "getServiceAccountIssuerOpenIdKeyset",
      "httpMethod": "get",
      "tag": "openid",
      "description": "get service account issuer OpenID JSON Web Key Set (contains public token verification keys)",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/version/",
      "method": "getCodeVersion",
      "httpMethod": "get",
      "tag": "version",
      "description": "get the code version",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Info contains versioning information. how we'll want to distribute that information."
        }
      ]
    }
  ],
  "apiBaseUrl": "kubernetes.local",
  "apiTitle": "Kubernetes",
  "endpoints": 428,
  "sdkMethods": 1217,
  "schemas": 547,
  "parameters": 4190,
  "difficultyScore": 2538,
  "difficulty": "Very Hard"
}