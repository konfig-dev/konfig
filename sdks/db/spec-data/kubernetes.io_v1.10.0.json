{
  "providerName": "kubernetes.io",
  "openApiRaw": "https://raw.githubusercontent.com/kubernetes/kubernetes/v1.10.0/api/openapi-spec/swagger.json",
  "securitySchemes": {
    "BearerToken": {
      "description": "Bearer Token authentication",
      "in": "header",
      "name": "authorization",
      "type": "apiKey"
    }
  },
  "homepage": "kubernetes.io",
  "apiVersion": "v1.10.0",
  "methods": [
    {
      "url": "/api/",
      "method": "getCoreApiVersions",
      "httpMethod": "get",
      "tag": "core",
      "typeScriptTag": "core",
      "description": "get available API versions",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIVersions lists the versions that are available, to allow clients to discover the API at /api, which is the root path of the legacy v1 API."
        }
      ]
    },
    {
      "url": "/api/v1/",
      "method": "getCoreV1ApiResources",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/api/v1/componentstatuses",
      "method": "listCoreV1ComponentStatus",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list objects of kind ComponentStatus",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status of all the conditions for the component as a list of ComponentStatus objects."
        }
      ]
    },
    {
      "url": "/api/v1/componentstatuses/{name}",
      "method": "readCoreV1ComponentStatus",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read the specified ComponentStatus",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ComponentStatus (and ComponentStatusList) holds the cluster validation info."
        }
      ]
    },
    {
      "url": "/api/v1/configmaps",
      "method": "listCoreV1ConfigMapForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind ConfigMap",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ConfigMapList is a resource containing a list of ConfigMap objects."
        }
      ]
    },
    {
      "url": "/api/v1/endpoints",
      "method": "listCoreV1EndpointsForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind Endpoints",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "EndpointsList is a list of endpoints."
        }
      ]
    },
    {
      "url": "/api/v1/events",
      "method": "listCoreV1EventForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind Event",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "EventList is a list of events."
        }
      ]
    },
    {
      "url": "/api/v1/limitranges",
      "method": "listCoreV1LimitRangeForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind LimitRange",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "LimitRangeList is a list of LimitRange items."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces",
      "method": "listCoreV1Namespace",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind Namespace",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "NamespaceList is a list of Namespaces."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces",
      "method": "createCoreV1Namespace",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "create a Namespace",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        },
        {
          "statusCode": "201",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        },
        {
          "statusCode": "202",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/bindings",
      "method": "createCoreV1NamespacedBinding",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "create a Binding",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "target",
          "schema": "undefined",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Binding ties one object to another; for example, a pod is bound to a node by a scheduler. Deprecated in 1.7, please use the bindings subresource of pods instead."
        },
        {
          "statusCode": "201",
          "description": "Binding ties one object to another; for example, a pod is bound to a node by a scheduler. Deprecated in 1.7, please use the bindings subresource of pods instead."
        },
        {
          "statusCode": "202",
          "description": "Binding ties one object to another; for example, a pod is bound to a node by a scheduler. Deprecated in 1.7, please use the bindings subresource of pods instead."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/configmaps",
      "method": "deleteCoreV1CollectionNamespacedConfigMap",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete collection of ConfigMap",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/configmaps",
      "method": "listCoreV1NamespacedConfigMap",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind ConfigMap",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ConfigMapList is a resource containing a list of ConfigMap objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/configmaps",
      "method": "createCoreV1NamespacedConfigMap",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "create a ConfigMap",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "binaryData",
          "schema": "object",
          "description": ""
        },
        {
          "name": "data",
          "schema": "object",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ConfigMap holds configuration data for pods to consume."
        },
        {
          "statusCode": "201",
          "description": "ConfigMap holds configuration data for pods to consume."
        },
        {
          "statusCode": "202",
          "description": "ConfigMap holds configuration data for pods to consume."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/configmaps/{name}",
      "method": "deleteCoreV1NamespacedConfigMap",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete a ConfigMap",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/configmaps/{name}",
      "method": "readCoreV1NamespacedConfigMap",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read the specified ConfigMap",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ConfigMap holds configuration data for pods to consume."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/configmaps/{name}",
      "method": "patchCoreV1NamespacedConfigMap",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update the specified ConfigMap",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ConfigMap holds configuration data for pods to consume."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/configmaps/{name}",
      "method": "replaceCoreV1NamespacedConfigMap",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace the specified ConfigMap",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "binaryData",
          "schema": "object",
          "description": ""
        },
        {
          "name": "data",
          "schema": "object",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ConfigMap holds configuration data for pods to consume."
        },
        {
          "statusCode": "201",
          "description": "ConfigMap holds configuration data for pods to consume."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/endpoints",
      "method": "deleteCoreV1CollectionNamespacedEndpoints",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete collection of Endpoints",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/endpoints",
      "method": "listCoreV1NamespacedEndpoints",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind Endpoints",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "EndpointsList is a list of endpoints."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/endpoints",
      "method": "createCoreV1NamespacedEndpoints",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "create Endpoints",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "subsets",
          "schema": "array",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Endpoints is a collection of endpoints that implement the actual service. Example:\n  Name: \"mysvc\",\n  Subsets: [\n    {\n      Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n      Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n    },\n    {\n      Addresses: [{\"ip\": \"10.10.3.3\"}],\n      Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n    },\n ]"
        },
        {
          "statusCode": "201",
          "description": "Endpoints is a collection of endpoints that implement the actual service. Example:\n  Name: \"mysvc\",\n  Subsets: [\n    {\n      Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n      Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n    },\n    {\n      Addresses: [{\"ip\": \"10.10.3.3\"}],\n      Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n    },\n ]"
        },
        {
          "statusCode": "202",
          "description": "Endpoints is a collection of endpoints that implement the actual service. Example:\n  Name: \"mysvc\",\n  Subsets: [\n    {\n      Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n      Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n    },\n    {\n      Addresses: [{\"ip\": \"10.10.3.3\"}],\n      Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n    },\n ]"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/endpoints/{name}",
      "method": "deleteCoreV1NamespacedEndpoints",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete Endpoints",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/endpoints/{name}",
      "method": "readCoreV1NamespacedEndpoints",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read the specified Endpoints",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Endpoints is a collection of endpoints that implement the actual service. Example:\n  Name: \"mysvc\",\n  Subsets: [\n    {\n      Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n      Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n    },\n    {\n      Addresses: [{\"ip\": \"10.10.3.3\"}],\n      Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n    },\n ]"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/endpoints/{name}",
      "method": "patchCoreV1NamespacedEndpoints",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update the specified Endpoints",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Endpoints is a collection of endpoints that implement the actual service. Example:\n  Name: \"mysvc\",\n  Subsets: [\n    {\n      Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n      Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n    },\n    {\n      Addresses: [{\"ip\": \"10.10.3.3\"}],\n      Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n    },\n ]"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/endpoints/{name}",
      "method": "replaceCoreV1NamespacedEndpoints",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace the specified Endpoints",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "subsets",
          "schema": "array",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Endpoints is a collection of endpoints that implement the actual service. Example:\n  Name: \"mysvc\",\n  Subsets: [\n    {\n      Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n      Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n    },\n    {\n      Addresses: [{\"ip\": \"10.10.3.3\"}],\n      Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n    },\n ]"
        },
        {
          "statusCode": "201",
          "description": "Endpoints is a collection of endpoints that implement the actual service. Example:\n  Name: \"mysvc\",\n  Subsets: [\n    {\n      Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n      Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n    },\n    {\n      Addresses: [{\"ip\": \"10.10.3.3\"}],\n      Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n    },\n ]"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/events",
      "method": "deleteCoreV1CollectionNamespacedEvent",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete collection of Event",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/events",
      "method": "listCoreV1NamespacedEvent",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind Event",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "EventList is a list of events."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/events",
      "method": "createCoreV1NamespacedEvent",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "create an Event",
      "parameters": [
        {
          "name": "action",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "count",
          "schema": "integer",
          "required": false,
          "description": ""
        },
        {
          "name": "eventTime",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "firstTimestamp",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "involvedObject",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "lastTimestamp",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "message",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "reason",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "related",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "reportingComponent",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "reportingInstance",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "series",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "source",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "type",
          "schema": "string",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event is a report of an event somewhere in the cluster."
        },
        {
          "statusCode": "201",
          "description": "Event is a report of an event somewhere in the cluster."
        },
        {
          "statusCode": "202",
          "description": "Event is a report of an event somewhere in the cluster."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/events/{name}",
      "method": "deleteCoreV1NamespacedEvent",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete an Event",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/events/{name}",
      "method": "readCoreV1NamespacedEvent",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read the specified Event",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event is a report of an event somewhere in the cluster."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/events/{name}",
      "method": "patchCoreV1NamespacedEvent",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update the specified Event",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event is a report of an event somewhere in the cluster."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/events/{name}",
      "method": "replaceCoreV1NamespacedEvent",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace the specified Event",
      "parameters": [
        {
          "name": "action",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "count",
          "schema": "integer",
          "required": false,
          "description": ""
        },
        {
          "name": "eventTime",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "firstTimestamp",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "involvedObject",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "lastTimestamp",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "message",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "reason",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "related",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "reportingComponent",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "reportingInstance",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "series",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "source",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "type",
          "schema": "string",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event is a report of an event somewhere in the cluster."
        },
        {
          "statusCode": "201",
          "description": "Event is a report of an event somewhere in the cluster."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/limitranges",
      "method": "deleteCoreV1CollectionNamespacedLimitRange",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete collection of LimitRange",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/limitranges",
      "method": "listCoreV1NamespacedLimitRange",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind LimitRange",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "LimitRangeList is a list of LimitRange items."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/limitranges",
      "method": "createCoreV1NamespacedLimitRange",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "create a LimitRange",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "LimitRange sets resource usage limits for each kind of resource in a Namespace."
        },
        {
          "statusCode": "201",
          "description": "LimitRange sets resource usage limits for each kind of resource in a Namespace."
        },
        {
          "statusCode": "202",
          "description": "LimitRange sets resource usage limits for each kind of resource in a Namespace."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/limitranges/{name}",
      "method": "deleteCoreV1NamespacedLimitRange",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete a LimitRange",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/limitranges/{name}",
      "method": "readCoreV1NamespacedLimitRange",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read the specified LimitRange",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "LimitRange sets resource usage limits for each kind of resource in a Namespace."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/limitranges/{name}",
      "method": "patchCoreV1NamespacedLimitRange",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update the specified LimitRange",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "LimitRange sets resource usage limits for each kind of resource in a Namespace."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/limitranges/{name}",
      "method": "replaceCoreV1NamespacedLimitRange",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace the specified LimitRange",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "LimitRange sets resource usage limits for each kind of resource in a Namespace."
        },
        {
          "statusCode": "201",
          "description": "LimitRange sets resource usage limits for each kind of resource in a Namespace."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/persistentvolumeclaims",
      "method": "deleteCoreV1CollectionNamespacedPersistentVolumeClaim",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete collection of PersistentVolumeClaim",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/persistentvolumeclaims",
      "method": "listCoreV1NamespacedPersistentVolumeClaim",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind PersistentVolumeClaim",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeClaimList is a list of PersistentVolumeClaim items."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/persistentvolumeclaims",
      "method": "createCoreV1NamespacedPersistentVolumeClaim",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "create a PersistentVolumeClaim",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        },
        {
          "statusCode": "201",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        },
        {
          "statusCode": "202",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}",
      "method": "deleteCoreV1NamespacedPersistentVolumeClaim",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete a PersistentVolumeClaim",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}",
      "method": "readCoreV1NamespacedPersistentVolumeClaim",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read the specified PersistentVolumeClaim",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}",
      "method": "patchCoreV1NamespacedPersistentVolumeClaim",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update the specified PersistentVolumeClaim",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}",
      "method": "replaceCoreV1NamespacedPersistentVolumeClaim",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace the specified PersistentVolumeClaim",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        },
        {
          "statusCode": "201",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status",
      "method": "readCoreV1NamespacedPersistentVolumeClaimStatus",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read status of the specified PersistentVolumeClaim",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status",
      "method": "patchCoreV1NamespacedPersistentVolumeClaimStatus",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update status of the specified PersistentVolumeClaim",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status",
      "method": "replaceCoreV1NamespacedPersistentVolumeClaimStatus",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace status of the specified PersistentVolumeClaim",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        },
        {
          "statusCode": "201",
          "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods",
      "method": "deleteCoreV1CollectionNamespacedPod",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete collection of Pod",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods",
      "method": "listCoreV1NamespacedPod",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind Pod",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodList is a list of Pods."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods",
      "method": "createCoreV1NamespacedPod",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "create a Pod",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        },
        {
          "statusCode": "201",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        },
        {
          "statusCode": "202",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}",
      "method": "deleteCoreV1NamespacedPod",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete a Pod",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}",
      "method": "readCoreV1NamespacedPod",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read the specified Pod",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}",
      "method": "patchCoreV1NamespacedPod",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update the specified Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}",
      "method": "replaceCoreV1NamespacedPod",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace the specified Pod",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        },
        {
          "statusCode": "201",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/attach",
      "method": "connectCoreV1GetNamespacedPodAttach",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect GET requests to attach of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/attach",
      "method": "connectCoreV1PostNamespacedPodAttach",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect POST requests to attach of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/binding",
      "method": "createCoreV1NamespacedPodBinding",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "create binding of a Pod",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "target",
          "schema": "undefined",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Binding ties one object to another; for example, a pod is bound to a node by a scheduler. Deprecated in 1.7, please use the bindings subresource of pods instead."
        },
        {
          "statusCode": "201",
          "description": "Binding ties one object to another; for example, a pod is bound to a node by a scheduler. Deprecated in 1.7, please use the bindings subresource of pods instead."
        },
        {
          "statusCode": "202",
          "description": "Binding ties one object to another; for example, a pod is bound to a node by a scheduler. Deprecated in 1.7, please use the bindings subresource of pods instead."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/eviction",
      "method": "createCoreV1NamespacedPodEviction",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "create eviction of a Pod",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "deleteOptions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Eviction evicts a pod from its node subject to certain policies and safety constraints. This is a subresource of Pod.  A request to cause such an eviction is created by POSTing to .../pods/<pod name>/evictions."
        },
        {
          "statusCode": "201",
          "description": "Eviction evicts a pod from its node subject to certain policies and safety constraints. This is a subresource of Pod.  A request to cause such an eviction is created by POSTing to .../pods/<pod name>/evictions."
        },
        {
          "statusCode": "202",
          "description": "Eviction evicts a pod from its node subject to certain policies and safety constraints. This is a subresource of Pod.  A request to cause such an eviction is created by POSTing to .../pods/<pod name>/evictions."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/exec",
      "method": "connectCoreV1GetNamespacedPodExec",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect GET requests to exec of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/exec",
      "method": "connectCoreV1PostNamespacedPodExec",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect POST requests to exec of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/log",
      "method": "readCoreV1NamespacedPodLog",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read log of the specified Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/portforward",
      "method": "connectCoreV1GetNamespacedPodPortforward",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect GET requests to portforward of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/portforward",
      "method": "connectCoreV1PostNamespacedPodPortforward",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect POST requests to portforward of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy",
      "method": "connectCoreV1DeleteNamespacedPodProxy",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect DELETE requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy",
      "method": "connectCoreV1GetNamespacedPodProxy",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect GET requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy",
      "method": "connectCoreV1HeadNamespacedPodProxy",
      "httpMethod": "head",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect HEAD requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy",
      "method": "connectCoreV1OptionsNamespacedPodProxy",
      "httpMethod": "options",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect OPTIONS requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy",
      "method": "connectCoreV1PatchNamespacedPodProxy",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect PATCH requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy",
      "method": "connectCoreV1PostNamespacedPodProxy",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect POST requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy",
      "method": "connectCoreV1PutNamespacedPodProxy",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect PUT requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}",
      "method": "connectCoreV1DeleteNamespacedPodProxyWithPath",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect DELETE requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}",
      "method": "connectCoreV1GetNamespacedPodProxyWithPath",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect GET requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}",
      "method": "connectCoreV1HeadNamespacedPodProxyWithPath",
      "httpMethod": "head",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect HEAD requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}",
      "method": "connectCoreV1OptionsNamespacedPodProxyWithPath",
      "httpMethod": "options",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect OPTIONS requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}",
      "method": "connectCoreV1PatchNamespacedPodProxyWithPath",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect PATCH requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}",
      "method": "connectCoreV1PostNamespacedPodProxyWithPath",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect POST requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}",
      "method": "connectCoreV1PutNamespacedPodProxyWithPath",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect PUT requests to proxy of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/status",
      "method": "readCoreV1NamespacedPodStatus",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read status of the specified Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/status",
      "method": "patchCoreV1NamespacedPodStatus",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update status of the specified Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/pods/{name}/status",
      "method": "replaceCoreV1NamespacedPodStatus",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace status of the specified Pod",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        },
        {
          "statusCode": "201",
          "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/podtemplates",
      "method": "deleteCoreV1CollectionNamespacedPodTemplate",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete collection of PodTemplate",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/podtemplates",
      "method": "listCoreV1NamespacedPodTemplate",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind PodTemplate",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodTemplateList is a list of PodTemplates."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/podtemplates",
      "method": "createCoreV1NamespacedPodTemplate",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "create a PodTemplate",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "template",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodTemplate describes a template for creating copies of a predefined pod."
        },
        {
          "statusCode": "201",
          "description": "PodTemplate describes a template for creating copies of a predefined pod."
        },
        {
          "statusCode": "202",
          "description": "PodTemplate describes a template for creating copies of a predefined pod."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/podtemplates/{name}",
      "method": "deleteCoreV1NamespacedPodTemplate",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete a PodTemplate",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/podtemplates/{name}",
      "method": "readCoreV1NamespacedPodTemplate",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read the specified PodTemplate",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodTemplate describes a template for creating copies of a predefined pod."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/podtemplates/{name}",
      "method": "patchCoreV1NamespacedPodTemplate",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update the specified PodTemplate",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodTemplate describes a template for creating copies of a predefined pod."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/podtemplates/{name}",
      "method": "replaceCoreV1NamespacedPodTemplate",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace the specified PodTemplate",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "template",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodTemplate describes a template for creating copies of a predefined pod."
        },
        {
          "statusCode": "201",
          "description": "PodTemplate describes a template for creating copies of a predefined pod."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers",
      "method": "deleteCoreV1CollectionNamespacedReplicationController",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete collection of ReplicationController",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers",
      "method": "listCoreV1NamespacedReplicationController",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind ReplicationController",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicationControllerList is a collection of replication controllers."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers",
      "method": "createCoreV1NamespacedReplicationController",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "create a ReplicationController",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicationController represents the configuration of a replication controller."
        },
        {
          "statusCode": "201",
          "description": "ReplicationController represents the configuration of a replication controller."
        },
        {
          "statusCode": "202",
          "description": "ReplicationController represents the configuration of a replication controller."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}",
      "method": "deleteCoreV1NamespacedReplicationController",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete a ReplicationController",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}",
      "method": "readCoreV1NamespacedReplicationController",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read the specified ReplicationController",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicationController represents the configuration of a replication controller."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}",
      "method": "patchCoreV1NamespacedReplicationController",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update the specified ReplicationController",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicationController represents the configuration of a replication controller."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}",
      "method": "replaceCoreV1NamespacedReplicationController",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace the specified ReplicationController",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicationController represents the configuration of a replication controller."
        },
        {
          "statusCode": "201",
          "description": "ReplicationController represents the configuration of a replication controller."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale",
      "method": "readCoreV1NamespacedReplicationControllerScale",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read scale of the specified ReplicationController",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale",
      "method": "patchCoreV1NamespacedReplicationControllerScale",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update scale of the specified ReplicationController",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale",
      "method": "replaceCoreV1NamespacedReplicationControllerScale",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace scale of the specified ReplicationController",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        },
        {
          "statusCode": "201",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status",
      "method": "readCoreV1NamespacedReplicationControllerStatus",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read status of the specified ReplicationController",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicationController represents the configuration of a replication controller."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status",
      "method": "patchCoreV1NamespacedReplicationControllerStatus",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update status of the specified ReplicationController",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicationController represents the configuration of a replication controller."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status",
      "method": "replaceCoreV1NamespacedReplicationControllerStatus",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace status of the specified ReplicationController",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicationController represents the configuration of a replication controller."
        },
        {
          "statusCode": "201",
          "description": "ReplicationController represents the configuration of a replication controller."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/resourcequotas",
      "method": "deleteCoreV1CollectionNamespacedResourceQuota",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete collection of ResourceQuota",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/resourcequotas",
      "method": "listCoreV1NamespacedResourceQuota",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind ResourceQuota",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceQuotaList is a list of ResourceQuota items."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/resourcequotas",
      "method": "createCoreV1NamespacedResourceQuota",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "create a ResourceQuota",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        },
        {
          "statusCode": "201",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        },
        {
          "statusCode": "202",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/resourcequotas/{name}",
      "method": "deleteCoreV1NamespacedResourceQuota",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete a ResourceQuota",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/resourcequotas/{name}",
      "method": "readCoreV1NamespacedResourceQuota",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read the specified ResourceQuota",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/resourcequotas/{name}",
      "method": "patchCoreV1NamespacedResourceQuota",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update the specified ResourceQuota",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/resourcequotas/{name}",
      "method": "replaceCoreV1NamespacedResourceQuota",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace the specified ResourceQuota",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        },
        {
          "statusCode": "201",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status",
      "method": "readCoreV1NamespacedResourceQuotaStatus",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read status of the specified ResourceQuota",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status",
      "method": "patchCoreV1NamespacedResourceQuotaStatus",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update status of the specified ResourceQuota",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status",
      "method": "replaceCoreV1NamespacedResourceQuotaStatus",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace status of the specified ResourceQuota",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        },
        {
          "statusCode": "201",
          "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/secrets",
      "method": "deleteCoreV1CollectionNamespacedSecret",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete collection of Secret",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/secrets",
      "method": "listCoreV1NamespacedSecret",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind Secret",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "SecretList is a list of Secret."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/secrets",
      "method": "createCoreV1NamespacedSecret",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "create a Secret",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "data",
          "schema": "object",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "stringData",
          "schema": "object",
          "description": ""
        },
        {
          "name": "type",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes."
        },
        {
          "statusCode": "201",
          "description": "Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes."
        },
        {
          "statusCode": "202",
          "description": "Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/secrets/{name}",
      "method": "deleteCoreV1NamespacedSecret",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete a Secret",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/secrets/{name}",
      "method": "readCoreV1NamespacedSecret",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read the specified Secret",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/secrets/{name}",
      "method": "patchCoreV1NamespacedSecret",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update the specified Secret",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/secrets/{name}",
      "method": "replaceCoreV1NamespacedSecret",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace the specified Secret",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "data",
          "schema": "object",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "stringData",
          "schema": "object",
          "description": ""
        },
        {
          "name": "type",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes."
        },
        {
          "statusCode": "201",
          "description": "Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/serviceaccounts",
      "method": "deleteCoreV1CollectionNamespacedServiceAccount",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete collection of ServiceAccount",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/serviceaccounts",
      "method": "listCoreV1NamespacedServiceAccount",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind ServiceAccount",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ServiceAccountList is a list of ServiceAccount objects"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/serviceaccounts",
      "method": "createCoreV1NamespacedServiceAccount",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "create a ServiceAccount",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "automountServiceAccountToken",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "imagePullSecrets",
          "schema": "array",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "secrets",
          "schema": "array",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets"
        },
        {
          "statusCode": "201",
          "description": "ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets"
        },
        {
          "statusCode": "202",
          "description": "ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/serviceaccounts/{name}",
      "method": "deleteCoreV1NamespacedServiceAccount",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete a ServiceAccount",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/serviceaccounts/{name}",
      "method": "readCoreV1NamespacedServiceAccount",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read the specified ServiceAccount",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/serviceaccounts/{name}",
      "method": "patchCoreV1NamespacedServiceAccount",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update the specified ServiceAccount",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/serviceaccounts/{name}",
      "method": "replaceCoreV1NamespacedServiceAccount",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace the specified ServiceAccount",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "automountServiceAccountToken",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "imagePullSecrets",
          "schema": "array",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "secrets",
          "schema": "array",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets"
        },
        {
          "statusCode": "201",
          "description": "ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets"
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services",
      "method": "listCoreV1NamespacedService",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind Service",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ServiceList holds a list of services."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services",
      "method": "createCoreV1NamespacedService",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "create a Service",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        },
        {
          "statusCode": "201",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        },
        {
          "statusCode": "202",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}",
      "method": "deleteCoreV1NamespacedService",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete a Service",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}",
      "method": "readCoreV1NamespacedService",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read the specified Service",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}",
      "method": "patchCoreV1NamespacedService",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update the specified Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}",
      "method": "replaceCoreV1NamespacedService",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace the specified Service",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        },
        {
          "statusCode": "201",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy",
      "method": "connectCoreV1DeleteNamespacedServiceProxy",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect DELETE requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy",
      "method": "connectCoreV1GetNamespacedServiceProxy",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect GET requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy",
      "method": "connectCoreV1HeadNamespacedServiceProxy",
      "httpMethod": "head",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect HEAD requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy",
      "method": "connectCoreV1OptionsNamespacedServiceProxy",
      "httpMethod": "options",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect OPTIONS requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy",
      "method": "connectCoreV1PatchNamespacedServiceProxy",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect PATCH requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy",
      "method": "connectCoreV1PostNamespacedServiceProxy",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect POST requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy",
      "method": "connectCoreV1PutNamespacedServiceProxy",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect PUT requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}",
      "method": "connectCoreV1DeleteNamespacedServiceProxyWithPath",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect DELETE requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}",
      "method": "connectCoreV1GetNamespacedServiceProxyWithPath",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect GET requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}",
      "method": "connectCoreV1HeadNamespacedServiceProxyWithPath",
      "httpMethod": "head",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect HEAD requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}",
      "method": "connectCoreV1OptionsNamespacedServiceProxyWithPath",
      "httpMethod": "options",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect OPTIONS requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}",
      "method": "connectCoreV1PatchNamespacedServiceProxyWithPath",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect PATCH requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}",
      "method": "connectCoreV1PostNamespacedServiceProxyWithPath",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect POST requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}",
      "method": "connectCoreV1PutNamespacedServiceProxyWithPath",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect PUT requests to proxy of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/status",
      "method": "readCoreV1NamespacedServiceStatus",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read status of the specified Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/status",
      "method": "patchCoreV1NamespacedServiceStatus",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update status of the specified Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{namespace}/services/{name}/status",
      "method": "replaceCoreV1NamespacedServiceStatus",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace status of the specified Service",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        },
        {
          "statusCode": "201",
          "description": "Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{name}",
      "method": "deleteCoreV1Namespace",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete a Namespace",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{name}",
      "method": "readCoreV1Namespace",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read the specified Namespace",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{name}",
      "method": "patchCoreV1Namespace",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update the specified Namespace",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{name}",
      "method": "replaceCoreV1Namespace",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace the specified Namespace",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        },
        {
          "statusCode": "201",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{name}/finalize",
      "method": "replaceCoreV1NamespaceFinalize",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace finalize of the specified Namespace",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        },
        {
          "statusCode": "201",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{name}/status",
      "method": "readCoreV1NamespaceStatus",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read status of the specified Namespace",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{name}/status",
      "method": "patchCoreV1NamespaceStatus",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update status of the specified Namespace",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        }
      ]
    },
    {
      "url": "/api/v1/namespaces/{name}/status",
      "method": "replaceCoreV1NamespaceStatus",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace status of the specified Namespace",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        },
        {
          "statusCode": "201",
          "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional."
        }
      ]
    },
    {
      "url": "/api/v1/nodes",
      "method": "deleteCoreV1CollectionNode",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete collection of Node",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/nodes",
      "method": "listCoreV1Node",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind Node",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "NodeList is the whole list of all Nodes which have been registered with master."
        }
      ]
    },
    {
      "url": "/api/v1/nodes",
      "method": "createCoreV1Node",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "create a Node",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        },
        {
          "statusCode": "201",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        },
        {
          "statusCode": "202",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}",
      "method": "deleteCoreV1Node",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete a Node",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}",
      "method": "readCoreV1Node",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read the specified Node",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}",
      "method": "patchCoreV1Node",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update the specified Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}",
      "method": "replaceCoreV1Node",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace the specified Node",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        },
        {
          "statusCode": "201",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy",
      "method": "connectCoreV1DeleteNodeProxy",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect DELETE requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy",
      "method": "connectCoreV1GetNodeProxy",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect GET requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy",
      "method": "connectCoreV1HeadNodeProxy",
      "httpMethod": "head",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect HEAD requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy",
      "method": "connectCoreV1OptionsNodeProxy",
      "httpMethod": "options",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect OPTIONS requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy",
      "method": "connectCoreV1PatchNodeProxy",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect PATCH requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy",
      "method": "connectCoreV1PostNodeProxy",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect POST requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy",
      "method": "connectCoreV1PutNodeProxy",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect PUT requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy/{path}",
      "method": "connectCoreV1DeleteNodeProxyWithPath",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect DELETE requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy/{path}",
      "method": "connectCoreV1GetNodeProxyWithPath",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect GET requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy/{path}",
      "method": "connectCoreV1HeadNodeProxyWithPath",
      "httpMethod": "head",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect HEAD requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy/{path}",
      "method": "connectCoreV1OptionsNodeProxyWithPath",
      "httpMethod": "options",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect OPTIONS requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy/{path}",
      "method": "connectCoreV1PatchNodeProxyWithPath",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect PATCH requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy/{path}",
      "method": "connectCoreV1PostNodeProxyWithPath",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect POST requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/proxy/{path}",
      "method": "connectCoreV1PutNodeProxyWithPath",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "connect PUT requests to proxy of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/status",
      "method": "readCoreV1NodeStatus",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read status of the specified Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/status",
      "method": "patchCoreV1NodeStatus",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update status of the specified Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        }
      ]
    },
    {
      "url": "/api/v1/nodes/{name}/status",
      "method": "replaceCoreV1NodeStatus",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace status of the specified Node",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        },
        {
          "statusCode": "201",
          "description": "Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd)."
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumeclaims",
      "method": "listCoreV1PersistentVolumeClaimForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind PersistentVolumeClaim",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeClaimList is a list of PersistentVolumeClaim items."
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumes",
      "method": "deleteCoreV1CollectionPersistentVolume",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete collection of PersistentVolume",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumes",
      "method": "listCoreV1PersistentVolume",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind PersistentVolume",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolumeList is a list of PersistentVolume items."
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumes",
      "method": "createCoreV1PersistentVolume",
      "httpMethod": "post",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "create a PersistentVolume",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        },
        {
          "statusCode": "201",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        },
        {
          "statusCode": "202",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumes/{name}",
      "method": "deleteCoreV1PersistentVolume",
      "httpMethod": "delete",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "delete a PersistentVolume",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumes/{name}",
      "method": "readCoreV1PersistentVolume",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read the specified PersistentVolume",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumes/{name}",
      "method": "patchCoreV1PersistentVolume",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update the specified PersistentVolume",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumes/{name}",
      "method": "replaceCoreV1PersistentVolume",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace the specified PersistentVolume",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        },
        {
          "statusCode": "201",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumes/{name}/status",
      "method": "readCoreV1PersistentVolumeStatus",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "read status of the specified PersistentVolume",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumes/{name}/status",
      "method": "patchCoreV1PersistentVolumeStatus",
      "httpMethod": "patch",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "partially update status of the specified PersistentVolume",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        }
      ]
    },
    {
      "url": "/api/v1/persistentvolumes/{name}/status",
      "method": "replaceCoreV1PersistentVolumeStatus",
      "httpMethod": "put",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "replace status of the specified PersistentVolume",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        },
        {
          "statusCode": "201",
          "description": "PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
        }
      ]
    },
    {
      "url": "/api/v1/pods",
      "method": "listCoreV1PodForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodList is a list of Pods."
        }
      ]
    },
    {
      "url": "/api/v1/podtemplates",
      "method": "listCoreV1PodTemplateForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind PodTemplate",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodTemplateList is a list of PodTemplates."
        }
      ]
    },
    {
      "url": "/api/v1/replicationcontrollers",
      "method": "listCoreV1ReplicationControllerForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind ReplicationController",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicationControllerList is a collection of replication controllers."
        }
      ]
    },
    {
      "url": "/api/v1/resourcequotas",
      "method": "listCoreV1ResourceQuotaForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind ResourceQuota",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ResourceQuotaList is a list of ResourceQuota items."
        }
      ]
    },
    {
      "url": "/api/v1/secrets",
      "method": "listCoreV1SecretForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind Secret",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "SecretList is a list of Secret."
        }
      ]
    },
    {
      "url": "/api/v1/serviceaccounts",
      "method": "listCoreV1ServiceAccountForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind ServiceAccount",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ServiceAccountList is a list of ServiceAccount objects"
        }
      ]
    },
    {
      "url": "/api/v1/services",
      "method": "listCoreV1ServiceForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "list or watch objects of kind Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ServiceList holds a list of services."
        }
      ]
    },
    {
      "url": "/api/v1/watch/configmaps",
      "method": "watchCoreV1ConfigMapListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of ConfigMap",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/endpoints",
      "method": "watchCoreV1EndpointsListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of Endpoints",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/events",
      "method": "watchCoreV1EventListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of Event",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/limitranges",
      "method": "watchCoreV1LimitRangeListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of LimitRange",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces",
      "method": "watchCoreV1NamespaceList",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of Namespace",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/configmaps",
      "method": "watchCoreV1NamespacedConfigMapList",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of ConfigMap",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/configmaps/{name}",
      "method": "watchCoreV1NamespacedConfigMap",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch changes to an object of kind ConfigMap",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/endpoints",
      "method": "watchCoreV1NamespacedEndpointsList",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of Endpoints",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/endpoints/{name}",
      "method": "watchCoreV1NamespacedEndpoints",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch changes to an object of kind Endpoints",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/events",
      "method": "watchCoreV1NamespacedEventList",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of Event",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/events/{name}",
      "method": "watchCoreV1NamespacedEvent",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch changes to an object of kind Event",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/limitranges",
      "method": "watchCoreV1NamespacedLimitRangeList",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of LimitRange",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/limitranges/{name}",
      "method": "watchCoreV1NamespacedLimitRange",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch changes to an object of kind LimitRange",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims",
      "method": "watchCoreV1NamespacedPersistentVolumeClaimList",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of PersistentVolumeClaim",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims/{name}",
      "method": "watchCoreV1NamespacedPersistentVolumeClaim",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch changes to an object of kind PersistentVolumeClaim",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/pods",
      "method": "watchCoreV1NamespacedPodList",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/pods/{name}",
      "method": "watchCoreV1NamespacedPod",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch changes to an object of kind Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/podtemplates",
      "method": "watchCoreV1NamespacedPodTemplateList",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of PodTemplate",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/podtemplates/{name}",
      "method": "watchCoreV1NamespacedPodTemplate",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch changes to an object of kind PodTemplate",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/replicationcontrollers",
      "method": "watchCoreV1NamespacedReplicationControllerList",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of ReplicationController",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/replicationcontrollers/{name}",
      "method": "watchCoreV1NamespacedReplicationController",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch changes to an object of kind ReplicationController",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/resourcequotas",
      "method": "watchCoreV1NamespacedResourceQuotaList",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of ResourceQuota",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/resourcequotas/{name}",
      "method": "watchCoreV1NamespacedResourceQuota",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch changes to an object of kind ResourceQuota",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/secrets",
      "method": "watchCoreV1NamespacedSecretList",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of Secret",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/secrets/{name}",
      "method": "watchCoreV1NamespacedSecret",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch changes to an object of kind Secret",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/serviceaccounts",
      "method": "watchCoreV1NamespacedServiceAccountList",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of ServiceAccount",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/serviceaccounts/{name}",
      "method": "watchCoreV1NamespacedServiceAccount",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch changes to an object of kind ServiceAccount",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/services",
      "method": "watchCoreV1NamespacedServiceList",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{namespace}/services/{name}",
      "method": "watchCoreV1NamespacedService",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch changes to an object of kind Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/namespaces/{name}",
      "method": "watchCoreV1Namespace",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch changes to an object of kind Namespace",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/nodes",
      "method": "watchCoreV1NodeList",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/nodes/{name}",
      "method": "watchCoreV1Node",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch changes to an object of kind Node",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/persistentvolumeclaims",
      "method": "watchCoreV1PersistentVolumeClaimListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of PersistentVolumeClaim",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/persistentvolumes",
      "method": "watchCoreV1PersistentVolumeList",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of PersistentVolume",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/persistentvolumes/{name}",
      "method": "watchCoreV1PersistentVolume",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch changes to an object of kind PersistentVolume",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/pods",
      "method": "watchCoreV1PodListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of Pod",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/podtemplates",
      "method": "watchCoreV1PodTemplateListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of PodTemplate",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/replicationcontrollers",
      "method": "watchCoreV1ReplicationControllerListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of ReplicationController",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/resourcequotas",
      "method": "watchCoreV1ResourceQuotaListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of ResourceQuota",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/secrets",
      "method": "watchCoreV1SecretListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of Secret",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/serviceaccounts",
      "method": "watchCoreV1ServiceAccountListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of ServiceAccount",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/api/v1/watch/services",
      "method": "watchCoreV1ServiceListForAllNamespaces",
      "httpMethod": "get",
      "tag": "core_v1",
      "typeScriptTag": "coreV1",
      "description": "watch individual changes to a list of Service",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/",
      "method": "getApiVersions",
      "httpMethod": "get",
      "tag": "apis",
      "typeScriptTag": "apis",
      "description": "get available API versions",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroupList is a list of APIGroup, to allow clients to discover the API at /apis."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/",
      "method": "getAdmissionregistrationApiGroup",
      "httpMethod": "get",
      "tag": "admissionregistration",
      "typeScriptTag": "admissionregistration",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/",
      "method": "getAdmissionregistrationV1Alpha1ApiResources",
      "httpMethod": "get",
      "tag": "admissionregistration_v1alpha1",
      "typeScriptTag": "admissionregistrationV1Alpha1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations",
      "method": "deleteAdmissionregistrationV1Alpha1CollectionInitializerConfiguration",
      "httpMethod": "delete",
      "tag": "admissionregistration_v1alpha1",
      "typeScriptTag": "admissionregistrationV1Alpha1",
      "description": "delete collection of InitializerConfiguration",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations",
      "method": "listAdmissionregistrationV1Alpha1InitializerConfiguration",
      "httpMethod": "get",
      "tag": "admissionregistration_v1alpha1",
      "typeScriptTag": "admissionregistrationV1Alpha1",
      "description": "list or watch objects of kind InitializerConfiguration",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "InitializerConfigurationList is a list of InitializerConfiguration."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations",
      "method": "createAdmissionregistrationV1Alpha1InitializerConfiguration",
      "httpMethod": "post",
      "tag": "admissionregistration_v1alpha1",
      "typeScriptTag": "admissionregistrationV1Alpha1",
      "description": "create an InitializerConfiguration",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "initializers",
          "schema": "array",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "InitializerConfiguration describes the configuration of initializers."
        },
        {
          "statusCode": "201",
          "description": "InitializerConfiguration describes the configuration of initializers."
        },
        {
          "statusCode": "202",
          "description": "InitializerConfiguration describes the configuration of initializers."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations/{name}",
      "method": "deleteAdmissionregistrationV1Alpha1InitializerConfiguration",
      "httpMethod": "delete",
      "tag": "admissionregistration_v1alpha1",
      "typeScriptTag": "admissionregistrationV1Alpha1",
      "description": "delete an InitializerConfiguration",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations/{name}",
      "method": "readAdmissionregistrationV1Alpha1InitializerConfiguration",
      "httpMethod": "get",
      "tag": "admissionregistration_v1alpha1",
      "typeScriptTag": "admissionregistrationV1Alpha1",
      "description": "read the specified InitializerConfiguration",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "InitializerConfiguration describes the configuration of initializers."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations/{name}",
      "method": "patchAdmissionregistrationV1Alpha1InitializerConfiguration",
      "httpMethod": "patch",
      "tag": "admissionregistration_v1alpha1",
      "typeScriptTag": "admissionregistrationV1Alpha1",
      "description": "partially update the specified InitializerConfiguration",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "InitializerConfiguration describes the configuration of initializers."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations/{name}",
      "method": "replaceAdmissionregistrationV1Alpha1InitializerConfiguration",
      "httpMethod": "put",
      "tag": "admissionregistration_v1alpha1",
      "typeScriptTag": "admissionregistrationV1Alpha1",
      "description": "replace the specified InitializerConfiguration",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "initializers",
          "schema": "array",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "InitializerConfiguration describes the configuration of initializers."
        },
        {
          "statusCode": "201",
          "description": "InitializerConfiguration describes the configuration of initializers."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/watch/initializerconfigurations",
      "method": "watchAdmissionregistrationV1Alpha1InitializerConfigurationList",
      "httpMethod": "get",
      "tag": "admissionregistration_v1alpha1",
      "typeScriptTag": "admissionregistrationV1Alpha1",
      "description": "watch individual changes to a list of InitializerConfiguration",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1alpha1/watch/initializerconfigurations/{name}",
      "method": "watchAdmissionregistrationV1Alpha1InitializerConfiguration",
      "httpMethod": "get",
      "tag": "admissionregistration_v1alpha1",
      "typeScriptTag": "admissionregistrationV1Alpha1",
      "description": "watch changes to an object of kind InitializerConfiguration",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1beta1/",
      "method": "getAdmissionregistrationV1Beta1ApiResources",
      "httpMethod": "get",
      "tag": "admissionregistration_v1beta1",
      "typeScriptTag": "admissionregistrationV1Beta1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations",
      "method": "deleteAdmissionregistrationV1Beta1CollectionMutatingWebhookConfiguration",
      "httpMethod": "delete",
      "tag": "admissionregistration_v1beta1",
      "typeScriptTag": "admissionregistrationV1Beta1",
      "description": "delete collection of MutatingWebhookConfiguration",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations",
      "method": "listAdmissionregistrationV1Beta1MutatingWebhookConfiguration",
      "httpMethod": "get",
      "tag": "admissionregistration_v1beta1",
      "typeScriptTag": "admissionregistrationV1Beta1",
      "description": "list or watch objects of kind MutatingWebhookConfiguration",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations",
      "method": "createAdmissionregistrationV1Beta1MutatingWebhookConfiguration",
      "httpMethod": "post",
      "tag": "admissionregistration_v1beta1",
      "typeScriptTag": "admissionregistrationV1Beta1",
      "description": "create a MutatingWebhookConfiguration",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "webhooks",
          "schema": "array",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object."
        },
        {
          "statusCode": "201",
          "description": "MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object."
        },
        {
          "statusCode": "202",
          "description": "MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/{name}",
      "method": "deleteAdmissionregistrationV1Beta1MutatingWebhookConfiguration",
      "httpMethod": "delete",
      "tag": "admissionregistration_v1beta1",
      "typeScriptTag": "admissionregistrationV1Beta1",
      "description": "delete a MutatingWebhookConfiguration",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/{name}",
      "method": "readAdmissionregistrationV1Beta1MutatingWebhookConfiguration",
      "httpMethod": "get",
      "tag": "admissionregistration_v1beta1",
      "typeScriptTag": "admissionregistrationV1Beta1",
      "description": "read the specified MutatingWebhookConfiguration",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/{name}",
      "method": "patchAdmissionregistrationV1Beta1MutatingWebhookConfiguration",
      "httpMethod": "patch",
      "tag": "admissionregistration_v1beta1",
      "typeScriptTag": "admissionregistrationV1Beta1",
      "description": "partially update the specified MutatingWebhookConfiguration",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/{name}",
      "method": "replaceAdmissionregistrationV1Beta1MutatingWebhookConfiguration",
      "httpMethod": "put",
      "tag": "admissionregistration_v1beta1",
      "typeScriptTag": "admissionregistrationV1Beta1",
      "description": "replace the specified MutatingWebhookConfiguration",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "webhooks",
          "schema": "array",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object."
        },
        {
          "statusCode": "201",
          "description": "MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations",
      "method": "deleteAdmissionregistrationV1Beta1CollectionValidatingWebhookConfiguration",
      "httpMethod": "delete",
      "tag": "admissionregistration_v1beta1",
      "typeScriptTag": "admissionregistrationV1Beta1",
      "description": "delete collection of ValidatingWebhookConfiguration",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations",
      "method": "listAdmissionregistrationV1Beta1ValidatingWebhookConfiguration",
      "httpMethod": "get",
      "tag": "admissionregistration_v1beta1",
      "typeScriptTag": "admissionregistrationV1Beta1",
      "description": "list or watch objects of kind ValidatingWebhookConfiguration",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations",
      "method": "createAdmissionregistrationV1Beta1ValidatingWebhookConfiguration",
      "httpMethod": "post",
      "tag": "admissionregistration_v1beta1",
      "typeScriptTag": "admissionregistrationV1Beta1",
      "description": "create a ValidatingWebhookConfiguration",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "webhooks",
          "schema": "array",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it."
        },
        {
          "statusCode": "201",
          "description": "ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it."
        },
        {
          "statusCode": "202",
          "description": "ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/{name}",
      "method": "deleteAdmissionregistrationV1Beta1ValidatingWebhookConfiguration",
      "httpMethod": "delete",
      "tag": "admissionregistration_v1beta1",
      "typeScriptTag": "admissionregistrationV1Beta1",
      "description": "delete a ValidatingWebhookConfiguration",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/{name}",
      "method": "readAdmissionregistrationV1Beta1ValidatingWebhookConfiguration",
      "httpMethod": "get",
      "tag": "admissionregistration_v1beta1",
      "typeScriptTag": "admissionregistrationV1Beta1",
      "description": "read the specified ValidatingWebhookConfiguration",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/{name}",
      "method": "patchAdmissionregistrationV1Beta1ValidatingWebhookConfiguration",
      "httpMethod": "patch",
      "tag": "admissionregistration_v1beta1",
      "typeScriptTag": "admissionregistrationV1Beta1",
      "description": "partially update the specified ValidatingWebhookConfiguration",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/{name}",
      "method": "replaceAdmissionregistrationV1Beta1ValidatingWebhookConfiguration",
      "httpMethod": "put",
      "tag": "admissionregistration_v1beta1",
      "typeScriptTag": "admissionregistrationV1Beta1",
      "description": "replace the specified ValidatingWebhookConfiguration",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "webhooks",
          "schema": "array",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it."
        },
        {
          "statusCode": "201",
          "description": "ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1beta1/watch/mutatingwebhookconfigurations",
      "method": "watchAdmissionregistrationV1Beta1MutatingWebhookConfigurationList",
      "httpMethod": "get",
      "tag": "admissionregistration_v1beta1",
      "typeScriptTag": "admissionregistrationV1Beta1",
      "description": "watch individual changes to a list of MutatingWebhookConfiguration",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1beta1/watch/mutatingwebhookconfigurations/{name}",
      "method": "watchAdmissionregistrationV1Beta1MutatingWebhookConfiguration",
      "httpMethod": "get",
      "tag": "admissionregistration_v1beta1",
      "typeScriptTag": "admissionregistrationV1Beta1",
      "description": "watch changes to an object of kind MutatingWebhookConfiguration",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1beta1/watch/validatingwebhookconfigurations",
      "method": "watchAdmissionregistrationV1Beta1ValidatingWebhookConfigurationList",
      "httpMethod": "get",
      "tag": "admissionregistration_v1beta1",
      "typeScriptTag": "admissionregistrationV1Beta1",
      "description": "watch individual changes to a list of ValidatingWebhookConfiguration",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/admissionregistration.k8s.io/v1beta1/watch/validatingwebhookconfigurations/{name}",
      "method": "watchAdmissionregistrationV1Beta1ValidatingWebhookConfiguration",
      "httpMethod": "get",
      "tag": "admissionregistration_v1beta1",
      "typeScriptTag": "admissionregistrationV1Beta1",
      "description": "watch changes to an object of kind ValidatingWebhookConfiguration",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/",
      "method": "getApiextensionsApiGroup",
      "httpMethod": "get",
      "tag": "apiextensions",
      "typeScriptTag": "apiextensions",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1beta1/",
      "method": "getApiextensionsV1Beta1ApiResources",
      "httpMethod": "get",
      "tag": "apiextensions_v1beta1",
      "typeScriptTag": "apiextensionsV1Beta1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions",
      "method": "deleteApiextensionsV1Beta1CollectionCustomResourceDefinition",
      "httpMethod": "delete",
      "tag": "apiextensions_v1beta1",
      "typeScriptTag": "apiextensionsV1Beta1",
      "description": "delete collection of CustomResourceDefinition",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions",
      "method": "listApiextensionsV1Beta1CustomResourceDefinition",
      "httpMethod": "get",
      "tag": "apiextensions_v1beta1",
      "typeScriptTag": "apiextensionsV1Beta1",
      "description": "list or watch objects of kind CustomResourceDefinition",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CustomResourceDefinitionList is a list of CustomResourceDefinition objects."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions",
      "method": "createApiextensionsV1Beta1CustomResourceDefinition",
      "httpMethod": "post",
      "tag": "apiextensions_v1beta1",
      "typeScriptTag": "apiextensionsV1Beta1",
      "description": "create a CustomResourceDefinition",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        },
        {
          "statusCode": "201",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        },
        {
          "statusCode": "202",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}",
      "method": "deleteApiextensionsV1Beta1CustomResourceDefinition",
      "httpMethod": "delete",
      "tag": "apiextensions_v1beta1",
      "typeScriptTag": "apiextensionsV1Beta1",
      "description": "delete a CustomResourceDefinition",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}",
      "method": "readApiextensionsV1Beta1CustomResourceDefinition",
      "httpMethod": "get",
      "tag": "apiextensions_v1beta1",
      "typeScriptTag": "apiextensionsV1Beta1",
      "description": "read the specified CustomResourceDefinition",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}",
      "method": "patchApiextensionsV1Beta1CustomResourceDefinition",
      "httpMethod": "patch",
      "tag": "apiextensions_v1beta1",
      "typeScriptTag": "apiextensionsV1Beta1",
      "description": "partially update the specified CustomResourceDefinition",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}",
      "method": "replaceApiextensionsV1Beta1CustomResourceDefinition",
      "httpMethod": "put",
      "tag": "apiextensions_v1beta1",
      "typeScriptTag": "apiextensionsV1Beta1",
      "description": "replace the specified CustomResourceDefinition",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        },
        {
          "statusCode": "201",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}/status",
      "method": "replaceApiextensionsV1Beta1CustomResourceDefinitionStatus",
      "httpMethod": "put",
      "tag": "apiextensions_v1beta1",
      "typeScriptTag": "apiextensionsV1Beta1",
      "description": "replace status of the specified CustomResourceDefinition",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        },
        {
          "statusCode": "201",
          "description": "CustomResourceDefinition represents a resource that should be exposed on the API server.  Its name MUST be in the format <.spec.name>.<.spec.group>."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1beta1/watch/customresourcedefinitions",
      "method": "watchApiextensionsV1Beta1CustomResourceDefinitionList",
      "httpMethod": "get",
      "tag": "apiextensions_v1beta1",
      "typeScriptTag": "apiextensionsV1Beta1",
      "description": "watch individual changes to a list of CustomResourceDefinition",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apiextensions.k8s.io/v1beta1/watch/customresourcedefinitions/{name}",
      "method": "watchApiextensionsV1Beta1CustomResourceDefinition",
      "httpMethod": "get",
      "tag": "apiextensions_v1beta1",
      "typeScriptTag": "apiextensionsV1Beta1",
      "description": "watch changes to an object of kind CustomResourceDefinition",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/",
      "method": "getApiregistrationApiGroup",
      "httpMethod": "get",
      "tag": "apiregistration",
      "typeScriptTag": "apiregistration",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/",
      "method": "getApiregistrationV1ApiResources",
      "httpMethod": "get",
      "tag": "apiregistration_v1",
      "typeScriptTag": "apiregistrationV1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/apiservices",
      "method": "deleteApiregistrationV1CollectionApiService",
      "httpMethod": "delete",
      "tag": "apiregistration_v1",
      "typeScriptTag": "apiregistrationV1",
      "description": "delete collection of APIService",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/apiservices",
      "method": "listApiregistrationV1ApiService",
      "httpMethod": "get",
      "tag": "apiregistration_v1",
      "typeScriptTag": "apiregistrationV1",
      "description": "list or watch objects of kind APIService",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIServiceList is a list of APIService objects."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/apiservices",
      "method": "createApiregistrationV1ApiService",
      "httpMethod": "post",
      "tag": "apiregistration_v1",
      "typeScriptTag": "apiregistrationV1",
      "description": "create an APIService",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        },
        {
          "statusCode": "201",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        },
        {
          "statusCode": "202",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/apiservices/{name}",
      "method": "deleteApiregistrationV1ApiService",
      "httpMethod": "delete",
      "tag": "apiregistration_v1",
      "typeScriptTag": "apiregistrationV1",
      "description": "delete an APIService",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/apiservices/{name}",
      "method": "readApiregistrationV1ApiService",
      "httpMethod": "get",
      "tag": "apiregistration_v1",
      "typeScriptTag": "apiregistrationV1",
      "description": "read the specified APIService",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/apiservices/{name}",
      "method": "patchApiregistrationV1ApiService",
      "httpMethod": "patch",
      "tag": "apiregistration_v1",
      "typeScriptTag": "apiregistrationV1",
      "description": "partially update the specified APIService",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/apiservices/{name}",
      "method": "replaceApiregistrationV1ApiService",
      "httpMethod": "put",
      "tag": "apiregistration_v1",
      "typeScriptTag": "apiregistrationV1",
      "description": "replace the specified APIService",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        },
        {
          "statusCode": "201",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/apiservices/{name}/status",
      "method": "replaceApiregistrationV1ApiServiceStatus",
      "httpMethod": "put",
      "tag": "apiregistration_v1",
      "typeScriptTag": "apiregistrationV1",
      "description": "replace status of the specified APIService",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        },
        {
          "statusCode": "201",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/watch/apiservices",
      "method": "watchApiregistrationV1ApiServiceList",
      "httpMethod": "get",
      "tag": "apiregistration_v1",
      "typeScriptTag": "apiregistrationV1",
      "description": "watch individual changes to a list of APIService",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1/watch/apiservices/{name}",
      "method": "watchApiregistrationV1ApiService",
      "httpMethod": "get",
      "tag": "apiregistration_v1",
      "typeScriptTag": "apiregistrationV1",
      "description": "watch changes to an object of kind APIService",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1beta1/",
      "method": "getApiregistrationV1Beta1ApiResources",
      "httpMethod": "get",
      "tag": "apiregistration_v1beta1",
      "typeScriptTag": "apiregistrationV1Beta1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1beta1/apiservices",
      "method": "deleteApiregistrationV1Beta1CollectionApiService",
      "httpMethod": "delete",
      "tag": "apiregistration_v1beta1",
      "typeScriptTag": "apiregistrationV1Beta1",
      "description": "delete collection of APIService",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1beta1/apiservices",
      "method": "listApiregistrationV1Beta1ApiService",
      "httpMethod": "get",
      "tag": "apiregistration_v1beta1",
      "typeScriptTag": "apiregistrationV1Beta1",
      "description": "list or watch objects of kind APIService",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIServiceList is a list of APIService objects."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1beta1/apiservices",
      "method": "createApiregistrationV1Beta1ApiService",
      "httpMethod": "post",
      "tag": "apiregistration_v1beta1",
      "typeScriptTag": "apiregistrationV1Beta1",
      "description": "create an APIService",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        },
        {
          "statusCode": "201",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        },
        {
          "statusCode": "202",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}",
      "method": "deleteApiregistrationV1Beta1ApiService",
      "httpMethod": "delete",
      "tag": "apiregistration_v1beta1",
      "typeScriptTag": "apiregistrationV1Beta1",
      "description": "delete an APIService",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}",
      "method": "readApiregistrationV1Beta1ApiService",
      "httpMethod": "get",
      "tag": "apiregistration_v1beta1",
      "typeScriptTag": "apiregistrationV1Beta1",
      "description": "read the specified APIService",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}",
      "method": "patchApiregistrationV1Beta1ApiService",
      "httpMethod": "patch",
      "tag": "apiregistration_v1beta1",
      "typeScriptTag": "apiregistrationV1Beta1",
      "description": "partially update the specified APIService",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}",
      "method": "replaceApiregistrationV1Beta1ApiService",
      "httpMethod": "put",
      "tag": "apiregistration_v1beta1",
      "typeScriptTag": "apiregistrationV1Beta1",
      "description": "replace the specified APIService",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        },
        {
          "statusCode": "201",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}/status",
      "method": "replaceApiregistrationV1Beta1ApiServiceStatus",
      "httpMethod": "put",
      "tag": "apiregistration_v1beta1",
      "typeScriptTag": "apiregistrationV1Beta1",
      "description": "replace status of the specified APIService",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        },
        {
          "statusCode": "201",
          "description": "APIService represents a server for a particular GroupVersion. Name must be \"version.group\"."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1beta1/watch/apiservices",
      "method": "watchApiregistrationV1Beta1ApiServiceList",
      "httpMethod": "get",
      "tag": "apiregistration_v1beta1",
      "typeScriptTag": "apiregistrationV1Beta1",
      "description": "watch individual changes to a list of APIService",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apiregistration.k8s.io/v1beta1/watch/apiservices/{name}",
      "method": "watchApiregistrationV1Beta1ApiService",
      "httpMethod": "get",
      "tag": "apiregistration_v1beta1",
      "typeScriptTag": "apiregistrationV1Beta1",
      "description": "watch changes to an object of kind APIService",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/",
      "method": "getAppsApiGroup",
      "httpMethod": "get",
      "tag": "apps",
      "typeScriptTag": "apps",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/",
      "method": "getAppsV1ApiResources",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/controllerrevisions",
      "method": "listAppsV1ControllerRevisionForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "list or watch objects of kind ControllerRevision",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ControllerRevisionList is a resource containing a list of ControllerRevision objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/daemonsets",
      "method": "listAppsV1DaemonSetForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "list or watch objects of kind DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSetList is a collection of daemon sets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/deployments",
      "method": "listAppsV1DeploymentForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "list or watch objects of kind Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DeploymentList is a list of Deployments."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/controllerrevisions",
      "method": "deleteAppsV1CollectionNamespacedControllerRevision",
      "httpMethod": "delete",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "delete collection of ControllerRevision",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/controllerrevisions",
      "method": "listAppsV1NamespacedControllerRevision",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "list or watch objects of kind ControllerRevision",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ControllerRevisionList is a resource containing a list of ControllerRevision objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/controllerrevisions",
      "method": "createAppsV1NamespacedControllerRevision",
      "httpMethod": "post",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "create a ControllerRevision",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "data",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "revision",
          "schema": "integer",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        },
        {
          "statusCode": "201",
          "description": "ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        },
        {
          "statusCode": "202",
          "description": "ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}",
      "method": "deleteAppsV1NamespacedControllerRevision",
      "httpMethod": "delete",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "delete a ControllerRevision",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}",
      "method": "readAppsV1NamespacedControllerRevision",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "read the specified ControllerRevision",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}",
      "method": "patchAppsV1NamespacedControllerRevision",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "partially update the specified ControllerRevision",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}",
      "method": "replaceAppsV1NamespacedControllerRevision",
      "httpMethod": "put",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "replace the specified ControllerRevision",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "data",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "revision",
          "schema": "integer",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        },
        {
          "statusCode": "201",
          "description": "ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/daemonsets",
      "method": "deleteAppsV1CollectionNamespacedDaemonSet",
      "httpMethod": "delete",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "delete collection of DaemonSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/daemonsets",
      "method": "listAppsV1NamespacedDaemonSet",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "list or watch objects of kind DaemonSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSetList is a collection of daemon sets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/daemonsets",
      "method": "createAppsV1NamespacedDaemonSet",
      "httpMethod": "post",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "create a DaemonSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSet represents the configuration of a daemon set."
        },
        {
          "statusCode": "201",
          "description": "DaemonSet represents the configuration of a daemon set."
        },
        {
          "statusCode": "202",
          "description": "DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}",
      "method": "deleteAppsV1NamespacedDaemonSet",
      "httpMethod": "delete",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "delete a DaemonSet",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}",
      "method": "readAppsV1NamespacedDaemonSet",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "read the specified DaemonSet",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}",
      "method": "patchAppsV1NamespacedDaemonSet",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "partially update the specified DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}",
      "method": "replaceAppsV1NamespacedDaemonSet",
      "httpMethod": "put",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "replace the specified DaemonSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSet represents the configuration of a daemon set."
        },
        {
          "statusCode": "201",
          "description": "DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status",
      "method": "readAppsV1NamespacedDaemonSetStatus",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "read status of the specified DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status",
      "method": "patchAppsV1NamespacedDaemonSetStatus",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "partially update status of the specified DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status",
      "method": "replaceAppsV1NamespacedDaemonSetStatus",
      "httpMethod": "put",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "replace status of the specified DaemonSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSet represents the configuration of a daemon set."
        },
        {
          "statusCode": "201",
          "description": "DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments",
      "method": "deleteAppsV1CollectionNamespacedDeployment",
      "httpMethod": "delete",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "delete collection of Deployment",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments",
      "method": "listAppsV1NamespacedDeployment",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "list or watch objects of kind Deployment",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DeploymentList is a list of Deployments."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments",
      "method": "createAppsV1NamespacedDeployment",
      "httpMethod": "post",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "create a Deployment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "201",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "202",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments/{name}",
      "method": "deleteAppsV1NamespacedDeployment",
      "httpMethod": "delete",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "delete a Deployment",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments/{name}",
      "method": "readAppsV1NamespacedDeployment",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "read the specified Deployment",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments/{name}",
      "method": "patchAppsV1NamespacedDeployment",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "partially update the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments/{name}",
      "method": "replaceAppsV1NamespacedDeployment",
      "httpMethod": "put",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "replace the specified Deployment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "201",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale",
      "method": "readAppsV1NamespacedDeploymentScale",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "read scale of the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale",
      "method": "patchAppsV1NamespacedDeploymentScale",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "partially update scale of the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale",
      "method": "replaceAppsV1NamespacedDeploymentScale",
      "httpMethod": "put",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "replace scale of the specified Deployment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        },
        {
          "statusCode": "201",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status",
      "method": "readAppsV1NamespacedDeploymentStatus",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "read status of the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status",
      "method": "patchAppsV1NamespacedDeploymentStatus",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "partially update status of the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status",
      "method": "replaceAppsV1NamespacedDeploymentStatus",
      "httpMethod": "put",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "replace status of the specified Deployment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "201",
          "description": "Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets",
      "method": "deleteAppsV1CollectionNamespacedReplicaSet",
      "httpMethod": "delete",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "delete collection of ReplicaSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets",
      "method": "listAppsV1NamespacedReplicaSet",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "list or watch objects of kind ReplicaSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSetList is a collection of ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets",
      "method": "createAppsV1NamespacedReplicaSet",
      "httpMethod": "post",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "create a ReplicaSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        },
        {
          "statusCode": "201",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        },
        {
          "statusCode": "202",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}",
      "method": "deleteAppsV1NamespacedReplicaSet",
      "httpMethod": "delete",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "delete a ReplicaSet",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}",
      "method": "readAppsV1NamespacedReplicaSet",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "read the specified ReplicaSet",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}",
      "method": "patchAppsV1NamespacedReplicaSet",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "partially update the specified ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}",
      "method": "replaceAppsV1NamespacedReplicaSet",
      "httpMethod": "put",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "replace the specified ReplicaSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        },
        {
          "statusCode": "201",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale",
      "method": "readAppsV1NamespacedReplicaSetScale",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "read scale of the specified ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale",
      "method": "patchAppsV1NamespacedReplicaSetScale",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "partially update scale of the specified ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale",
      "method": "replaceAppsV1NamespacedReplicaSetScale",
      "httpMethod": "put",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "replace scale of the specified ReplicaSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        },
        {
          "statusCode": "201",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status",
      "method": "readAppsV1NamespacedReplicaSetStatus",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "read status of the specified ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status",
      "method": "patchAppsV1NamespacedReplicaSetStatus",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "partially update status of the specified ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status",
      "method": "replaceAppsV1NamespacedReplicaSetStatus",
      "httpMethod": "put",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "replace status of the specified ReplicaSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        },
        {
          "statusCode": "201",
          "description": "ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets",
      "method": "deleteAppsV1CollectionNamespacedStatefulSet",
      "httpMethod": "delete",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "delete collection of StatefulSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets",
      "method": "listAppsV1NamespacedStatefulSet",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "list or watch objects of kind StatefulSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSetList is a collection of StatefulSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets",
      "method": "createAppsV1NamespacedStatefulSet",
      "httpMethod": "post",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "create a StatefulSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        },
        {
          "statusCode": "201",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        },
        {
          "statusCode": "202",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}",
      "method": "deleteAppsV1NamespacedStatefulSet",
      "httpMethod": "delete",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "delete a StatefulSet",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}",
      "method": "readAppsV1NamespacedStatefulSet",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "read the specified StatefulSet",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}",
      "method": "patchAppsV1NamespacedStatefulSet",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "partially update the specified StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}",
      "method": "replaceAppsV1NamespacedStatefulSet",
      "httpMethod": "put",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "replace the specified StatefulSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        },
        {
          "statusCode": "201",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale",
      "method": "readAppsV1NamespacedStatefulSetScale",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "read scale of the specified StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale",
      "method": "patchAppsV1NamespacedStatefulSetScale",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "partially update scale of the specified StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale",
      "method": "replaceAppsV1NamespacedStatefulSetScale",
      "httpMethod": "put",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "replace scale of the specified StatefulSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        },
        {
          "statusCode": "201",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status",
      "method": "readAppsV1NamespacedStatefulSetStatus",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "read status of the specified StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status",
      "method": "patchAppsV1NamespacedStatefulSetStatus",
      "httpMethod": "patch",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "partially update status of the specified StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status",
      "method": "replaceAppsV1NamespacedStatefulSetStatus",
      "httpMethod": "put",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "replace status of the specified StatefulSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        },
        {
          "statusCode": "201",
          "description": "StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/replicasets",
      "method": "listAppsV1ReplicaSetForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "list or watch objects of kind ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSetList is a collection of ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/statefulsets",
      "method": "listAppsV1StatefulSetForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "list or watch objects of kind StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSetList is a collection of StatefulSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/controllerrevisions",
      "method": "watchAppsV1ControllerRevisionListForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "watch individual changes to a list of ControllerRevision",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/daemonsets",
      "method": "watchAppsV1DaemonSetListForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "watch individual changes to a list of DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/deployments",
      "method": "watchAppsV1DeploymentListForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "watch individual changes to a list of Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/namespaces/{namespace}/controllerrevisions",
      "method": "watchAppsV1NamespacedControllerRevisionList",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "watch individual changes to a list of ControllerRevision",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/namespaces/{namespace}/controllerrevisions/{name}",
      "method": "watchAppsV1NamespacedControllerRevision",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "watch changes to an object of kind ControllerRevision",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/namespaces/{namespace}/daemonsets",
      "method": "watchAppsV1NamespacedDaemonSetList",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "watch individual changes to a list of DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/namespaces/{namespace}/daemonsets/{name}",
      "method": "watchAppsV1NamespacedDaemonSet",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "watch changes to an object of kind DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/namespaces/{namespace}/deployments",
      "method": "watchAppsV1NamespacedDeploymentList",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "watch individual changes to a list of Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/namespaces/{namespace}/deployments/{name}",
      "method": "watchAppsV1NamespacedDeployment",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "watch changes to an object of kind Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/namespaces/{namespace}/replicasets",
      "method": "watchAppsV1NamespacedReplicaSetList",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "watch individual changes to a list of ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/namespaces/{namespace}/replicasets/{name}",
      "method": "watchAppsV1NamespacedReplicaSet",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "watch changes to an object of kind ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/namespaces/{namespace}/statefulsets",
      "method": "watchAppsV1NamespacedStatefulSetList",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "watch individual changes to a list of StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/namespaces/{namespace}/statefulsets/{name}",
      "method": "watchAppsV1NamespacedStatefulSet",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "watch changes to an object of kind StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/replicasets",
      "method": "watchAppsV1ReplicaSetListForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "watch individual changes to a list of ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1/watch/statefulsets",
      "method": "watchAppsV1StatefulSetListForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1",
      "typeScriptTag": "appsV1",
      "description": "watch individual changes to a list of StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/",
      "method": "getAppsV1Beta1ApiResources",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/controllerrevisions",
      "method": "listAppsV1Beta1ControllerRevisionForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "list or watch objects of kind ControllerRevision",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ControllerRevisionList is a resource containing a list of ControllerRevision objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/deployments",
      "method": "listAppsV1Beta1DeploymentForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "list or watch objects of kind Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DeploymentList is a list of Deployments."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions",
      "method": "deleteAppsV1Beta1CollectionNamespacedControllerRevision",
      "httpMethod": "delete",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "delete collection of ControllerRevision",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions",
      "method": "listAppsV1Beta1NamespacedControllerRevision",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "list or watch objects of kind ControllerRevision",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ControllerRevisionList is a resource containing a list of ControllerRevision objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions",
      "method": "createAppsV1Beta1NamespacedControllerRevision",
      "httpMethod": "post",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "create a ControllerRevision",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "data",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "revision",
          "schema": "integer",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ControllerRevision is deprecated by apps/v1beta2/ControllerRevision. See the release notes for more information. ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of ControllerRevision is deprecated by apps/v1beta2/ControllerRevision. See the release notes for more information. ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        },
        {
          "statusCode": "202",
          "description": "DEPRECATED - This group version of ControllerRevision is deprecated by apps/v1beta2/ControllerRevision. See the release notes for more information. ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions/{name}",
      "method": "deleteAppsV1Beta1NamespacedControllerRevision",
      "httpMethod": "delete",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "delete a ControllerRevision",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions/{name}",
      "method": "readAppsV1Beta1NamespacedControllerRevision",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "read the specified ControllerRevision",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ControllerRevision is deprecated by apps/v1beta2/ControllerRevision. See the release notes for more information. ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions/{name}",
      "method": "patchAppsV1Beta1NamespacedControllerRevision",
      "httpMethod": "patch",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "partially update the specified ControllerRevision",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ControllerRevision is deprecated by apps/v1beta2/ControllerRevision. See the release notes for more information. ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions/{name}",
      "method": "replaceAppsV1Beta1NamespacedControllerRevision",
      "httpMethod": "put",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "replace the specified ControllerRevision",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "data",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "revision",
          "schema": "integer",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ControllerRevision is deprecated by apps/v1beta2/ControllerRevision. See the release notes for more information. ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of ControllerRevision is deprecated by apps/v1beta2/ControllerRevision. See the release notes for more information. ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/deployments",
      "method": "deleteAppsV1Beta1CollectionNamespacedDeployment",
      "httpMethod": "delete",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "delete collection of Deployment",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/deployments",
      "method": "listAppsV1Beta1NamespacedDeployment",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "list or watch objects of kind Deployment",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DeploymentList is a list of Deployments."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/deployments",
      "method": "createAppsV1Beta1NamespacedDeployment",
      "httpMethod": "post",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "create a Deployment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "202",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}",
      "method": "deleteAppsV1Beta1NamespacedDeployment",
      "httpMethod": "delete",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "delete a Deployment",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}",
      "method": "readAppsV1Beta1NamespacedDeployment",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "read the specified Deployment",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}",
      "method": "patchAppsV1Beta1NamespacedDeployment",
      "httpMethod": "patch",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "partially update the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}",
      "method": "replaceAppsV1Beta1NamespacedDeployment",
      "httpMethod": "put",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "replace the specified Deployment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/rollback",
      "method": "createAppsV1Beta1NamespacedDeploymentRollback",
      "httpMethod": "post",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "create rollback of a Deployment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "name",
          "schema": "string",
          "required": true,
          "description": ""
        },
        {
          "name": "rollbackTo",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "updatedAnnotations",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED. DeploymentRollback stores the information required to rollback a deployment."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED. DeploymentRollback stores the information required to rollback a deployment."
        },
        {
          "statusCode": "202",
          "description": "DEPRECATED. DeploymentRollback stores the information required to rollback a deployment."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/scale",
      "method": "readAppsV1Beta1NamespacedDeploymentScale",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "read scale of the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/scale",
      "method": "patchAppsV1Beta1NamespacedDeploymentScale",
      "httpMethod": "patch",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "partially update scale of the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/scale",
      "method": "replaceAppsV1Beta1NamespacedDeploymentScale",
      "httpMethod": "put",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "replace scale of the specified Deployment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        },
        {
          "statusCode": "201",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/status",
      "method": "readAppsV1Beta1NamespacedDeploymentStatus",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "read status of the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/status",
      "method": "patchAppsV1Beta1NamespacedDeploymentStatus",
      "httpMethod": "patch",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "partially update status of the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/status",
      "method": "replaceAppsV1Beta1NamespacedDeploymentStatus",
      "httpMethod": "put",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "replace status of the specified Deployment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/statefulsets",
      "method": "deleteAppsV1Beta1CollectionNamespacedStatefulSet",
      "httpMethod": "delete",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "delete collection of StatefulSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/statefulsets",
      "method": "listAppsV1Beta1NamespacedStatefulSet",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "list or watch objects of kind StatefulSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSetList is a collection of StatefulSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/statefulsets",
      "method": "createAppsV1Beta1NamespacedStatefulSet",
      "httpMethod": "post",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "create a StatefulSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1beta2/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1beta2/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        },
        {
          "statusCode": "202",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1beta2/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}",
      "method": "deleteAppsV1Beta1NamespacedStatefulSet",
      "httpMethod": "delete",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "delete a StatefulSet",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}",
      "method": "readAppsV1Beta1NamespacedStatefulSet",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "read the specified StatefulSet",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1beta2/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}",
      "method": "patchAppsV1Beta1NamespacedStatefulSet",
      "httpMethod": "patch",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "partially update the specified StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1beta2/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}",
      "method": "replaceAppsV1Beta1NamespacedStatefulSet",
      "httpMethod": "put",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "replace the specified StatefulSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1beta2/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1beta2/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/scale",
      "method": "readAppsV1Beta1NamespacedStatefulSetScale",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "read scale of the specified StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/scale",
      "method": "patchAppsV1Beta1NamespacedStatefulSetScale",
      "httpMethod": "patch",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "partially update scale of the specified StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/scale",
      "method": "replaceAppsV1Beta1NamespacedStatefulSetScale",
      "httpMethod": "put",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "replace scale of the specified StatefulSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        },
        {
          "statusCode": "201",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/status",
      "method": "readAppsV1Beta1NamespacedStatefulSetStatus",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "read status of the specified StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1beta2/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/status",
      "method": "patchAppsV1Beta1NamespacedStatefulSetStatus",
      "httpMethod": "patch",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "partially update status of the specified StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1beta2/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/status",
      "method": "replaceAppsV1Beta1NamespacedStatefulSetStatus",
      "httpMethod": "put",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "replace status of the specified StatefulSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1beta2/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1beta2/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/statefulsets",
      "method": "listAppsV1Beta1StatefulSetForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "list or watch objects of kind StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSetList is a collection of StatefulSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/watch/controllerrevisions",
      "method": "watchAppsV1Beta1ControllerRevisionListForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "watch individual changes to a list of ControllerRevision",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/watch/deployments",
      "method": "watchAppsV1Beta1DeploymentListForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "watch individual changes to a list of Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/watch/namespaces/{namespace}/controllerrevisions",
      "method": "watchAppsV1Beta1NamespacedControllerRevisionList",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "watch individual changes to a list of ControllerRevision",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/watch/namespaces/{namespace}/controllerrevisions/{name}",
      "method": "watchAppsV1Beta1NamespacedControllerRevision",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "watch changes to an object of kind ControllerRevision",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/watch/namespaces/{namespace}/deployments",
      "method": "watchAppsV1Beta1NamespacedDeploymentList",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "watch individual changes to a list of Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/watch/namespaces/{namespace}/deployments/{name}",
      "method": "watchAppsV1Beta1NamespacedDeployment",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "watch changes to an object of kind Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/watch/namespaces/{namespace}/statefulsets",
      "method": "watchAppsV1Beta1NamespacedStatefulSetList",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "watch individual changes to a list of StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/watch/namespaces/{namespace}/statefulsets/{name}",
      "method": "watchAppsV1Beta1NamespacedStatefulSet",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "watch changes to an object of kind StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta1/watch/statefulsets",
      "method": "watchAppsV1Beta1StatefulSetListForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1beta1",
      "typeScriptTag": "appsV1Beta1",
      "description": "watch individual changes to a list of StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/",
      "method": "getAppsV1Beta2ApiResources",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/controllerrevisions",
      "method": "listAppsV1Beta2ControllerRevisionForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "list or watch objects of kind ControllerRevision",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ControllerRevisionList is a resource containing a list of ControllerRevision objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/daemonsets",
      "method": "listAppsV1Beta2DaemonSetForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "list or watch objects of kind DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSetList is a collection of daemon sets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/deployments",
      "method": "listAppsV1Beta2DeploymentForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "list or watch objects of kind Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DeploymentList is a list of Deployments."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions",
      "method": "deleteAppsV1Beta2CollectionNamespacedControllerRevision",
      "httpMethod": "delete",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "delete collection of ControllerRevision",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions",
      "method": "listAppsV1Beta2NamespacedControllerRevision",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "list or watch objects of kind ControllerRevision",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ControllerRevisionList is a resource containing a list of ControllerRevision objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions",
      "method": "createAppsV1Beta2NamespacedControllerRevision",
      "httpMethod": "post",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "create a ControllerRevision",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "data",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "revision",
          "schema": "integer",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ControllerRevision is deprecated by apps/v1/ControllerRevision. See the release notes for more information. ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of ControllerRevision is deprecated by apps/v1/ControllerRevision. See the release notes for more information. ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        },
        {
          "statusCode": "202",
          "description": "DEPRECATED - This group version of ControllerRevision is deprecated by apps/v1/ControllerRevision. See the release notes for more information. ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions/{name}",
      "method": "deleteAppsV1Beta2NamespacedControllerRevision",
      "httpMethod": "delete",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "delete a ControllerRevision",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions/{name}",
      "method": "readAppsV1Beta2NamespacedControllerRevision",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "read the specified ControllerRevision",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ControllerRevision is deprecated by apps/v1/ControllerRevision. See the release notes for more information. ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions/{name}",
      "method": "patchAppsV1Beta2NamespacedControllerRevision",
      "httpMethod": "patch",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "partially update the specified ControllerRevision",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ControllerRevision is deprecated by apps/v1/ControllerRevision. See the release notes for more information. ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions/{name}",
      "method": "replaceAppsV1Beta2NamespacedControllerRevision",
      "httpMethod": "put",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "replace the specified ControllerRevision",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "data",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "revision",
          "schema": "integer",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ControllerRevision is deprecated by apps/v1/ControllerRevision. See the release notes for more information. ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of ControllerRevision is deprecated by apps/v1/ControllerRevision. See the release notes for more information. ControllerRevision implements an immutable snapshot of state data. Clients are responsible for serializing and deserializing the objects that contain their internal state. Once a ControllerRevision has been successfully created, it can not be updated. The API Server will fail validation of all requests that attempt to mutate the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/daemonsets",
      "method": "deleteAppsV1Beta2CollectionNamespacedDaemonSet",
      "httpMethod": "delete",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "delete collection of DaemonSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/daemonsets",
      "method": "listAppsV1Beta2NamespacedDaemonSet",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "list or watch objects of kind DaemonSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSetList is a collection of daemon sets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/daemonsets",
      "method": "createAppsV1Beta2NamespacedDaemonSet",
      "httpMethod": "post",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "create a DaemonSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        },
        {
          "statusCode": "202",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}",
      "method": "deleteAppsV1Beta2NamespacedDaemonSet",
      "httpMethod": "delete",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "delete a DaemonSet",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}",
      "method": "readAppsV1Beta2NamespacedDaemonSet",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "read the specified DaemonSet",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}",
      "method": "patchAppsV1Beta2NamespacedDaemonSet",
      "httpMethod": "patch",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "partially update the specified DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}",
      "method": "replaceAppsV1Beta2NamespacedDaemonSet",
      "httpMethod": "put",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "replace the specified DaemonSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}/status",
      "method": "readAppsV1Beta2NamespacedDaemonSetStatus",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "read status of the specified DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}/status",
      "method": "patchAppsV1Beta2NamespacedDaemonSetStatus",
      "httpMethod": "patch",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "partially update status of the specified DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}/status",
      "method": "replaceAppsV1Beta2NamespacedDaemonSetStatus",
      "httpMethod": "put",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "replace status of the specified DaemonSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/deployments",
      "method": "deleteAppsV1Beta2CollectionNamespacedDeployment",
      "httpMethod": "delete",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "delete collection of Deployment",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/deployments",
      "method": "listAppsV1Beta2NamespacedDeployment",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "list or watch objects of kind Deployment",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DeploymentList is a list of Deployments."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/deployments",
      "method": "createAppsV1Beta2NamespacedDeployment",
      "httpMethod": "post",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "create a Deployment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "202",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}",
      "method": "deleteAppsV1Beta2NamespacedDeployment",
      "httpMethod": "delete",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "delete a Deployment",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}",
      "method": "readAppsV1Beta2NamespacedDeployment",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "read the specified Deployment",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}",
      "method": "patchAppsV1Beta2NamespacedDeployment",
      "httpMethod": "patch",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "partially update the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}",
      "method": "replaceAppsV1Beta2NamespacedDeployment",
      "httpMethod": "put",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "replace the specified Deployment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/scale",
      "method": "readAppsV1Beta2NamespacedDeploymentScale",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "read scale of the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/scale",
      "method": "patchAppsV1Beta2NamespacedDeploymentScale",
      "httpMethod": "patch",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "partially update scale of the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/scale",
      "method": "replaceAppsV1Beta2NamespacedDeploymentScale",
      "httpMethod": "put",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "replace scale of the specified Deployment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        },
        {
          "statusCode": "201",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/status",
      "method": "readAppsV1Beta2NamespacedDeploymentStatus",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "read status of the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/status",
      "method": "patchAppsV1Beta2NamespacedDeploymentStatus",
      "httpMethod": "patch",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "partially update status of the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/status",
      "method": "replaceAppsV1Beta2NamespacedDeploymentStatus",
      "httpMethod": "put",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "replace status of the specified Deployment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/replicasets",
      "method": "deleteAppsV1Beta2CollectionNamespacedReplicaSet",
      "httpMethod": "delete",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "delete collection of ReplicaSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/replicasets",
      "method": "listAppsV1Beta2NamespacedReplicaSet",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "list or watch objects of kind ReplicaSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSetList is a collection of ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/replicasets",
      "method": "createAppsV1Beta2NamespacedReplicaSet",
      "httpMethod": "post",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "create a ReplicaSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        },
        {
          "statusCode": "202",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}",
      "method": "deleteAppsV1Beta2NamespacedReplicaSet",
      "httpMethod": "delete",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "delete a ReplicaSet",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}",
      "method": "readAppsV1Beta2NamespacedReplicaSet",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "read the specified ReplicaSet",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}",
      "method": "patchAppsV1Beta2NamespacedReplicaSet",
      "httpMethod": "patch",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "partially update the specified ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}",
      "method": "replaceAppsV1Beta2NamespacedReplicaSet",
      "httpMethod": "put",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "replace the specified ReplicaSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/scale",
      "method": "readAppsV1Beta2NamespacedReplicaSetScale",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "read scale of the specified ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/scale",
      "method": "patchAppsV1Beta2NamespacedReplicaSetScale",
      "httpMethod": "patch",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "partially update scale of the specified ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/scale",
      "method": "replaceAppsV1Beta2NamespacedReplicaSetScale",
      "httpMethod": "put",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "replace scale of the specified ReplicaSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        },
        {
          "statusCode": "201",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/status",
      "method": "readAppsV1Beta2NamespacedReplicaSetStatus",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "read status of the specified ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/status",
      "method": "patchAppsV1Beta2NamespacedReplicaSetStatus",
      "httpMethod": "patch",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "partially update status of the specified ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/status",
      "method": "replaceAppsV1Beta2NamespacedReplicaSetStatus",
      "httpMethod": "put",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "replace status of the specified ReplicaSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/statefulsets",
      "method": "deleteAppsV1Beta2CollectionNamespacedStatefulSet",
      "httpMethod": "delete",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "delete collection of StatefulSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/statefulsets",
      "method": "listAppsV1Beta2NamespacedStatefulSet",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "list or watch objects of kind StatefulSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSetList is a collection of StatefulSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/statefulsets",
      "method": "createAppsV1Beta2NamespacedStatefulSet",
      "httpMethod": "post",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "create a StatefulSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        },
        {
          "statusCode": "202",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}",
      "method": "deleteAppsV1Beta2NamespacedStatefulSet",
      "httpMethod": "delete",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "delete a StatefulSet",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}",
      "method": "readAppsV1Beta2NamespacedStatefulSet",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "read the specified StatefulSet",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}",
      "method": "patchAppsV1Beta2NamespacedStatefulSet",
      "httpMethod": "patch",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "partially update the specified StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}",
      "method": "replaceAppsV1Beta2NamespacedStatefulSet",
      "httpMethod": "put",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "replace the specified StatefulSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/scale",
      "method": "readAppsV1Beta2NamespacedStatefulSetScale",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "read scale of the specified StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/scale",
      "method": "patchAppsV1Beta2NamespacedStatefulSetScale",
      "httpMethod": "patch",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "partially update scale of the specified StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/scale",
      "method": "replaceAppsV1Beta2NamespacedStatefulSetScale",
      "httpMethod": "put",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "replace scale of the specified StatefulSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Scale represents a scaling request for a resource."
        },
        {
          "statusCode": "201",
          "description": "Scale represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/status",
      "method": "readAppsV1Beta2NamespacedStatefulSetStatus",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "read status of the specified StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/status",
      "method": "patchAppsV1Beta2NamespacedStatefulSetStatus",
      "httpMethod": "patch",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "partially update status of the specified StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/status",
      "method": "replaceAppsV1Beta2NamespacedStatefulSetStatus",
      "httpMethod": "put",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "replace status of the specified StatefulSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of StatefulSet is deprecated by apps/v1/StatefulSet. See the release notes for more information. StatefulSet represents a set of pods with consistent identities. Identities are defined as:\n - Network: A single stable DNS and hostname.\n - Storage: As many VolumeClaims as requested.\nThe StatefulSet guarantees that a given network identity will always map to the same storage identity."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/replicasets",
      "method": "listAppsV1Beta2ReplicaSetForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "list or watch objects of kind ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSetList is a collection of ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/statefulsets",
      "method": "listAppsV1Beta2StatefulSetForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "list or watch objects of kind StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "StatefulSetList is a collection of StatefulSets."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/watch/controllerrevisions",
      "method": "watchAppsV1Beta2ControllerRevisionListForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "watch individual changes to a list of ControllerRevision",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/watch/daemonsets",
      "method": "watchAppsV1Beta2DaemonSetListForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "watch individual changes to a list of DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/watch/deployments",
      "method": "watchAppsV1Beta2DeploymentListForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "watch individual changes to a list of Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/watch/namespaces/{namespace}/controllerrevisions",
      "method": "watchAppsV1Beta2NamespacedControllerRevisionList",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "watch individual changes to a list of ControllerRevision",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/watch/namespaces/{namespace}/controllerrevisions/{name}",
      "method": "watchAppsV1Beta2NamespacedControllerRevision",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "watch changes to an object of kind ControllerRevision",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/watch/namespaces/{namespace}/daemonsets",
      "method": "watchAppsV1Beta2NamespacedDaemonSetList",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "watch individual changes to a list of DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/watch/namespaces/{namespace}/daemonsets/{name}",
      "method": "watchAppsV1Beta2NamespacedDaemonSet",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "watch changes to an object of kind DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/watch/namespaces/{namespace}/deployments",
      "method": "watchAppsV1Beta2NamespacedDeploymentList",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "watch individual changes to a list of Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/watch/namespaces/{namespace}/deployments/{name}",
      "method": "watchAppsV1Beta2NamespacedDeployment",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "watch changes to an object of kind Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/watch/namespaces/{namespace}/replicasets",
      "method": "watchAppsV1Beta2NamespacedReplicaSetList",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "watch individual changes to a list of ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/watch/namespaces/{namespace}/replicasets/{name}",
      "method": "watchAppsV1Beta2NamespacedReplicaSet",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "watch changes to an object of kind ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/watch/namespaces/{namespace}/statefulsets",
      "method": "watchAppsV1Beta2NamespacedStatefulSetList",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "watch individual changes to a list of StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/watch/namespaces/{namespace}/statefulsets/{name}",
      "method": "watchAppsV1Beta2NamespacedStatefulSet",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "watch changes to an object of kind StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/watch/replicasets",
      "method": "watchAppsV1Beta2ReplicaSetListForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "watch individual changes to a list of ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/apps/v1beta2/watch/statefulsets",
      "method": "watchAppsV1Beta2StatefulSetListForAllNamespaces",
      "httpMethod": "get",
      "tag": "apps_v1beta2",
      "typeScriptTag": "appsV1Beta2",
      "description": "watch individual changes to a list of StatefulSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/authentication.k8s.io/",
      "method": "getAuthenticationApiGroup",
      "httpMethod": "get",
      "tag": "authentication",
      "typeScriptTag": "authentication",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/authentication.k8s.io/v1/",
      "method": "getAuthenticationV1ApiResources",
      "httpMethod": "get",
      "tag": "authentication_v1",
      "typeScriptTag": "authenticationV1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/authentication.k8s.io/v1/tokenreviews",
      "method": "createAuthenticationV1TokenReview",
      "httpMethod": "post",
      "tag": "authentication_v1",
      "typeScriptTag": "authenticationV1",
      "description": "create a TokenReview",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver."
        },
        {
          "statusCode": "201",
          "description": "TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver."
        },
        {
          "statusCode": "202",
          "description": "TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver."
        }
      ]
    },
    {
      "url": "/apis/authentication.k8s.io/v1beta1/",
      "method": "getAuthenticationV1Beta1ApiResources",
      "httpMethod": "get",
      "tag": "authentication_v1beta1",
      "typeScriptTag": "authenticationV1Beta1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/authentication.k8s.io/v1beta1/tokenreviews",
      "method": "createAuthenticationV1Beta1TokenReview",
      "httpMethod": "post",
      "tag": "authentication_v1beta1",
      "typeScriptTag": "authenticationV1Beta1",
      "description": "create a TokenReview",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver."
        },
        {
          "statusCode": "201",
          "description": "TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver."
        },
        {
          "statusCode": "202",
          "description": "TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver."
        }
      ]
    },
    {
      "url": "/apis/authorization.k8s.io/",
      "method": "getAuthorizationApiGroup",
      "httpMethod": "get",
      "tag": "authorization",
      "typeScriptTag": "authorization",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/authorization.k8s.io/v1/",
      "method": "getAuthorizationV1ApiResources",
      "httpMethod": "get",
      "tag": "authorization_v1",
      "typeScriptTag": "authorizationV1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/authorization.k8s.io/v1/namespaces/{namespace}/localsubjectaccessreviews",
      "method": "createAuthorizationV1NamespacedLocalSubjectAccessReview",
      "httpMethod": "post",
      "tag": "authorization_v1",
      "typeScriptTag": "authorizationV1",
      "description": "create a LocalSubjectAccessReview",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking."
        },
        {
          "statusCode": "201",
          "description": "LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking."
        },
        {
          "statusCode": "202",
          "description": "LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking."
        }
      ]
    },
    {
      "url": "/apis/authorization.k8s.io/v1/selfsubjectaccessreviews",
      "method": "createAuthorizationV1SelfSubjectAccessReview",
      "httpMethod": "post",
      "tag": "authorization_v1",
      "typeScriptTag": "authorizationV1",
      "description": "create a SelfSubjectAccessReview",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means \"in all namespaces\".  Self is a special case, because users should always be able to check whether they can perform an action"
        },
        {
          "statusCode": "201",
          "description": "SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means \"in all namespaces\".  Self is a special case, because users should always be able to check whether they can perform an action"
        },
        {
          "statusCode": "202",
          "description": "SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means \"in all namespaces\".  Self is a special case, because users should always be able to check whether they can perform an action"
        }
      ]
    },
    {
      "url": "/apis/authorization.k8s.io/v1/selfsubjectrulesreviews",
      "method": "createAuthorizationV1SelfSubjectRulesReview",
      "httpMethod": "post",
      "tag": "authorization_v1",
      "typeScriptTag": "authorizationV1",
      "description": "create a SelfSubjectRulesReview",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace. The returned list of actions may be incomplete depending on the server's authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview should be used by UIs to show/hide actions, or to quickly let an end user reason about their permissions. It should NOT Be used by external systems to drive authorization decisions as this raises confused deputy, cache lifetime/revocation, and correctness concerns. SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization decisions to the API server."
        },
        {
          "statusCode": "201",
          "description": "SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace. The returned list of actions may be incomplete depending on the server's authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview should be used by UIs to show/hide actions, or to quickly let an end user reason about their permissions. It should NOT Be used by external systems to drive authorization decisions as this raises confused deputy, cache lifetime/revocation, and correctness concerns. SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization decisions to the API server."
        },
        {
          "statusCode": "202",
          "description": "SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace. The returned list of actions may be incomplete depending on the server's authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview should be used by UIs to show/hide actions, or to quickly let an end user reason about their permissions. It should NOT Be used by external systems to drive authorization decisions as this raises confused deputy, cache lifetime/revocation, and correctness concerns. SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization decisions to the API server."
        }
      ]
    },
    {
      "url": "/apis/authorization.k8s.io/v1/subjectaccessreviews",
      "method": "createAuthorizationV1SubjectAccessReview",
      "httpMethod": "post",
      "tag": "authorization_v1",
      "typeScriptTag": "authorizationV1",
      "description": "create a SubjectAccessReview",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "SubjectAccessReview checks whether or not a user or group can perform an action."
        },
        {
          "statusCode": "201",
          "description": "SubjectAccessReview checks whether or not a user or group can perform an action."
        },
        {
          "statusCode": "202",
          "description": "SubjectAccessReview checks whether or not a user or group can perform an action."
        }
      ]
    },
    {
      "url": "/apis/authorization.k8s.io/v1beta1/",
      "method": "getAuthorizationV1Beta1ApiResources",
      "httpMethod": "get",
      "tag": "authorization_v1beta1",
      "typeScriptTag": "authorizationV1Beta1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/authorization.k8s.io/v1beta1/namespaces/{namespace}/localsubjectaccessreviews",
      "method": "createAuthorizationV1Beta1NamespacedLocalSubjectAccessReview",
      "httpMethod": "post",
      "tag": "authorization_v1beta1",
      "typeScriptTag": "authorizationV1Beta1",
      "description": "create a LocalSubjectAccessReview",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking."
        },
        {
          "statusCode": "201",
          "description": "LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking."
        },
        {
          "statusCode": "202",
          "description": "LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking."
        }
      ]
    },
    {
      "url": "/apis/authorization.k8s.io/v1beta1/selfsubjectaccessreviews",
      "method": "createAuthorizationV1Beta1SelfSubjectAccessReview",
      "httpMethod": "post",
      "tag": "authorization_v1beta1",
      "typeScriptTag": "authorizationV1Beta1",
      "description": "create a SelfSubjectAccessReview",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means \"in all namespaces\".  Self is a special case, because users should always be able to check whether they can perform an action"
        },
        {
          "statusCode": "201",
          "description": "SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means \"in all namespaces\".  Self is a special case, because users should always be able to check whether they can perform an action"
        },
        {
          "statusCode": "202",
          "description": "SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means \"in all namespaces\".  Self is a special case, because users should always be able to check whether they can perform an action"
        }
      ]
    },
    {
      "url": "/apis/authorization.k8s.io/v1beta1/selfsubjectrulesreviews",
      "method": "createAuthorizationV1Beta1SelfSubjectRulesReview",
      "httpMethod": "post",
      "tag": "authorization_v1beta1",
      "typeScriptTag": "authorizationV1Beta1",
      "description": "create a SelfSubjectRulesReview",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace. The returned list of actions may be incomplete depending on the server's authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview should be used by UIs to show/hide actions, or to quickly let an end user reason about their permissions. It should NOT Be used by external systems to drive authorization decisions as this raises confused deputy, cache lifetime/revocation, and correctness concerns. SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization decisions to the API server."
        },
        {
          "statusCode": "201",
          "description": "SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace. The returned list of actions may be incomplete depending on the server's authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview should be used by UIs to show/hide actions, or to quickly let an end user reason about their permissions. It should NOT Be used by external systems to drive authorization decisions as this raises confused deputy, cache lifetime/revocation, and correctness concerns. SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization decisions to the API server."
        },
        {
          "statusCode": "202",
          "description": "SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace. The returned list of actions may be incomplete depending on the server's authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview should be used by UIs to show/hide actions, or to quickly let an end user reason about their permissions. It should NOT Be used by external systems to drive authorization decisions as this raises confused deputy, cache lifetime/revocation, and correctness concerns. SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization decisions to the API server."
        }
      ]
    },
    {
      "url": "/apis/authorization.k8s.io/v1beta1/subjectaccessreviews",
      "method": "createAuthorizationV1Beta1SubjectAccessReview",
      "httpMethod": "post",
      "tag": "authorization_v1beta1",
      "typeScriptTag": "authorizationV1Beta1",
      "description": "create a SubjectAccessReview",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "SubjectAccessReview checks whether or not a user or group can perform an action."
        },
        {
          "statusCode": "201",
          "description": "SubjectAccessReview checks whether or not a user or group can perform an action."
        },
        {
          "statusCode": "202",
          "description": "SubjectAccessReview checks whether or not a user or group can perform an action."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/",
      "method": "getAutoscalingApiGroup",
      "httpMethod": "get",
      "tag": "autoscaling",
      "typeScriptTag": "autoscaling",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/",
      "method": "getAutoscalingV1ApiResources",
      "httpMethod": "get",
      "tag": "autoscaling_v1",
      "typeScriptTag": "autoscalingV1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/horizontalpodautoscalers",
      "method": "listAutoscalingV1HorizontalPodAutoscalerForAllNamespaces",
      "httpMethod": "get",
      "tag": "autoscaling_v1",
      "typeScriptTag": "autoscalingV1",
      "description": "list or watch objects of kind HorizontalPodAutoscaler",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "list of horizontal pod autoscaler objects."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers",
      "method": "deleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler",
      "httpMethod": "delete",
      "tag": "autoscaling_v1",
      "typeScriptTag": "autoscalingV1",
      "description": "delete collection of HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers",
      "method": "listAutoscalingV1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "get",
      "tag": "autoscaling_v1",
      "typeScriptTag": "autoscalingV1",
      "description": "list or watch objects of kind HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "list of horizontal pod autoscaler objects."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers",
      "method": "createAutoscalingV1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "post",
      "tag": "autoscaling_v1",
      "typeScriptTag": "autoscalingV1",
      "description": "create a HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "configuration of a horizontal pod autoscaler."
        },
        {
          "statusCode": "201",
          "description": "configuration of a horizontal pod autoscaler."
        },
        {
          "statusCode": "202",
          "description": "configuration of a horizontal pod autoscaler."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}",
      "method": "deleteAutoscalingV1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "delete",
      "tag": "autoscaling_v1",
      "typeScriptTag": "autoscalingV1",
      "description": "delete a HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}",
      "method": "readAutoscalingV1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "get",
      "tag": "autoscaling_v1",
      "typeScriptTag": "autoscalingV1",
      "description": "read the specified HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "configuration of a horizontal pod autoscaler."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}",
      "method": "patchAutoscalingV1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "patch",
      "tag": "autoscaling_v1",
      "typeScriptTag": "autoscalingV1",
      "description": "partially update the specified HorizontalPodAutoscaler",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "configuration of a horizontal pod autoscaler."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}",
      "method": "replaceAutoscalingV1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "put",
      "tag": "autoscaling_v1",
      "typeScriptTag": "autoscalingV1",
      "description": "replace the specified HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "configuration of a horizontal pod autoscaler."
        },
        {
          "statusCode": "201",
          "description": "configuration of a horizontal pod autoscaler."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status",
      "method": "readAutoscalingV1NamespacedHorizontalPodAutoscalerStatus",
      "httpMethod": "get",
      "tag": "autoscaling_v1",
      "typeScriptTag": "autoscalingV1",
      "description": "read status of the specified HorizontalPodAutoscaler",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "configuration of a horizontal pod autoscaler."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status",
      "method": "patchAutoscalingV1NamespacedHorizontalPodAutoscalerStatus",
      "httpMethod": "patch",
      "tag": "autoscaling_v1",
      "typeScriptTag": "autoscalingV1",
      "description": "partially update status of the specified HorizontalPodAutoscaler",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "configuration of a horizontal pod autoscaler."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status",
      "method": "replaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatus",
      "httpMethod": "put",
      "tag": "autoscaling_v1",
      "typeScriptTag": "autoscalingV1",
      "description": "replace status of the specified HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "configuration of a horizontal pod autoscaler."
        },
        {
          "statusCode": "201",
          "description": "configuration of a horizontal pod autoscaler."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/watch/horizontalpodautoscalers",
      "method": "watchAutoscalingV1HorizontalPodAutoscalerListForAllNamespaces",
      "httpMethod": "get",
      "tag": "autoscaling_v1",
      "typeScriptTag": "autoscalingV1",
      "description": "watch individual changes to a list of HorizontalPodAutoscaler",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/watch/namespaces/{namespace}/horizontalpodautoscalers",
      "method": "watchAutoscalingV1NamespacedHorizontalPodAutoscalerList",
      "httpMethod": "get",
      "tag": "autoscaling_v1",
      "typeScriptTag": "autoscalingV1",
      "description": "watch individual changes to a list of HorizontalPodAutoscaler",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v1/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}",
      "method": "watchAutoscalingV1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "get",
      "tag": "autoscaling_v1",
      "typeScriptTag": "autoscalingV1",
      "description": "watch changes to an object of kind HorizontalPodAutoscaler",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2beta1/",
      "method": "getAutoscalingV2Beta1ApiResources",
      "httpMethod": "get",
      "tag": "autoscaling_v2beta1",
      "typeScriptTag": "autoscalingV2Beta1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2beta1/horizontalpodautoscalers",
      "method": "listAutoscalingV2Beta1HorizontalPodAutoscalerForAllNamespaces",
      "httpMethod": "get",
      "tag": "autoscaling_v2beta1",
      "typeScriptTag": "autoscalingV2Beta1",
      "description": "list or watch objects of kind HorizontalPodAutoscaler",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "HorizontalPodAutoscaler is a list of horizontal pod autoscaler objects."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers",
      "method": "deleteAutoscalingV2Beta1CollectionNamespacedHorizontalPodAutoscaler",
      "httpMethod": "delete",
      "tag": "autoscaling_v2beta1",
      "typeScriptTag": "autoscalingV2Beta1",
      "description": "delete collection of HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers",
      "method": "listAutoscalingV2Beta1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "get",
      "tag": "autoscaling_v2beta1",
      "typeScriptTag": "autoscalingV2Beta1",
      "description": "list or watch objects of kind HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "HorizontalPodAutoscaler is a list of horizontal pod autoscaler objects."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers",
      "method": "createAutoscalingV2Beta1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "post",
      "tag": "autoscaling_v2beta1",
      "typeScriptTag": "autoscalingV2Beta1",
      "description": "create a HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        },
        {
          "statusCode": "201",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        },
        {
          "statusCode": "202",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}",
      "method": "deleteAutoscalingV2Beta1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "delete",
      "tag": "autoscaling_v2beta1",
      "typeScriptTag": "autoscalingV2Beta1",
      "description": "delete a HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}",
      "method": "readAutoscalingV2Beta1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "get",
      "tag": "autoscaling_v2beta1",
      "typeScriptTag": "autoscalingV2Beta1",
      "description": "read the specified HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}",
      "method": "patchAutoscalingV2Beta1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "patch",
      "tag": "autoscaling_v2beta1",
      "typeScriptTag": "autoscalingV2Beta1",
      "description": "partially update the specified HorizontalPodAutoscaler",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}",
      "method": "replaceAutoscalingV2Beta1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "put",
      "tag": "autoscaling_v2beta1",
      "typeScriptTag": "autoscalingV2Beta1",
      "description": "replace the specified HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        },
        {
          "statusCode": "201",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status",
      "method": "readAutoscalingV2Beta1NamespacedHorizontalPodAutoscalerStatus",
      "httpMethod": "get",
      "tag": "autoscaling_v2beta1",
      "typeScriptTag": "autoscalingV2Beta1",
      "description": "read status of the specified HorizontalPodAutoscaler",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status",
      "method": "patchAutoscalingV2Beta1NamespacedHorizontalPodAutoscalerStatus",
      "httpMethod": "patch",
      "tag": "autoscaling_v2beta1",
      "typeScriptTag": "autoscalingV2Beta1",
      "description": "partially update status of the specified HorizontalPodAutoscaler",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status",
      "method": "replaceAutoscalingV2Beta1NamespacedHorizontalPodAutoscalerStatus",
      "httpMethod": "put",
      "tag": "autoscaling_v2beta1",
      "typeScriptTag": "autoscalingV2Beta1",
      "description": "replace status of the specified HorizontalPodAutoscaler",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        },
        {
          "statusCode": "201",
          "description": "HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2beta1/watch/horizontalpodautoscalers",
      "method": "watchAutoscalingV2Beta1HorizontalPodAutoscalerListForAllNamespaces",
      "httpMethod": "get",
      "tag": "autoscaling_v2beta1",
      "typeScriptTag": "autoscalingV2Beta1",
      "description": "watch individual changes to a list of HorizontalPodAutoscaler",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2beta1/watch/namespaces/{namespace}/horizontalpodautoscalers",
      "method": "watchAutoscalingV2Beta1NamespacedHorizontalPodAutoscalerList",
      "httpMethod": "get",
      "tag": "autoscaling_v2beta1",
      "typeScriptTag": "autoscalingV2Beta1",
      "description": "watch individual changes to a list of HorizontalPodAutoscaler",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/autoscaling/v2beta1/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}",
      "method": "watchAutoscalingV2Beta1NamespacedHorizontalPodAutoscaler",
      "httpMethod": "get",
      "tag": "autoscaling_v2beta1",
      "typeScriptTag": "autoscalingV2Beta1",
      "description": "watch changes to an object of kind HorizontalPodAutoscaler",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/batch/",
      "method": "getBatchApiGroup",
      "httpMethod": "get",
      "tag": "batch",
      "typeScriptTag": "batch",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/",
      "method": "getBatchV1ApiResources",
      "httpMethod": "get",
      "tag": "batch_v1",
      "typeScriptTag": "batchV1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/jobs",
      "method": "listBatchV1JobForAllNamespaces",
      "httpMethod": "get",
      "tag": "batch_v1",
      "typeScriptTag": "batchV1",
      "description": "list or watch objects of kind Job",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "JobList is a collection of jobs."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/jobs",
      "method": "deleteBatchV1CollectionNamespacedJob",
      "httpMethod": "delete",
      "tag": "batch_v1",
      "typeScriptTag": "batchV1",
      "description": "delete collection of Job",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/jobs",
      "method": "listBatchV1NamespacedJob",
      "httpMethod": "get",
      "tag": "batch_v1",
      "typeScriptTag": "batchV1",
      "description": "list or watch objects of kind Job",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "JobList is a collection of jobs."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/jobs",
      "method": "createBatchV1NamespacedJob",
      "httpMethod": "post",
      "tag": "batch_v1",
      "typeScriptTag": "batchV1",
      "description": "create a Job",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Job represents the configuration of a single job."
        },
        {
          "statusCode": "201",
          "description": "Job represents the configuration of a single job."
        },
        {
          "statusCode": "202",
          "description": "Job represents the configuration of a single job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/jobs/{name}",
      "method": "deleteBatchV1NamespacedJob",
      "httpMethod": "delete",
      "tag": "batch_v1",
      "typeScriptTag": "batchV1",
      "description": "delete a Job",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/jobs/{name}",
      "method": "readBatchV1NamespacedJob",
      "httpMethod": "get",
      "tag": "batch_v1",
      "typeScriptTag": "batchV1",
      "description": "read the specified Job",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Job represents the configuration of a single job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/jobs/{name}",
      "method": "patchBatchV1NamespacedJob",
      "httpMethod": "patch",
      "tag": "batch_v1",
      "typeScriptTag": "batchV1",
      "description": "partially update the specified Job",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Job represents the configuration of a single job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/jobs/{name}",
      "method": "replaceBatchV1NamespacedJob",
      "httpMethod": "put",
      "tag": "batch_v1",
      "typeScriptTag": "batchV1",
      "description": "replace the specified Job",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Job represents the configuration of a single job."
        },
        {
          "statusCode": "201",
          "description": "Job represents the configuration of a single job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status",
      "method": "readBatchV1NamespacedJobStatus",
      "httpMethod": "get",
      "tag": "batch_v1",
      "typeScriptTag": "batchV1",
      "description": "read status of the specified Job",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Job represents the configuration of a single job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status",
      "method": "patchBatchV1NamespacedJobStatus",
      "httpMethod": "patch",
      "tag": "batch_v1",
      "typeScriptTag": "batchV1",
      "description": "partially update status of the specified Job",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Job represents the configuration of a single job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status",
      "method": "replaceBatchV1NamespacedJobStatus",
      "httpMethod": "put",
      "tag": "batch_v1",
      "typeScriptTag": "batchV1",
      "description": "replace status of the specified Job",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Job represents the configuration of a single job."
        },
        {
          "statusCode": "201",
          "description": "Job represents the configuration of a single job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/watch/jobs",
      "method": "watchBatchV1JobListForAllNamespaces",
      "httpMethod": "get",
      "tag": "batch_v1",
      "typeScriptTag": "batchV1",
      "description": "watch individual changes to a list of Job",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/watch/namespaces/{namespace}/jobs",
      "method": "watchBatchV1NamespacedJobList",
      "httpMethod": "get",
      "tag": "batch_v1",
      "typeScriptTag": "batchV1",
      "description": "watch individual changes to a list of Job",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/batch/v1/watch/namespaces/{namespace}/jobs/{name}",
      "method": "watchBatchV1NamespacedJob",
      "httpMethod": "get",
      "tag": "batch_v1",
      "typeScriptTag": "batchV1",
      "description": "watch changes to an object of kind Job",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/batch/v1beta1/",
      "method": "getBatchV1Beta1ApiResources",
      "httpMethod": "get",
      "tag": "batch_v1beta1",
      "typeScriptTag": "batchV1Beta1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/batch/v1beta1/cronjobs",
      "method": "listBatchV1Beta1CronJobForAllNamespaces",
      "httpMethod": "get",
      "tag": "batch_v1beta1",
      "typeScriptTag": "batchV1Beta1",
      "description": "list or watch objects of kind CronJob",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJobList is a collection of cron jobs."
        }
      ]
    },
    {
      "url": "/apis/batch/v1beta1/namespaces/{namespace}/cronjobs",
      "method": "deleteBatchV1Beta1CollectionNamespacedCronJob",
      "httpMethod": "delete",
      "tag": "batch_v1beta1",
      "typeScriptTag": "batchV1Beta1",
      "description": "delete collection of CronJob",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/batch/v1beta1/namespaces/{namespace}/cronjobs",
      "method": "listBatchV1Beta1NamespacedCronJob",
      "httpMethod": "get",
      "tag": "batch_v1beta1",
      "typeScriptTag": "batchV1Beta1",
      "description": "list or watch objects of kind CronJob",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJobList is a collection of cron jobs."
        }
      ]
    },
    {
      "url": "/apis/batch/v1beta1/namespaces/{namespace}/cronjobs",
      "method": "createBatchV1Beta1NamespacedCronJob",
      "httpMethod": "post",
      "tag": "batch_v1beta1",
      "typeScriptTag": "batchV1Beta1",
      "description": "create a CronJob",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        },
        {
          "statusCode": "201",
          "description": "CronJob represents the configuration of a single cron job."
        },
        {
          "statusCode": "202",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}",
      "method": "deleteBatchV1Beta1NamespacedCronJob",
      "httpMethod": "delete",
      "tag": "batch_v1beta1",
      "typeScriptTag": "batchV1Beta1",
      "description": "delete a CronJob",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}",
      "method": "readBatchV1Beta1NamespacedCronJob",
      "httpMethod": "get",
      "tag": "batch_v1beta1",
      "typeScriptTag": "batchV1Beta1",
      "description": "read the specified CronJob",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}",
      "method": "patchBatchV1Beta1NamespacedCronJob",
      "httpMethod": "patch",
      "tag": "batch_v1beta1",
      "typeScriptTag": "batchV1Beta1",
      "description": "partially update the specified CronJob",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}",
      "method": "replaceBatchV1Beta1NamespacedCronJob",
      "httpMethod": "put",
      "tag": "batch_v1beta1",
      "typeScriptTag": "batchV1Beta1",
      "description": "replace the specified CronJob",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        },
        {
          "statusCode": "201",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}/status",
      "method": "readBatchV1Beta1NamespacedCronJobStatus",
      "httpMethod": "get",
      "tag": "batch_v1beta1",
      "typeScriptTag": "batchV1Beta1",
      "description": "read status of the specified CronJob",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}/status",
      "method": "patchBatchV1Beta1NamespacedCronJobStatus",
      "httpMethod": "patch",
      "tag": "batch_v1beta1",
      "typeScriptTag": "batchV1Beta1",
      "description": "partially update status of the specified CronJob",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}/status",
      "method": "replaceBatchV1Beta1NamespacedCronJobStatus",
      "httpMethod": "put",
      "tag": "batch_v1beta1",
      "typeScriptTag": "batchV1Beta1",
      "description": "replace status of the specified CronJob",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        },
        {
          "statusCode": "201",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v1beta1/watch/cronjobs",
      "method": "watchBatchV1Beta1CronJobListForAllNamespaces",
      "httpMethod": "get",
      "tag": "batch_v1beta1",
      "typeScriptTag": "batchV1Beta1",
      "description": "watch individual changes to a list of CronJob",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/batch/v1beta1/watch/namespaces/{namespace}/cronjobs",
      "method": "watchBatchV1Beta1NamespacedCronJobList",
      "httpMethod": "get",
      "tag": "batch_v1beta1",
      "typeScriptTag": "batchV1Beta1",
      "description": "watch individual changes to a list of CronJob",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/batch/v1beta1/watch/namespaces/{namespace}/cronjobs/{name}",
      "method": "watchBatchV1Beta1NamespacedCronJob",
      "httpMethod": "get",
      "tag": "batch_v1beta1",
      "typeScriptTag": "batchV1Beta1",
      "description": "watch changes to an object of kind CronJob",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/batch/v2alpha1/",
      "method": "getBatchV2Alpha1ApiResources",
      "httpMethod": "get",
      "tag": "batch_v2alpha1",
      "typeScriptTag": "batchV2Alpha1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/batch/v2alpha1/cronjobs",
      "method": "listBatchV2Alpha1CronJobForAllNamespaces",
      "httpMethod": "get",
      "tag": "batch_v2alpha1",
      "typeScriptTag": "batchV2Alpha1",
      "description": "list or watch objects of kind CronJob",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJobList is a collection of cron jobs."
        }
      ]
    },
    {
      "url": "/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs",
      "method": "deleteBatchV2Alpha1CollectionNamespacedCronJob",
      "httpMethod": "delete",
      "tag": "batch_v2alpha1",
      "typeScriptTag": "batchV2Alpha1",
      "description": "delete collection of CronJob",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs",
      "method": "listBatchV2Alpha1NamespacedCronJob",
      "httpMethod": "get",
      "tag": "batch_v2alpha1",
      "typeScriptTag": "batchV2Alpha1",
      "description": "list or watch objects of kind CronJob",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJobList is a collection of cron jobs."
        }
      ]
    },
    {
      "url": "/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs",
      "method": "createBatchV2Alpha1NamespacedCronJob",
      "httpMethod": "post",
      "tag": "batch_v2alpha1",
      "typeScriptTag": "batchV2Alpha1",
      "description": "create a CronJob",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        },
        {
          "statusCode": "201",
          "description": "CronJob represents the configuration of a single cron job."
        },
        {
          "statusCode": "202",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}",
      "method": "deleteBatchV2Alpha1NamespacedCronJob",
      "httpMethod": "delete",
      "tag": "batch_v2alpha1",
      "typeScriptTag": "batchV2Alpha1",
      "description": "delete a CronJob",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}",
      "method": "readBatchV2Alpha1NamespacedCronJob",
      "httpMethod": "get",
      "tag": "batch_v2alpha1",
      "typeScriptTag": "batchV2Alpha1",
      "description": "read the specified CronJob",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}",
      "method": "patchBatchV2Alpha1NamespacedCronJob",
      "httpMethod": "patch",
      "tag": "batch_v2alpha1",
      "typeScriptTag": "batchV2Alpha1",
      "description": "partially update the specified CronJob",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}",
      "method": "replaceBatchV2Alpha1NamespacedCronJob",
      "httpMethod": "put",
      "tag": "batch_v2alpha1",
      "typeScriptTag": "batchV2Alpha1",
      "description": "replace the specified CronJob",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        },
        {
          "statusCode": "201",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}/status",
      "method": "readBatchV2Alpha1NamespacedCronJobStatus",
      "httpMethod": "get",
      "tag": "batch_v2alpha1",
      "typeScriptTag": "batchV2Alpha1",
      "description": "read status of the specified CronJob",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}/status",
      "method": "patchBatchV2Alpha1NamespacedCronJobStatus",
      "httpMethod": "patch",
      "tag": "batch_v2alpha1",
      "typeScriptTag": "batchV2Alpha1",
      "description": "partially update status of the specified CronJob",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}/status",
      "method": "replaceBatchV2Alpha1NamespacedCronJobStatus",
      "httpMethod": "put",
      "tag": "batch_v2alpha1",
      "typeScriptTag": "batchV2Alpha1",
      "description": "replace status of the specified CronJob",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "CronJob represents the configuration of a single cron job."
        },
        {
          "statusCode": "201",
          "description": "CronJob represents the configuration of a single cron job."
        }
      ]
    },
    {
      "url": "/apis/batch/v2alpha1/watch/cronjobs",
      "method": "watchBatchV2Alpha1CronJobListForAllNamespaces",
      "httpMethod": "get",
      "tag": "batch_v2alpha1",
      "typeScriptTag": "batchV2Alpha1",
      "description": "watch individual changes to a list of CronJob",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/batch/v2alpha1/watch/namespaces/{namespace}/cronjobs",
      "method": "watchBatchV2Alpha1NamespacedCronJobList",
      "httpMethod": "get",
      "tag": "batch_v2alpha1",
      "typeScriptTag": "batchV2Alpha1",
      "description": "watch individual changes to a list of CronJob",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/batch/v2alpha1/watch/namespaces/{namespace}/cronjobs/{name}",
      "method": "watchBatchV2Alpha1NamespacedCronJob",
      "httpMethod": "get",
      "tag": "batch_v2alpha1",
      "typeScriptTag": "batchV2Alpha1",
      "description": "watch changes to an object of kind CronJob",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/",
      "method": "getCertificatesApiGroup",
      "httpMethod": "get",
      "tag": "certificates",
      "typeScriptTag": "certificates",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1beta1/",
      "method": "getCertificatesV1Beta1ApiResources",
      "httpMethod": "get",
      "tag": "certificates_v1beta1",
      "typeScriptTag": "certificatesV1Beta1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1beta1/certificatesigningrequests",
      "method": "deleteCertificatesV1Beta1CollectionCertificateSigningRequest",
      "httpMethod": "delete",
      "tag": "certificates_v1beta1",
      "typeScriptTag": "certificatesV1Beta1",
      "description": "delete collection of CertificateSigningRequest",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1beta1/certificatesigningrequests",
      "method": "listCertificatesV1Beta1CertificateSigningRequest",
      "httpMethod": "get",
      "tag": "certificates_v1beta1",
      "typeScriptTag": "certificatesV1Beta1",
      "description": "list or watch objects of kind CertificateSigningRequest",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": ""
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1beta1/certificatesigningrequests",
      "method": "createCertificatesV1Beta1CertificateSigningRequest",
      "httpMethod": "post",
      "tag": "certificates_v1beta1",
      "typeScriptTag": "certificatesV1Beta1",
      "description": "create a CertificateSigningRequest",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Describes a certificate signing request"
        },
        {
          "statusCode": "201",
          "description": "Describes a certificate signing request"
        },
        {
          "statusCode": "202",
          "description": "Describes a certificate signing request"
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}",
      "method": "deleteCertificatesV1Beta1CertificateSigningRequest",
      "httpMethod": "delete",
      "tag": "certificates_v1beta1",
      "typeScriptTag": "certificatesV1Beta1",
      "description": "delete a CertificateSigningRequest",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}",
      "method": "readCertificatesV1Beta1CertificateSigningRequest",
      "httpMethod": "get",
      "tag": "certificates_v1beta1",
      "typeScriptTag": "certificatesV1Beta1",
      "description": "read the specified CertificateSigningRequest",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Describes a certificate signing request"
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}",
      "method": "patchCertificatesV1Beta1CertificateSigningRequest",
      "httpMethod": "patch",
      "tag": "certificates_v1beta1",
      "typeScriptTag": "certificatesV1Beta1",
      "description": "partially update the specified CertificateSigningRequest",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Describes a certificate signing request"
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}",
      "method": "replaceCertificatesV1Beta1CertificateSigningRequest",
      "httpMethod": "put",
      "tag": "certificates_v1beta1",
      "typeScriptTag": "certificatesV1Beta1",
      "description": "replace the specified CertificateSigningRequest",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Describes a certificate signing request"
        },
        {
          "statusCode": "201",
          "description": "Describes a certificate signing request"
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}/approval",
      "method": "replaceCertificatesV1Beta1CertificateSigningRequestApproval",
      "httpMethod": "put",
      "tag": "certificates_v1beta1",
      "typeScriptTag": "certificatesV1Beta1",
      "description": "replace approval of the specified CertificateSigningRequest",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Describes a certificate signing request"
        },
        {
          "statusCode": "201",
          "description": "Describes a certificate signing request"
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}/status",
      "method": "replaceCertificatesV1Beta1CertificateSigningRequestStatus",
      "httpMethod": "put",
      "tag": "certificates_v1beta1",
      "typeScriptTag": "certificatesV1Beta1",
      "description": "replace status of the specified CertificateSigningRequest",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Describes a certificate signing request"
        },
        {
          "statusCode": "201",
          "description": "Describes a certificate signing request"
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1beta1/watch/certificatesigningrequests",
      "method": "watchCertificatesV1Beta1CertificateSigningRequestList",
      "httpMethod": "get",
      "tag": "certificates_v1beta1",
      "typeScriptTag": "certificatesV1Beta1",
      "description": "watch individual changes to a list of CertificateSigningRequest",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/certificates.k8s.io/v1beta1/watch/certificatesigningrequests/{name}",
      "method": "watchCertificatesV1Beta1CertificateSigningRequest",
      "httpMethod": "get",
      "tag": "certificates_v1beta1",
      "typeScriptTag": "certificatesV1Beta1",
      "description": "watch changes to an object of kind CertificateSigningRequest",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/",
      "method": "getEventsApiGroup",
      "httpMethod": "get",
      "tag": "events",
      "typeScriptTag": "events",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1beta1/",
      "method": "getEventsV1Beta1ApiResources",
      "httpMethod": "get",
      "tag": "events_v1beta1",
      "typeScriptTag": "eventsV1Beta1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1beta1/events",
      "method": "listEventsV1Beta1EventForAllNamespaces",
      "httpMethod": "get",
      "tag": "events_v1beta1",
      "typeScriptTag": "eventsV1Beta1",
      "description": "list or watch objects of kind Event",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "EventList is a list of Event objects."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events",
      "method": "deleteEventsV1Beta1CollectionNamespacedEvent",
      "httpMethod": "delete",
      "tag": "events_v1beta1",
      "typeScriptTag": "eventsV1Beta1",
      "description": "delete collection of Event",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events",
      "method": "listEventsV1Beta1NamespacedEvent",
      "httpMethod": "get",
      "tag": "events_v1beta1",
      "typeScriptTag": "eventsV1Beta1",
      "description": "list or watch objects of kind Event",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "EventList is a list of Event objects."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events",
      "method": "createEventsV1Beta1NamespacedEvent",
      "httpMethod": "post",
      "tag": "events_v1beta1",
      "typeScriptTag": "eventsV1Beta1",
      "description": "create an Event",
      "parameters": [
        {
          "name": "action",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "deprecatedCount",
          "schema": "integer",
          "required": false,
          "description": ""
        },
        {
          "name": "deprecatedFirstTimestamp",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "deprecatedLastTimestamp",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "deprecatedSource",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "eventTime",
          "schema": "string",
          "required": true,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "note",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "reason",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "regarding",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "related",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "reportingController",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "reportingInstance",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "series",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "type",
          "schema": "string",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system."
        },
        {
          "statusCode": "201",
          "description": "Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system."
        },
        {
          "statusCode": "202",
          "description": "Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}",
      "method": "deleteEventsV1Beta1NamespacedEvent",
      "httpMethod": "delete",
      "tag": "events_v1beta1",
      "typeScriptTag": "eventsV1Beta1",
      "description": "delete an Event",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}",
      "method": "readEventsV1Beta1NamespacedEvent",
      "httpMethod": "get",
      "tag": "events_v1beta1",
      "typeScriptTag": "eventsV1Beta1",
      "description": "read the specified Event",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}",
      "method": "patchEventsV1Beta1NamespacedEvent",
      "httpMethod": "patch",
      "tag": "events_v1beta1",
      "typeScriptTag": "eventsV1Beta1",
      "description": "partially update the specified Event",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}",
      "method": "replaceEventsV1Beta1NamespacedEvent",
      "httpMethod": "put",
      "tag": "events_v1beta1",
      "typeScriptTag": "eventsV1Beta1",
      "description": "replace the specified Event",
      "parameters": [
        {
          "name": "action",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "deprecatedCount",
          "schema": "integer",
          "required": false,
          "description": ""
        },
        {
          "name": "deprecatedFirstTimestamp",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "deprecatedLastTimestamp",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "deprecatedSource",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "eventTime",
          "schema": "string",
          "required": true,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "note",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "reason",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "regarding",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "related",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "reportingController",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "reportingInstance",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "series",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "type",
          "schema": "string",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system."
        },
        {
          "statusCode": "201",
          "description": "Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1beta1/watch/events",
      "method": "watchEventsV1Beta1EventListForAllNamespaces",
      "httpMethod": "get",
      "tag": "events_v1beta1",
      "typeScriptTag": "eventsV1Beta1",
      "description": "watch individual changes to a list of Event",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1beta1/watch/namespaces/{namespace}/events",
      "method": "watchEventsV1Beta1NamespacedEventList",
      "httpMethod": "get",
      "tag": "events_v1beta1",
      "typeScriptTag": "eventsV1Beta1",
      "description": "watch individual changes to a list of Event",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/events.k8s.io/v1beta1/watch/namespaces/{namespace}/events/{name}",
      "method": "watchEventsV1Beta1NamespacedEvent",
      "httpMethod": "get",
      "tag": "events_v1beta1",
      "typeScriptTag": "eventsV1Beta1",
      "description": "watch changes to an object of kind Event",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/",
      "method": "getExtensionsApiGroup",
      "httpMethod": "get",
      "tag": "extensions",
      "typeScriptTag": "extensions",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/",
      "method": "getExtensionsV1Beta1ApiResources",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/daemonsets",
      "method": "listExtensionsV1Beta1DaemonSetForAllNamespaces",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "list or watch objects of kind DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSetList is a collection of daemon sets."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/deployments",
      "method": "listExtensionsV1Beta1DeploymentForAllNamespaces",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "list or watch objects of kind Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DeploymentList is a list of Deployments."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/ingresses",
      "method": "listExtensionsV1Beta1IngressForAllNamespaces",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "list or watch objects of kind Ingress",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "IngressList is a collection of Ingress."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets",
      "method": "deleteExtensionsV1Beta1CollectionNamespacedDaemonSet",
      "httpMethod": "delete",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "delete collection of DaemonSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets",
      "method": "listExtensionsV1Beta1NamespacedDaemonSet",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "list or watch objects of kind DaemonSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DaemonSetList is a collection of daemon sets."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets",
      "method": "createExtensionsV1Beta1NamespacedDaemonSet",
      "httpMethod": "post",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "create a DaemonSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1beta2/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1beta2/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        },
        {
          "statusCode": "202",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1beta2/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}",
      "method": "deleteExtensionsV1Beta1NamespacedDaemonSet",
      "httpMethod": "delete",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "delete a DaemonSet",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}",
      "method": "readExtensionsV1Beta1NamespacedDaemonSet",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "read the specified DaemonSet",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1beta2/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}",
      "method": "patchExtensionsV1Beta1NamespacedDaemonSet",
      "httpMethod": "patch",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "partially update the specified DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1beta2/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}",
      "method": "replaceExtensionsV1Beta1NamespacedDaemonSet",
      "httpMethod": "put",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "replace the specified DaemonSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1beta2/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1beta2/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status",
      "method": "readExtensionsV1Beta1NamespacedDaemonSetStatus",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "read status of the specified DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1beta2/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status",
      "method": "patchExtensionsV1Beta1NamespacedDaemonSetStatus",
      "httpMethod": "patch",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "partially update status of the specified DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1beta2/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status",
      "method": "replaceExtensionsV1Beta1NamespacedDaemonSetStatus",
      "httpMethod": "put",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "replace status of the specified DaemonSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1beta2/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of DaemonSet is deprecated by apps/v1beta2/DaemonSet. See the release notes for more information. DaemonSet represents the configuration of a daemon set."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/deployments",
      "method": "deleteExtensionsV1Beta1CollectionNamespacedDeployment",
      "httpMethod": "delete",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "delete collection of Deployment",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/deployments",
      "method": "listExtensionsV1Beta1NamespacedDeployment",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "list or watch objects of kind Deployment",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DeploymentList is a list of Deployments."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/deployments",
      "method": "createExtensionsV1Beta1NamespacedDeployment",
      "httpMethod": "post",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "create a Deployment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "202",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}",
      "method": "deleteExtensionsV1Beta1NamespacedDeployment",
      "httpMethod": "delete",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "delete a Deployment",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}",
      "method": "readExtensionsV1Beta1NamespacedDeployment",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "read the specified Deployment",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}",
      "method": "patchExtensionsV1Beta1NamespacedDeployment",
      "httpMethod": "patch",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "partially update the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}",
      "method": "replaceExtensionsV1Beta1NamespacedDeployment",
      "httpMethod": "put",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "replace the specified Deployment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/rollback",
      "method": "createExtensionsV1Beta1NamespacedDeploymentRollback",
      "httpMethod": "post",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "create rollback of a Deployment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "name",
          "schema": "string",
          "required": true,
          "description": ""
        },
        {
          "name": "rollbackTo",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "updatedAnnotations",
          "schema": "object",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED. DeploymentRollback stores the information required to rollback a deployment."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED. DeploymentRollback stores the information required to rollback a deployment."
        },
        {
          "statusCode": "202",
          "description": "DEPRECATED. DeploymentRollback stores the information required to rollback a deployment."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale",
      "method": "readExtensionsV1Beta1NamespacedDeploymentScale",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "read scale of the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale",
      "method": "patchExtensionsV1Beta1NamespacedDeploymentScale",
      "httpMethod": "patch",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "partially update scale of the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale",
      "method": "replaceExtensionsV1Beta1NamespacedDeploymentScale",
      "httpMethod": "put",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "replace scale of the specified Deployment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "represents a scaling request for a resource."
        },
        {
          "statusCode": "201",
          "description": "represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status",
      "method": "readExtensionsV1Beta1NamespacedDeploymentStatus",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "read status of the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status",
      "method": "patchExtensionsV1Beta1NamespacedDeploymentStatus",
      "httpMethod": "patch",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "partially update status of the specified Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status",
      "method": "replaceExtensionsV1Beta1NamespacedDeploymentStatus",
      "httpMethod": "put",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "replace status of the specified Deployment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of Deployment is deprecated by apps/v1beta2/Deployment. See the release notes for more information. Deployment enables declarative updates for Pods and ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/ingresses",
      "method": "deleteExtensionsV1Beta1CollectionNamespacedIngress",
      "httpMethod": "delete",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "delete collection of Ingress",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/ingresses",
      "method": "listExtensionsV1Beta1NamespacedIngress",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "list or watch objects of kind Ingress",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "IngressList is a collection of Ingress."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/ingresses",
      "method": "createExtensionsV1Beta1NamespacedIngress",
      "httpMethod": "post",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "create an Ingress",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        },
        {
          "statusCode": "201",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        },
        {
          "statusCode": "202",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}",
      "method": "deleteExtensionsV1Beta1NamespacedIngress",
      "httpMethod": "delete",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "delete an Ingress",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}",
      "method": "readExtensionsV1Beta1NamespacedIngress",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "read the specified Ingress",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}",
      "method": "patchExtensionsV1Beta1NamespacedIngress",
      "httpMethod": "patch",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "partially update the specified Ingress",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}",
      "method": "replaceExtensionsV1Beta1NamespacedIngress",
      "httpMethod": "put",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "replace the specified Ingress",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        },
        {
          "statusCode": "201",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status",
      "method": "readExtensionsV1Beta1NamespacedIngressStatus",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "read status of the specified Ingress",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status",
      "method": "patchExtensionsV1Beta1NamespacedIngressStatus",
      "httpMethod": "patch",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "partially update status of the specified Ingress",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status",
      "method": "replaceExtensionsV1Beta1NamespacedIngressStatus",
      "httpMethod": "put",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "replace status of the specified Ingress",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        },
        {
          "statusCode": "201",
          "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies",
      "method": "deleteExtensionsV1Beta1CollectionNamespacedNetworkPolicy",
      "httpMethod": "delete",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "delete collection of NetworkPolicy",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies",
      "method": "listExtensionsV1Beta1NamespacedNetworkPolicy",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "list or watch objects of kind NetworkPolicy",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED 1.9 - This group version of NetworkPolicyList is deprecated by networking/v1/NetworkPolicyList. Network Policy List is a list of NetworkPolicy objects."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies",
      "method": "createExtensionsV1Beta1NamespacedNetworkPolicy",
      "httpMethod": "post",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "create a NetworkPolicy",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED 1.9 - This group version of NetworkPolicy is deprecated by networking/v1/NetworkPolicy. NetworkPolicy describes what network traffic is allowed for a set of Pods"
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED 1.9 - This group version of NetworkPolicy is deprecated by networking/v1/NetworkPolicy. NetworkPolicy describes what network traffic is allowed for a set of Pods"
        },
        {
          "statusCode": "202",
          "description": "DEPRECATED 1.9 - This group version of NetworkPolicy is deprecated by networking/v1/NetworkPolicy. NetworkPolicy describes what network traffic is allowed for a set of Pods"
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}",
      "method": "deleteExtensionsV1Beta1NamespacedNetworkPolicy",
      "httpMethod": "delete",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "delete a NetworkPolicy",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}",
      "method": "readExtensionsV1Beta1NamespacedNetworkPolicy",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "read the specified NetworkPolicy",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED 1.9 - This group version of NetworkPolicy is deprecated by networking/v1/NetworkPolicy. NetworkPolicy describes what network traffic is allowed for a set of Pods"
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}",
      "method": "patchExtensionsV1Beta1NamespacedNetworkPolicy",
      "httpMethod": "patch",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "partially update the specified NetworkPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED 1.9 - This group version of NetworkPolicy is deprecated by networking/v1/NetworkPolicy. NetworkPolicy describes what network traffic is allowed for a set of Pods"
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}",
      "method": "replaceExtensionsV1Beta1NamespacedNetworkPolicy",
      "httpMethod": "put",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "replace the specified NetworkPolicy",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED 1.9 - This group version of NetworkPolicy is deprecated by networking/v1/NetworkPolicy. NetworkPolicy describes what network traffic is allowed for a set of Pods"
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED 1.9 - This group version of NetworkPolicy is deprecated by networking/v1/NetworkPolicy. NetworkPolicy describes what network traffic is allowed for a set of Pods"
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/replicasets",
      "method": "deleteExtensionsV1Beta1CollectionNamespacedReplicaSet",
      "httpMethod": "delete",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "delete collection of ReplicaSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/replicasets",
      "method": "listExtensionsV1Beta1NamespacedReplicaSet",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "list or watch objects of kind ReplicaSet",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSetList is a collection of ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/replicasets",
      "method": "createExtensionsV1Beta1NamespacedReplicaSet",
      "httpMethod": "post",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "create a ReplicaSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1beta2/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1beta2/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        },
        {
          "statusCode": "202",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1beta2/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}",
      "method": "deleteExtensionsV1Beta1NamespacedReplicaSet",
      "httpMethod": "delete",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "delete a ReplicaSet",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}",
      "method": "readExtensionsV1Beta1NamespacedReplicaSet",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "read the specified ReplicaSet",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1beta2/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}",
      "method": "patchExtensionsV1Beta1NamespacedReplicaSet",
      "httpMethod": "patch",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "partially update the specified ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1beta2/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}",
      "method": "replaceExtensionsV1Beta1NamespacedReplicaSet",
      "httpMethod": "put",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "replace the specified ReplicaSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1beta2/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1beta2/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale",
      "method": "readExtensionsV1Beta1NamespacedReplicaSetScale",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "read scale of the specified ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale",
      "method": "patchExtensionsV1Beta1NamespacedReplicaSetScale",
      "httpMethod": "patch",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "partially update scale of the specified ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale",
      "method": "replaceExtensionsV1Beta1NamespacedReplicaSetScale",
      "httpMethod": "put",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "replace scale of the specified ReplicaSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "represents a scaling request for a resource."
        },
        {
          "statusCode": "201",
          "description": "represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status",
      "method": "readExtensionsV1Beta1NamespacedReplicaSetStatus",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "read status of the specified ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1beta2/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status",
      "method": "patchExtensionsV1Beta1NamespacedReplicaSetStatus",
      "httpMethod": "patch",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "partially update status of the specified ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1beta2/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status",
      "method": "replaceExtensionsV1Beta1NamespacedReplicaSetStatus",
      "httpMethod": "put",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "replace status of the specified ReplicaSet",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1beta2/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        },
        {
          "statusCode": "201",
          "description": "DEPRECATED - This group version of ReplicaSet is deprecated by apps/v1beta2/ReplicaSet. See the release notes for more information. ReplicaSet ensures that a specified number of pod replicas are running at any given time."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale",
      "method": "readExtensionsV1Beta1NamespacedReplicationControllerDummyScale",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "read scale of the specified ReplicationControllerDummy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale",
      "method": "patchExtensionsV1Beta1NamespacedReplicationControllerDummyScale",
      "httpMethod": "patch",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "partially update scale of the specified ReplicationControllerDummy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale",
      "method": "replaceExtensionsV1Beta1NamespacedReplicationControllerDummyScale",
      "httpMethod": "put",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "replace scale of the specified ReplicationControllerDummy",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "represents a scaling request for a resource."
        },
        {
          "statusCode": "201",
          "description": "represents a scaling request for a resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/networkpolicies",
      "method": "listExtensionsV1Beta1NetworkPolicyForAllNamespaces",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "list or watch objects of kind NetworkPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "DEPRECATED 1.9 - This group version of NetworkPolicyList is deprecated by networking/v1/NetworkPolicyList. Network Policy List is a list of NetworkPolicy objects."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/podsecuritypolicies",
      "method": "deleteExtensionsV1Beta1CollectionPodSecurityPolicy",
      "httpMethod": "delete",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "delete collection of PodSecurityPolicy",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/podsecuritypolicies",
      "method": "listExtensionsV1Beta1PodSecurityPolicy",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "list or watch objects of kind PodSecurityPolicy",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod Security Policy List is a list of PodSecurityPolicy objects."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/podsecuritypolicies",
      "method": "createExtensionsV1Beta1PodSecurityPolicy",
      "httpMethod": "post",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "create a PodSecurityPolicy",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod Security Policy governs the ability to make requests that affect the Security Context that will be applied to a pod and container."
        },
        {
          "statusCode": "201",
          "description": "Pod Security Policy governs the ability to make requests that affect the Security Context that will be applied to a pod and container."
        },
        {
          "statusCode": "202",
          "description": "Pod Security Policy governs the ability to make requests that affect the Security Context that will be applied to a pod and container."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/podsecuritypolicies/{name}",
      "method": "deleteExtensionsV1Beta1PodSecurityPolicy",
      "httpMethod": "delete",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "delete a PodSecurityPolicy",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/podsecuritypolicies/{name}",
      "method": "readExtensionsV1Beta1PodSecurityPolicy",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "read the specified PodSecurityPolicy",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod Security Policy governs the ability to make requests that affect the Security Context that will be applied to a pod and container."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/podsecuritypolicies/{name}",
      "method": "patchExtensionsV1Beta1PodSecurityPolicy",
      "httpMethod": "patch",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "partially update the specified PodSecurityPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod Security Policy governs the ability to make requests that affect the Security Context that will be applied to a pod and container."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/podsecuritypolicies/{name}",
      "method": "replaceExtensionsV1Beta1PodSecurityPolicy",
      "httpMethod": "put",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "replace the specified PodSecurityPolicy",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod Security Policy governs the ability to make requests that affect the Security Context that will be applied to a pod and container."
        },
        {
          "statusCode": "201",
          "description": "Pod Security Policy governs the ability to make requests that affect the Security Context that will be applied to a pod and container."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/replicasets",
      "method": "listExtensionsV1Beta1ReplicaSetForAllNamespaces",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "list or watch objects of kind ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ReplicaSetList is a collection of ReplicaSets."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/watch/daemonsets",
      "method": "watchExtensionsV1Beta1DaemonSetListForAllNamespaces",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "watch individual changes to a list of DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/watch/deployments",
      "method": "watchExtensionsV1Beta1DeploymentListForAllNamespaces",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "watch individual changes to a list of Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/watch/ingresses",
      "method": "watchExtensionsV1Beta1IngressListForAllNamespaces",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "watch individual changes to a list of Ingress",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/watch/namespaces/{namespace}/daemonsets",
      "method": "watchExtensionsV1Beta1NamespacedDaemonSetList",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "watch individual changes to a list of DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/watch/namespaces/{namespace}/daemonsets/{name}",
      "method": "watchExtensionsV1Beta1NamespacedDaemonSet",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "watch changes to an object of kind DaemonSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/watch/namespaces/{namespace}/deployments",
      "method": "watchExtensionsV1Beta1NamespacedDeploymentList",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "watch individual changes to a list of Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/watch/namespaces/{namespace}/deployments/{name}",
      "method": "watchExtensionsV1Beta1NamespacedDeployment",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "watch changes to an object of kind Deployment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/watch/namespaces/{namespace}/ingresses",
      "method": "watchExtensionsV1Beta1NamespacedIngressList",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "watch individual changes to a list of Ingress",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/watch/namespaces/{namespace}/ingresses/{name}",
      "method": "watchExtensionsV1Beta1NamespacedIngress",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "watch changes to an object of kind Ingress",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/watch/namespaces/{namespace}/networkpolicies",
      "method": "watchExtensionsV1Beta1NamespacedNetworkPolicyList",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "watch individual changes to a list of NetworkPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/watch/namespaces/{namespace}/networkpolicies/{name}",
      "method": "watchExtensionsV1Beta1NamespacedNetworkPolicy",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "watch changes to an object of kind NetworkPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/watch/namespaces/{namespace}/replicasets",
      "method": "watchExtensionsV1Beta1NamespacedReplicaSetList",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "watch individual changes to a list of ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/watch/namespaces/{namespace}/replicasets/{name}",
      "method": "watchExtensionsV1Beta1NamespacedReplicaSet",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "watch changes to an object of kind ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/watch/networkpolicies",
      "method": "watchExtensionsV1Beta1NetworkPolicyListForAllNamespaces",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "watch individual changes to a list of NetworkPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/watch/podsecuritypolicies",
      "method": "watchExtensionsV1Beta1PodSecurityPolicyList",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "watch individual changes to a list of PodSecurityPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/watch/podsecuritypolicies/{name}",
      "method": "watchExtensionsV1Beta1PodSecurityPolicy",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "watch changes to an object of kind PodSecurityPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/extensions/v1beta1/watch/replicasets",
      "method": "watchExtensionsV1Beta1ReplicaSetListForAllNamespaces",
      "httpMethod": "get",
      "tag": "extensions_v1beta1",
      "typeScriptTag": "extensionsV1Beta1",
      "description": "watch individual changes to a list of ReplicaSet",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/",
      "method": "getNetworkingApiGroup",
      "httpMethod": "get",
      "tag": "networking",
      "typeScriptTag": "networking",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/",
      "method": "getNetworkingV1ApiResources",
      "httpMethod": "get",
      "tag": "networking_v1",
      "typeScriptTag": "networkingV1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies",
      "method": "deleteNetworkingV1CollectionNamespacedNetworkPolicy",
      "httpMethod": "delete",
      "tag": "networking_v1",
      "typeScriptTag": "networkingV1",
      "description": "delete collection of NetworkPolicy",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies",
      "method": "listNetworkingV1NamespacedNetworkPolicy",
      "httpMethod": "get",
      "tag": "networking_v1",
      "typeScriptTag": "networkingV1",
      "description": "list or watch objects of kind NetworkPolicy",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "NetworkPolicyList is a list of NetworkPolicy objects."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies",
      "method": "createNetworkingV1NamespacedNetworkPolicy",
      "httpMethod": "post",
      "tag": "networking_v1",
      "typeScriptTag": "networkingV1",
      "description": "create a NetworkPolicy",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
        },
        {
          "statusCode": "201",
          "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
        },
        {
          "statusCode": "202",
          "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}",
      "method": "deleteNetworkingV1NamespacedNetworkPolicy",
      "httpMethod": "delete",
      "tag": "networking_v1",
      "typeScriptTag": "networkingV1",
      "description": "delete a NetworkPolicy",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}",
      "method": "readNetworkingV1NamespacedNetworkPolicy",
      "httpMethod": "get",
      "tag": "networking_v1",
      "typeScriptTag": "networkingV1",
      "description": "read the specified NetworkPolicy",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}",
      "method": "patchNetworkingV1NamespacedNetworkPolicy",
      "httpMethod": "patch",
      "tag": "networking_v1",
      "typeScriptTag": "networkingV1",
      "description": "partially update the specified NetworkPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}",
      "method": "replaceNetworkingV1NamespacedNetworkPolicy",
      "httpMethod": "put",
      "tag": "networking_v1",
      "typeScriptTag": "networkingV1",
      "description": "replace the specified NetworkPolicy",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
        },
        {
          "statusCode": "201",
          "description": "NetworkPolicy describes what network traffic is allowed for a set of Pods"
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/networkpolicies",
      "method": "listNetworkingV1NetworkPolicyForAllNamespaces",
      "httpMethod": "get",
      "tag": "networking_v1",
      "typeScriptTag": "networkingV1",
      "description": "list or watch objects of kind NetworkPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "NetworkPolicyList is a list of NetworkPolicy objects."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/watch/namespaces/{namespace}/networkpolicies",
      "method": "watchNetworkingV1NamespacedNetworkPolicyList",
      "httpMethod": "get",
      "tag": "networking_v1",
      "typeScriptTag": "networkingV1",
      "description": "watch individual changes to a list of NetworkPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/watch/namespaces/{namespace}/networkpolicies/{name}",
      "method": "watchNetworkingV1NamespacedNetworkPolicy",
      "httpMethod": "get",
      "tag": "networking_v1",
      "typeScriptTag": "networkingV1",
      "description": "watch changes to an object of kind NetworkPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/networking.k8s.io/v1/watch/networkpolicies",
      "method": "watchNetworkingV1NetworkPolicyListForAllNamespaces",
      "httpMethod": "get",
      "tag": "networking_v1",
      "typeScriptTag": "networkingV1",
      "description": "watch individual changes to a list of NetworkPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/policy/",
      "method": "getPolicyApiGroup",
      "httpMethod": "get",
      "tag": "policy",
      "typeScriptTag": "policy",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/",
      "method": "getPolicyV1Beta1ApiResources",
      "httpMethod": "get",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets",
      "method": "deletePolicyV1Beta1CollectionNamespacedPodDisruptionBudget",
      "httpMethod": "delete",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "delete collection of PodDisruptionBudget",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets",
      "method": "listPolicyV1Beta1NamespacedPodDisruptionBudget",
      "httpMethod": "get",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "list or watch objects of kind PodDisruptionBudget",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodDisruptionBudgetList is a collection of PodDisruptionBudgets."
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets",
      "method": "createPolicyV1Beta1NamespacedPodDisruptionBudget",
      "httpMethod": "post",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "create a PodDisruptionBudget",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        },
        {
          "statusCode": "201",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        },
        {
          "statusCode": "202",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}",
      "method": "deletePolicyV1Beta1NamespacedPodDisruptionBudget",
      "httpMethod": "delete",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "delete a PodDisruptionBudget",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}",
      "method": "readPolicyV1Beta1NamespacedPodDisruptionBudget",
      "httpMethod": "get",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "read the specified PodDisruptionBudget",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}",
      "method": "patchPolicyV1Beta1NamespacedPodDisruptionBudget",
      "httpMethod": "patch",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "partially update the specified PodDisruptionBudget",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}",
      "method": "replacePolicyV1Beta1NamespacedPodDisruptionBudget",
      "httpMethod": "put",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "replace the specified PodDisruptionBudget",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        },
        {
          "statusCode": "201",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status",
      "method": "readPolicyV1Beta1NamespacedPodDisruptionBudgetStatus",
      "httpMethod": "get",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "read status of the specified PodDisruptionBudget",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status",
      "method": "patchPolicyV1Beta1NamespacedPodDisruptionBudgetStatus",
      "httpMethod": "patch",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "partially update status of the specified PodDisruptionBudget",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status",
      "method": "replacePolicyV1Beta1NamespacedPodDisruptionBudgetStatus",
      "httpMethod": "put",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "replace status of the specified PodDisruptionBudget",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        },
        {
          "statusCode": "201",
          "description": "PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods"
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/poddisruptionbudgets",
      "method": "listPolicyV1Beta1PodDisruptionBudgetForAllNamespaces",
      "httpMethod": "get",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "list or watch objects of kind PodDisruptionBudget",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodDisruptionBudgetList is a collection of PodDisruptionBudgets."
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/podsecuritypolicies",
      "method": "deletePolicyV1Beta1CollectionPodSecurityPolicy",
      "httpMethod": "delete",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "delete collection of PodSecurityPolicy",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/podsecuritypolicies",
      "method": "listPolicyV1Beta1PodSecurityPolicy",
      "httpMethod": "get",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "list or watch objects of kind PodSecurityPolicy",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod Security Policy List is a list of PodSecurityPolicy objects."
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/podsecuritypolicies",
      "method": "createPolicyV1Beta1PodSecurityPolicy",
      "httpMethod": "post",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "create a PodSecurityPolicy",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod Security Policy governs the ability to make requests that affect the Security Context that will be applied to a pod and container."
        },
        {
          "statusCode": "201",
          "description": "Pod Security Policy governs the ability to make requests that affect the Security Context that will be applied to a pod and container."
        },
        {
          "statusCode": "202",
          "description": "Pod Security Policy governs the ability to make requests that affect the Security Context that will be applied to a pod and container."
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/podsecuritypolicies/{name}",
      "method": "deletePolicyV1Beta1PodSecurityPolicy",
      "httpMethod": "delete",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "delete a PodSecurityPolicy",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/podsecuritypolicies/{name}",
      "method": "readPolicyV1Beta1PodSecurityPolicy",
      "httpMethod": "get",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "read the specified PodSecurityPolicy",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod Security Policy governs the ability to make requests that affect the Security Context that will be applied to a pod and container."
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/podsecuritypolicies/{name}",
      "method": "patchPolicyV1Beta1PodSecurityPolicy",
      "httpMethod": "patch",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "partially update the specified PodSecurityPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod Security Policy governs the ability to make requests that affect the Security Context that will be applied to a pod and container."
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/podsecuritypolicies/{name}",
      "method": "replacePolicyV1Beta1PodSecurityPolicy",
      "httpMethod": "put",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "replace the specified PodSecurityPolicy",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Pod Security Policy governs the ability to make requests that affect the Security Context that will be applied to a pod and container."
        },
        {
          "statusCode": "201",
          "description": "Pod Security Policy governs the ability to make requests that affect the Security Context that will be applied to a pod and container."
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/watch/namespaces/{namespace}/poddisruptionbudgets",
      "method": "watchPolicyV1Beta1NamespacedPodDisruptionBudgetList",
      "httpMethod": "get",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "watch individual changes to a list of PodDisruptionBudget",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/watch/namespaces/{namespace}/poddisruptionbudgets/{name}",
      "method": "watchPolicyV1Beta1NamespacedPodDisruptionBudget",
      "httpMethod": "get",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "watch changes to an object of kind PodDisruptionBudget",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/watch/poddisruptionbudgets",
      "method": "watchPolicyV1Beta1PodDisruptionBudgetListForAllNamespaces",
      "httpMethod": "get",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "watch individual changes to a list of PodDisruptionBudget",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/watch/podsecuritypolicies",
      "method": "watchPolicyV1Beta1PodSecurityPolicyList",
      "httpMethod": "get",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "watch individual changes to a list of PodSecurityPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/policy/v1beta1/watch/podsecuritypolicies/{name}",
      "method": "watchPolicyV1Beta1PodSecurityPolicy",
      "httpMethod": "get",
      "tag": "policy_v1beta1",
      "typeScriptTag": "policyV1Beta1",
      "description": "watch changes to an object of kind PodSecurityPolicy",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/",
      "method": "getRbacAuthorizationApiGroup",
      "httpMethod": "get",
      "tag": "rbacAuthorization",
      "typeScriptTag": "rbacAuthorization",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/",
      "method": "getRbacAuthorizationV1ApiResources",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings",
      "method": "deleteRbacAuthorizationV1CollectionClusterRoleBinding",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "delete collection of ClusterRoleBinding",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings",
      "method": "listRbacAuthorizationV1ClusterRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "list or watch objects of kind ClusterRoleBinding",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleBindingList is a collection of ClusterRoleBindings"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings",
      "method": "createRbacAuthorizationV1ClusterRoleBinding",
      "httpMethod": "post",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "create a ClusterRoleBinding",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "roleRef",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "subjects",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        },
        {
          "statusCode": "201",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        },
        {
          "statusCode": "202",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}",
      "method": "deleteRbacAuthorizationV1ClusterRoleBinding",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "delete a ClusterRoleBinding",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}",
      "method": "readRbacAuthorizationV1ClusterRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "read the specified ClusterRoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}",
      "method": "patchRbacAuthorizationV1ClusterRoleBinding",
      "httpMethod": "patch",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "partially update the specified ClusterRoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}",
      "method": "replaceRbacAuthorizationV1ClusterRoleBinding",
      "httpMethod": "put",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "replace the specified ClusterRoleBinding",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "roleRef",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "subjects",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        },
        {
          "statusCode": "201",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterroles",
      "method": "deleteRbacAuthorizationV1CollectionClusterRole",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "delete collection of ClusterRole",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterroles",
      "method": "listRbacAuthorizationV1ClusterRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "list or watch objects of kind ClusterRole",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleList is a collection of ClusterRoles"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterroles",
      "method": "createRbacAuthorizationV1ClusterRole",
      "httpMethod": "post",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "create a ClusterRole",
      "parameters": [
        {
          "name": "aggregationRule",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "rules",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        },
        {
          "statusCode": "201",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        },
        {
          "statusCode": "202",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}",
      "method": "deleteRbacAuthorizationV1ClusterRole",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "delete a ClusterRole",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}",
      "method": "readRbacAuthorizationV1ClusterRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "read the specified ClusterRole",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}",
      "method": "patchRbacAuthorizationV1ClusterRole",
      "httpMethod": "patch",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "partially update the specified ClusterRole",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}",
      "method": "replaceRbacAuthorizationV1ClusterRole",
      "httpMethod": "put",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "replace the specified ClusterRole",
      "parameters": [
        {
          "name": "aggregationRule",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "rules",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        },
        {
          "statusCode": "201",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings",
      "method": "deleteRbacAuthorizationV1CollectionNamespacedRoleBinding",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "delete collection of RoleBinding",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings",
      "method": "listRbacAuthorizationV1NamespacedRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "list or watch objects of kind RoleBinding",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBindingList is a collection of RoleBindings"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings",
      "method": "createRbacAuthorizationV1NamespacedRoleBinding",
      "httpMethod": "post",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "create a RoleBinding",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "roleRef",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "subjects",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        },
        {
          "statusCode": "201",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        },
        {
          "statusCode": "202",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}",
      "method": "deleteRbacAuthorizationV1NamespacedRoleBinding",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "delete a RoleBinding",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}",
      "method": "readRbacAuthorizationV1NamespacedRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "read the specified RoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}",
      "method": "patchRbacAuthorizationV1NamespacedRoleBinding",
      "httpMethod": "patch",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "partially update the specified RoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}",
      "method": "replaceRbacAuthorizationV1NamespacedRoleBinding",
      "httpMethod": "put",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "replace the specified RoleBinding",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "roleRef",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "subjects",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        },
        {
          "statusCode": "201",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles",
      "method": "deleteRbacAuthorizationV1CollectionNamespacedRole",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "delete collection of Role",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles",
      "method": "listRbacAuthorizationV1NamespacedRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "list or watch objects of kind Role",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleList is a collection of Roles"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles",
      "method": "createRbacAuthorizationV1NamespacedRole",
      "httpMethod": "post",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "create a Role",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "rules",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        },
        {
          "statusCode": "201",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        },
        {
          "statusCode": "202",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}",
      "method": "deleteRbacAuthorizationV1NamespacedRole",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "delete a Role",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}",
      "method": "readRbacAuthorizationV1NamespacedRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "read the specified Role",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}",
      "method": "patchRbacAuthorizationV1NamespacedRole",
      "httpMethod": "patch",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "partially update the specified Role",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}",
      "method": "replaceRbacAuthorizationV1NamespacedRole",
      "httpMethod": "put",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "replace the specified Role",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "rules",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        },
        {
          "statusCode": "201",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/rolebindings",
      "method": "listRbacAuthorizationV1RoleBindingForAllNamespaces",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "list or watch objects of kind RoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBindingList is a collection of RoleBindings"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/roles",
      "method": "listRbacAuthorizationV1RoleForAllNamespaces",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "list or watch objects of kind Role",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleList is a collection of Roles"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/watch/clusterrolebindings",
      "method": "watchRbacAuthorizationV1ClusterRoleBindingList",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "watch individual changes to a list of ClusterRoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/watch/clusterrolebindings/{name}",
      "method": "watchRbacAuthorizationV1ClusterRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "watch changes to an object of kind ClusterRoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/watch/clusterroles",
      "method": "watchRbacAuthorizationV1ClusterRoleList",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "watch individual changes to a list of ClusterRole",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/watch/clusterroles/{name}",
      "method": "watchRbacAuthorizationV1ClusterRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "watch changes to an object of kind ClusterRole",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/rolebindings",
      "method": "watchRbacAuthorizationV1NamespacedRoleBindingList",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "watch individual changes to a list of RoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/rolebindings/{name}",
      "method": "watchRbacAuthorizationV1NamespacedRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "watch changes to an object of kind RoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/roles",
      "method": "watchRbacAuthorizationV1NamespacedRoleList",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "watch individual changes to a list of Role",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/watch/namespaces/{namespace}/roles/{name}",
      "method": "watchRbacAuthorizationV1NamespacedRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "watch changes to an object of kind Role",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/watch/rolebindings",
      "method": "watchRbacAuthorizationV1RoleBindingListForAllNamespaces",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "watch individual changes to a list of RoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1/watch/roles",
      "method": "watchRbacAuthorizationV1RoleListForAllNamespaces",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1",
      "typeScriptTag": "rbacAuthorizationV1",
      "description": "watch individual changes to a list of Role",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/",
      "method": "getRbacAuthorizationV1Alpha1ApiResources",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings",
      "method": "deleteRbacAuthorizationV1Alpha1CollectionClusterRoleBinding",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "delete collection of ClusterRoleBinding",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings",
      "method": "listRbacAuthorizationV1Alpha1ClusterRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "list or watch objects of kind ClusterRoleBinding",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleBindingList is a collection of ClusterRoleBindings"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings",
      "method": "createRbacAuthorizationV1Alpha1ClusterRoleBinding",
      "httpMethod": "post",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "create a ClusterRoleBinding",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "roleRef",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "subjects",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        },
        {
          "statusCode": "201",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        },
        {
          "statusCode": "202",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}",
      "method": "deleteRbacAuthorizationV1Alpha1ClusterRoleBinding",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "delete a ClusterRoleBinding",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}",
      "method": "readRbacAuthorizationV1Alpha1ClusterRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "read the specified ClusterRoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}",
      "method": "patchRbacAuthorizationV1Alpha1ClusterRoleBinding",
      "httpMethod": "patch",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "partially update the specified ClusterRoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}",
      "method": "replaceRbacAuthorizationV1Alpha1ClusterRoleBinding",
      "httpMethod": "put",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "replace the specified ClusterRoleBinding",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "roleRef",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "subjects",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        },
        {
          "statusCode": "201",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles",
      "method": "deleteRbacAuthorizationV1Alpha1CollectionClusterRole",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "delete collection of ClusterRole",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles",
      "method": "listRbacAuthorizationV1Alpha1ClusterRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "list or watch objects of kind ClusterRole",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleList is a collection of ClusterRoles"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles",
      "method": "createRbacAuthorizationV1Alpha1ClusterRole",
      "httpMethod": "post",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "create a ClusterRole",
      "parameters": [
        {
          "name": "aggregationRule",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "rules",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        },
        {
          "statusCode": "201",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        },
        {
          "statusCode": "202",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}",
      "method": "deleteRbacAuthorizationV1Alpha1ClusterRole",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "delete a ClusterRole",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}",
      "method": "readRbacAuthorizationV1Alpha1ClusterRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "read the specified ClusterRole",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}",
      "method": "patchRbacAuthorizationV1Alpha1ClusterRole",
      "httpMethod": "patch",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "partially update the specified ClusterRole",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}",
      "method": "replaceRbacAuthorizationV1Alpha1ClusterRole",
      "httpMethod": "put",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "replace the specified ClusterRole",
      "parameters": [
        {
          "name": "aggregationRule",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "rules",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        },
        {
          "statusCode": "201",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings",
      "method": "deleteRbacAuthorizationV1Alpha1CollectionNamespacedRoleBinding",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "delete collection of RoleBinding",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings",
      "method": "listRbacAuthorizationV1Alpha1NamespacedRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "list or watch objects of kind RoleBinding",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBindingList is a collection of RoleBindings"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings",
      "method": "createRbacAuthorizationV1Alpha1NamespacedRoleBinding",
      "httpMethod": "post",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "create a RoleBinding",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "roleRef",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "subjects",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        },
        {
          "statusCode": "201",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        },
        {
          "statusCode": "202",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}",
      "method": "deleteRbacAuthorizationV1Alpha1NamespacedRoleBinding",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "delete a RoleBinding",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}",
      "method": "readRbacAuthorizationV1Alpha1NamespacedRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "read the specified RoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}",
      "method": "patchRbacAuthorizationV1Alpha1NamespacedRoleBinding",
      "httpMethod": "patch",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "partially update the specified RoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}",
      "method": "replaceRbacAuthorizationV1Alpha1NamespacedRoleBinding",
      "httpMethod": "put",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "replace the specified RoleBinding",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "roleRef",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "subjects",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        },
        {
          "statusCode": "201",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles",
      "method": "deleteRbacAuthorizationV1Alpha1CollectionNamespacedRole",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "delete collection of Role",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles",
      "method": "listRbacAuthorizationV1Alpha1NamespacedRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "list or watch objects of kind Role",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleList is a collection of Roles"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles",
      "method": "createRbacAuthorizationV1Alpha1NamespacedRole",
      "httpMethod": "post",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "create a Role",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "rules",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        },
        {
          "statusCode": "201",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        },
        {
          "statusCode": "202",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}",
      "method": "deleteRbacAuthorizationV1Alpha1NamespacedRole",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "delete a Role",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}",
      "method": "readRbacAuthorizationV1Alpha1NamespacedRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "read the specified Role",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}",
      "method": "patchRbacAuthorizationV1Alpha1NamespacedRole",
      "httpMethod": "patch",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "partially update the specified Role",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}",
      "method": "replaceRbacAuthorizationV1Alpha1NamespacedRole",
      "httpMethod": "put",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "replace the specified Role",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "rules",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        },
        {
          "statusCode": "201",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/rolebindings",
      "method": "listRbacAuthorizationV1Alpha1RoleBindingForAllNamespaces",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "list or watch objects of kind RoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBindingList is a collection of RoleBindings"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/roles",
      "method": "listRbacAuthorizationV1Alpha1RoleForAllNamespaces",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "list or watch objects of kind Role",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleList is a collection of Roles"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/watch/clusterrolebindings",
      "method": "watchRbacAuthorizationV1Alpha1ClusterRoleBindingList",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "watch individual changes to a list of ClusterRoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/watch/clusterrolebindings/{name}",
      "method": "watchRbacAuthorizationV1Alpha1ClusterRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "watch changes to an object of kind ClusterRoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/watch/clusterroles",
      "method": "watchRbacAuthorizationV1Alpha1ClusterRoleList",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "watch individual changes to a list of ClusterRole",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/watch/clusterroles/{name}",
      "method": "watchRbacAuthorizationV1Alpha1ClusterRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "watch changes to an object of kind ClusterRole",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/watch/namespaces/{namespace}/rolebindings",
      "method": "watchRbacAuthorizationV1Alpha1NamespacedRoleBindingList",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "watch individual changes to a list of RoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/watch/namespaces/{namespace}/rolebindings/{name}",
      "method": "watchRbacAuthorizationV1Alpha1NamespacedRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "watch changes to an object of kind RoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/watch/namespaces/{namespace}/roles",
      "method": "watchRbacAuthorizationV1Alpha1NamespacedRoleList",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "watch individual changes to a list of Role",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/watch/namespaces/{namespace}/roles/{name}",
      "method": "watchRbacAuthorizationV1Alpha1NamespacedRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "watch changes to an object of kind Role",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/watch/rolebindings",
      "method": "watchRbacAuthorizationV1Alpha1RoleBindingListForAllNamespaces",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "watch individual changes to a list of RoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1alpha1/watch/roles",
      "method": "watchRbacAuthorizationV1Alpha1RoleListForAllNamespaces",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1alpha1",
      "typeScriptTag": "rbacAuthorizationV1Alpha1",
      "description": "watch individual changes to a list of Role",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/",
      "method": "getRbacAuthorizationV1Beta1ApiResources",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings",
      "method": "deleteRbacAuthorizationV1Beta1CollectionClusterRoleBinding",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "delete collection of ClusterRoleBinding",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings",
      "method": "listRbacAuthorizationV1Beta1ClusterRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "list or watch objects of kind ClusterRoleBinding",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleBindingList is a collection of ClusterRoleBindings"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings",
      "method": "createRbacAuthorizationV1Beta1ClusterRoleBinding",
      "httpMethod": "post",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "create a ClusterRoleBinding",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "roleRef",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "subjects",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        },
        {
          "statusCode": "201",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        },
        {
          "statusCode": "202",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}",
      "method": "deleteRbacAuthorizationV1Beta1ClusterRoleBinding",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "delete a ClusterRoleBinding",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}",
      "method": "readRbacAuthorizationV1Beta1ClusterRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "read the specified ClusterRoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}",
      "method": "patchRbacAuthorizationV1Beta1ClusterRoleBinding",
      "httpMethod": "patch",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "partially update the specified ClusterRoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}",
      "method": "replaceRbacAuthorizationV1Beta1ClusterRoleBinding",
      "httpMethod": "put",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "replace the specified ClusterRoleBinding",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "roleRef",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "subjects",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        },
        {
          "statusCode": "201",
          "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/clusterroles",
      "method": "deleteRbacAuthorizationV1Beta1CollectionClusterRole",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "delete collection of ClusterRole",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/clusterroles",
      "method": "listRbacAuthorizationV1Beta1ClusterRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "list or watch objects of kind ClusterRole",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRoleList is a collection of ClusterRoles"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/clusterroles",
      "method": "createRbacAuthorizationV1Beta1ClusterRole",
      "httpMethod": "post",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "create a ClusterRole",
      "parameters": [
        {
          "name": "aggregationRule",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "rules",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        },
        {
          "statusCode": "201",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        },
        {
          "statusCode": "202",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}",
      "method": "deleteRbacAuthorizationV1Beta1ClusterRole",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "delete a ClusterRole",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}",
      "method": "readRbacAuthorizationV1Beta1ClusterRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "read the specified ClusterRole",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}",
      "method": "patchRbacAuthorizationV1Beta1ClusterRole",
      "httpMethod": "patch",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "partially update the specified ClusterRole",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}",
      "method": "replaceRbacAuthorizationV1Beta1ClusterRole",
      "httpMethod": "put",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "replace the specified ClusterRole",
      "parameters": [
        {
          "name": "aggregationRule",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "rules",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        },
        {
          "statusCode": "201",
          "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings",
      "method": "deleteRbacAuthorizationV1Beta1CollectionNamespacedRoleBinding",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "delete collection of RoleBinding",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings",
      "method": "listRbacAuthorizationV1Beta1NamespacedRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "list or watch objects of kind RoleBinding",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBindingList is a collection of RoleBindings"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings",
      "method": "createRbacAuthorizationV1Beta1NamespacedRoleBinding",
      "httpMethod": "post",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "create a RoleBinding",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "roleRef",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "subjects",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        },
        {
          "statusCode": "201",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        },
        {
          "statusCode": "202",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}",
      "method": "deleteRbacAuthorizationV1Beta1NamespacedRoleBinding",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "delete a RoleBinding",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}",
      "method": "readRbacAuthorizationV1Beta1NamespacedRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "read the specified RoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}",
      "method": "patchRbacAuthorizationV1Beta1NamespacedRoleBinding",
      "httpMethod": "patch",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "partially update the specified RoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}",
      "method": "replaceRbacAuthorizationV1Beta1NamespacedRoleBinding",
      "httpMethod": "put",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "replace the specified RoleBinding",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "roleRef",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "subjects",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        },
        {
          "statusCode": "201",
          "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles",
      "method": "deleteRbacAuthorizationV1Beta1CollectionNamespacedRole",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "delete collection of Role",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles",
      "method": "listRbacAuthorizationV1Beta1NamespacedRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "list or watch objects of kind Role",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleList is a collection of Roles"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles",
      "method": "createRbacAuthorizationV1Beta1NamespacedRole",
      "httpMethod": "post",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "create a Role",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "rules",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        },
        {
          "statusCode": "201",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        },
        {
          "statusCode": "202",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}",
      "method": "deleteRbacAuthorizationV1Beta1NamespacedRole",
      "httpMethod": "delete",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "delete a Role",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}",
      "method": "readRbacAuthorizationV1Beta1NamespacedRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "read the specified Role",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}",
      "method": "patchRbacAuthorizationV1Beta1NamespacedRole",
      "httpMethod": "patch",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "partially update the specified Role",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}",
      "method": "replaceRbacAuthorizationV1Beta1NamespacedRole",
      "httpMethod": "put",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "replace the specified Role",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "rules",
          "schema": "array",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        },
        {
          "statusCode": "201",
          "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/rolebindings",
      "method": "listRbacAuthorizationV1Beta1RoleBindingForAllNamespaces",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "list or watch objects of kind RoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleBindingList is a collection of RoleBindings"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/roles",
      "method": "listRbacAuthorizationV1Beta1RoleForAllNamespaces",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "list or watch objects of kind Role",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "RoleList is a collection of Roles"
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/watch/clusterrolebindings",
      "method": "watchRbacAuthorizationV1Beta1ClusterRoleBindingList",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "watch individual changes to a list of ClusterRoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/watch/clusterrolebindings/{name}",
      "method": "watchRbacAuthorizationV1Beta1ClusterRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "watch changes to an object of kind ClusterRoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/watch/clusterroles",
      "method": "watchRbacAuthorizationV1Beta1ClusterRoleList",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "watch individual changes to a list of ClusterRole",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/watch/clusterroles/{name}",
      "method": "watchRbacAuthorizationV1Beta1ClusterRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "watch changes to an object of kind ClusterRole",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/watch/namespaces/{namespace}/rolebindings",
      "method": "watchRbacAuthorizationV1Beta1NamespacedRoleBindingList",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "watch individual changes to a list of RoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/watch/namespaces/{namespace}/rolebindings/{name}",
      "method": "watchRbacAuthorizationV1Beta1NamespacedRoleBinding",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "watch changes to an object of kind RoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/watch/namespaces/{namespace}/roles",
      "method": "watchRbacAuthorizationV1Beta1NamespacedRoleList",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "watch individual changes to a list of Role",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/watch/namespaces/{namespace}/roles/{name}",
      "method": "watchRbacAuthorizationV1Beta1NamespacedRole",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "watch changes to an object of kind Role",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/watch/rolebindings",
      "method": "watchRbacAuthorizationV1Beta1RoleBindingListForAllNamespaces",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "watch individual changes to a list of RoleBinding",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/rbac.authorization.k8s.io/v1beta1/watch/roles",
      "method": "watchRbacAuthorizationV1Beta1RoleListForAllNamespaces",
      "httpMethod": "get",
      "tag": "rbacAuthorization_v1beta1",
      "typeScriptTag": "rbacAuthorizationV1Beta1",
      "description": "watch individual changes to a list of Role",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/",
      "method": "getSchedulingApiGroup",
      "httpMethod": "get",
      "tag": "scheduling",
      "typeScriptTag": "scheduling",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/v1alpha1/",
      "method": "getSchedulingV1Alpha1ApiResources",
      "httpMethod": "get",
      "tag": "scheduling_v1alpha1",
      "typeScriptTag": "schedulingV1Alpha1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/v1alpha1/priorityclasses",
      "method": "deleteSchedulingV1Alpha1CollectionPriorityClass",
      "httpMethod": "delete",
      "tag": "scheduling_v1alpha1",
      "typeScriptTag": "schedulingV1Alpha1",
      "description": "delete collection of PriorityClass",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/v1alpha1/priorityclasses",
      "method": "listSchedulingV1Alpha1PriorityClass",
      "httpMethod": "get",
      "tag": "scheduling_v1alpha1",
      "typeScriptTag": "schedulingV1Alpha1",
      "description": "list or watch objects of kind PriorityClass",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityClassList is a collection of priority classes."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/v1alpha1/priorityclasses",
      "method": "createSchedulingV1Alpha1PriorityClass",
      "httpMethod": "post",
      "tag": "scheduling_v1alpha1",
      "typeScriptTag": "schedulingV1Alpha1",
      "description": "create a PriorityClass",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "description",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "globalDefault",
          "schema": "boolean",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "value",
          "schema": "integer",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer."
        },
        {
          "statusCode": "201",
          "description": "PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer."
        },
        {
          "statusCode": "202",
          "description": "PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/v1alpha1/priorityclasses/{name}",
      "method": "deleteSchedulingV1Alpha1PriorityClass",
      "httpMethod": "delete",
      "tag": "scheduling_v1alpha1",
      "typeScriptTag": "schedulingV1Alpha1",
      "description": "delete a PriorityClass",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/v1alpha1/priorityclasses/{name}",
      "method": "readSchedulingV1Alpha1PriorityClass",
      "httpMethod": "get",
      "tag": "scheduling_v1alpha1",
      "typeScriptTag": "schedulingV1Alpha1",
      "description": "read the specified PriorityClass",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/v1alpha1/priorityclasses/{name}",
      "method": "patchSchedulingV1Alpha1PriorityClass",
      "httpMethod": "patch",
      "tag": "scheduling_v1alpha1",
      "typeScriptTag": "schedulingV1Alpha1",
      "description": "partially update the specified PriorityClass",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/v1alpha1/priorityclasses/{name}",
      "method": "replaceSchedulingV1Alpha1PriorityClass",
      "httpMethod": "put",
      "tag": "scheduling_v1alpha1",
      "typeScriptTag": "schedulingV1Alpha1",
      "description": "replace the specified PriorityClass",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "description",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "globalDefault",
          "schema": "boolean",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "value",
          "schema": "integer",
          "required": true,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer."
        },
        {
          "statusCode": "201",
          "description": "PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/v1alpha1/watch/priorityclasses",
      "method": "watchSchedulingV1Alpha1PriorityClassList",
      "httpMethod": "get",
      "tag": "scheduling_v1alpha1",
      "typeScriptTag": "schedulingV1Alpha1",
      "description": "watch individual changes to a list of PriorityClass",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/scheduling.k8s.io/v1alpha1/watch/priorityclasses/{name}",
      "method": "watchSchedulingV1Alpha1PriorityClass",
      "httpMethod": "get",
      "tag": "scheduling_v1alpha1",
      "typeScriptTag": "schedulingV1Alpha1",
      "description": "watch changes to an object of kind PriorityClass",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/settings.k8s.io/",
      "method": "getSettingsApiGroup",
      "httpMethod": "get",
      "tag": "settings",
      "typeScriptTag": "settings",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/settings.k8s.io/v1alpha1/",
      "method": "getSettingsV1Alpha1ApiResources",
      "httpMethod": "get",
      "tag": "settings_v1alpha1",
      "typeScriptTag": "settingsV1Alpha1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets",
      "method": "deleteSettingsV1Alpha1CollectionNamespacedPodPreset",
      "httpMethod": "delete",
      "tag": "settings_v1alpha1",
      "typeScriptTag": "settingsV1Alpha1",
      "description": "delete collection of PodPreset",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets",
      "method": "listSettingsV1Alpha1NamespacedPodPreset",
      "httpMethod": "get",
      "tag": "settings_v1alpha1",
      "typeScriptTag": "settingsV1Alpha1",
      "description": "list or watch objects of kind PodPreset",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodPresetList is a list of PodPreset objects."
        }
      ]
    },
    {
      "url": "/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets",
      "method": "createSettingsV1Alpha1NamespacedPodPreset",
      "httpMethod": "post",
      "tag": "settings_v1alpha1",
      "typeScriptTag": "settingsV1Alpha1",
      "description": "create a PodPreset",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodPreset is a policy resource that defines additional runtime requirements for a Pod."
        },
        {
          "statusCode": "201",
          "description": "PodPreset is a policy resource that defines additional runtime requirements for a Pod."
        },
        {
          "statusCode": "202",
          "description": "PodPreset is a policy resource that defines additional runtime requirements for a Pod."
        }
      ]
    },
    {
      "url": "/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}",
      "method": "deleteSettingsV1Alpha1NamespacedPodPreset",
      "httpMethod": "delete",
      "tag": "settings_v1alpha1",
      "typeScriptTag": "settingsV1Alpha1",
      "description": "delete a PodPreset",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}",
      "method": "readSettingsV1Alpha1NamespacedPodPreset",
      "httpMethod": "get",
      "tag": "settings_v1alpha1",
      "typeScriptTag": "settingsV1Alpha1",
      "description": "read the specified PodPreset",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodPreset is a policy resource that defines additional runtime requirements for a Pod."
        }
      ]
    },
    {
      "url": "/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}",
      "method": "patchSettingsV1Alpha1NamespacedPodPreset",
      "httpMethod": "patch",
      "tag": "settings_v1alpha1",
      "typeScriptTag": "settingsV1Alpha1",
      "description": "partially update the specified PodPreset",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodPreset is a policy resource that defines additional runtime requirements for a Pod."
        }
      ]
    },
    {
      "url": "/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}",
      "method": "replaceSettingsV1Alpha1NamespacedPodPreset",
      "httpMethod": "put",
      "tag": "settings_v1alpha1",
      "typeScriptTag": "settingsV1Alpha1",
      "description": "replace the specified PodPreset",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodPreset is a policy resource that defines additional runtime requirements for a Pod."
        },
        {
          "statusCode": "201",
          "description": "PodPreset is a policy resource that defines additional runtime requirements for a Pod."
        }
      ]
    },
    {
      "url": "/apis/settings.k8s.io/v1alpha1/podpresets",
      "method": "listSettingsV1Alpha1PodPresetForAllNamespaces",
      "httpMethod": "get",
      "tag": "settings_v1alpha1",
      "typeScriptTag": "settingsV1Alpha1",
      "description": "list or watch objects of kind PodPreset",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "PodPresetList is a list of PodPreset objects."
        }
      ]
    },
    {
      "url": "/apis/settings.k8s.io/v1alpha1/watch/namespaces/{namespace}/podpresets",
      "method": "watchSettingsV1Alpha1NamespacedPodPresetList",
      "httpMethod": "get",
      "tag": "settings_v1alpha1",
      "typeScriptTag": "settingsV1Alpha1",
      "description": "watch individual changes to a list of PodPreset",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/settings.k8s.io/v1alpha1/watch/namespaces/{namespace}/podpresets/{name}",
      "method": "watchSettingsV1Alpha1NamespacedPodPreset",
      "httpMethod": "get",
      "tag": "settings_v1alpha1",
      "typeScriptTag": "settingsV1Alpha1",
      "description": "watch changes to an object of kind PodPreset",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/settings.k8s.io/v1alpha1/watch/podpresets",
      "method": "watchSettingsV1Alpha1PodPresetListForAllNamespaces",
      "httpMethod": "get",
      "tag": "settings_v1alpha1",
      "typeScriptTag": "settingsV1Alpha1",
      "description": "watch individual changes to a list of PodPreset",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/",
      "method": "getStorageApiGroup",
      "httpMethod": "get",
      "tag": "storage",
      "typeScriptTag": "storage",
      "description": "get information of a group",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIGroup contains the name, the supported versions, and the preferred version of a group."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/",
      "method": "getStorageV1ApiResources",
      "httpMethod": "get",
      "tag": "storage_v1",
      "typeScriptTag": "storageV1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/storageclasses",
      "method": "deleteStorageV1CollectionStorageClass",
      "httpMethod": "delete",
      "tag": "storage_v1",
      "typeScriptTag": "storageV1",
      "description": "delete collection of StorageClass",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/storageclasses",
      "method": "listStorageV1StorageClass",
      "httpMethod": "get",
      "tag": "storage_v1",
      "typeScriptTag": "storageV1",
      "description": "list or watch objects of kind StorageClass",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StorageClassList is a collection of storage classes."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/storageclasses",
      "method": "createStorageV1StorageClass",
      "httpMethod": "post",
      "tag": "storage_v1",
      "typeScriptTag": "storageV1",
      "description": "create a StorageClass",
      "parameters": [
        {
          "name": "allowVolumeExpansion",
          "schema": "boolean",
          "required": false,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "mountOptions",
          "schema": "array",
          "required": false,
          "description": ""
        },
        {
          "name": "parameters",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "provisioner",
          "schema": "string",
          "required": true,
          "description": ""
        },
        {
          "name": "reclaimPolicy",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "volumeBindingMode",
          "schema": "string",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        },
        {
          "statusCode": "201",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        },
        {
          "statusCode": "202",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/storageclasses/{name}",
      "method": "deleteStorageV1StorageClass",
      "httpMethod": "delete",
      "tag": "storage_v1",
      "typeScriptTag": "storageV1",
      "description": "delete a StorageClass",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/storageclasses/{name}",
      "method": "readStorageV1StorageClass",
      "httpMethod": "get",
      "tag": "storage_v1",
      "typeScriptTag": "storageV1",
      "description": "read the specified StorageClass",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/storageclasses/{name}",
      "method": "patchStorageV1StorageClass",
      "httpMethod": "patch",
      "tag": "storage_v1",
      "typeScriptTag": "storageV1",
      "description": "partially update the specified StorageClass",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/storageclasses/{name}",
      "method": "replaceStorageV1StorageClass",
      "httpMethod": "put",
      "tag": "storage_v1",
      "typeScriptTag": "storageV1",
      "description": "replace the specified StorageClass",
      "parameters": [
        {
          "name": "allowVolumeExpansion",
          "schema": "boolean",
          "required": false,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "mountOptions",
          "schema": "array",
          "required": false,
          "description": ""
        },
        {
          "name": "parameters",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "provisioner",
          "schema": "string",
          "required": true,
          "description": ""
        },
        {
          "name": "reclaimPolicy",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "volumeBindingMode",
          "schema": "string",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        },
        {
          "statusCode": "201",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/watch/storageclasses",
      "method": "watchStorageV1StorageClassList",
      "httpMethod": "get",
      "tag": "storage_v1",
      "typeScriptTag": "storageV1",
      "description": "watch individual changes to a list of StorageClass",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1/watch/storageclasses/{name}",
      "method": "watchStorageV1StorageClass",
      "httpMethod": "get",
      "tag": "storage_v1",
      "typeScriptTag": "storageV1",
      "description": "watch changes to an object of kind StorageClass",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1alpha1/",
      "method": "getStorageV1Alpha1ApiResources",
      "httpMethod": "get",
      "tag": "storage_v1alpha1",
      "typeScriptTag": "storageV1Alpha1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1alpha1/volumeattachments",
      "method": "deleteStorageV1Alpha1CollectionVolumeAttachment",
      "httpMethod": "delete",
      "tag": "storage_v1alpha1",
      "typeScriptTag": "storageV1Alpha1",
      "description": "delete collection of VolumeAttachment",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1alpha1/volumeattachments",
      "method": "listStorageV1Alpha1VolumeAttachment",
      "httpMethod": "get",
      "tag": "storage_v1alpha1",
      "typeScriptTag": "storageV1Alpha1",
      "description": "list or watch objects of kind VolumeAttachment",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "VolumeAttachmentList is a collection of VolumeAttachment objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1alpha1/volumeattachments",
      "method": "createStorageV1Alpha1VolumeAttachment",
      "httpMethod": "post",
      "tag": "storage_v1alpha1",
      "typeScriptTag": "storageV1Alpha1",
      "description": "create a VolumeAttachment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        },
        {
          "statusCode": "201",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        },
        {
          "statusCode": "202",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1alpha1/volumeattachments/{name}",
      "method": "deleteStorageV1Alpha1VolumeAttachment",
      "httpMethod": "delete",
      "tag": "storage_v1alpha1",
      "typeScriptTag": "storageV1Alpha1",
      "description": "delete a VolumeAttachment",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1alpha1/volumeattachments/{name}",
      "method": "readStorageV1Alpha1VolumeAttachment",
      "httpMethod": "get",
      "tag": "storage_v1alpha1",
      "typeScriptTag": "storageV1Alpha1",
      "description": "read the specified VolumeAttachment",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1alpha1/volumeattachments/{name}",
      "method": "patchStorageV1Alpha1VolumeAttachment",
      "httpMethod": "patch",
      "tag": "storage_v1alpha1",
      "typeScriptTag": "storageV1Alpha1",
      "description": "partially update the specified VolumeAttachment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1alpha1/volumeattachments/{name}",
      "method": "replaceStorageV1Alpha1VolumeAttachment",
      "httpMethod": "put",
      "tag": "storage_v1alpha1",
      "typeScriptTag": "storageV1Alpha1",
      "description": "replace the specified VolumeAttachment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        },
        {
          "statusCode": "201",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1alpha1/watch/volumeattachments",
      "method": "watchStorageV1Alpha1VolumeAttachmentList",
      "httpMethod": "get",
      "tag": "storage_v1alpha1",
      "typeScriptTag": "storageV1Alpha1",
      "description": "watch individual changes to a list of VolumeAttachment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1alpha1/watch/volumeattachments/{name}",
      "method": "watchStorageV1Alpha1VolumeAttachment",
      "httpMethod": "get",
      "tag": "storage_v1alpha1",
      "typeScriptTag": "storageV1Alpha1",
      "description": "watch changes to an object of kind VolumeAttachment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1beta1/",
      "method": "getStorageV1Beta1ApiResources",
      "httpMethod": "get",
      "tag": "storage_v1beta1",
      "typeScriptTag": "storageV1Beta1",
      "description": "get available resources",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1beta1/storageclasses",
      "method": "deleteStorageV1Beta1CollectionStorageClass",
      "httpMethod": "delete",
      "tag": "storage_v1beta1",
      "typeScriptTag": "storageV1Beta1",
      "description": "delete collection of StorageClass",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1beta1/storageclasses",
      "method": "listStorageV1Beta1StorageClass",
      "httpMethod": "get",
      "tag": "storage_v1beta1",
      "typeScriptTag": "storageV1Beta1",
      "description": "list or watch objects of kind StorageClass",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StorageClassList is a collection of storage classes."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1beta1/storageclasses",
      "method": "createStorageV1Beta1StorageClass",
      "httpMethod": "post",
      "tag": "storage_v1beta1",
      "typeScriptTag": "storageV1Beta1",
      "description": "create a StorageClass",
      "parameters": [
        {
          "name": "allowVolumeExpansion",
          "schema": "boolean",
          "required": false,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "mountOptions",
          "schema": "array",
          "required": false,
          "description": ""
        },
        {
          "name": "parameters",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "provisioner",
          "schema": "string",
          "required": true,
          "description": ""
        },
        {
          "name": "reclaimPolicy",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "volumeBindingMode",
          "schema": "string",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        },
        {
          "statusCode": "201",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        },
        {
          "statusCode": "202",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1beta1/storageclasses/{name}",
      "method": "deleteStorageV1Beta1StorageClass",
      "httpMethod": "delete",
      "tag": "storage_v1beta1",
      "typeScriptTag": "storageV1Beta1",
      "description": "delete a StorageClass",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1beta1/storageclasses/{name}",
      "method": "readStorageV1Beta1StorageClass",
      "httpMethod": "get",
      "tag": "storage_v1beta1",
      "typeScriptTag": "storageV1Beta1",
      "description": "read the specified StorageClass",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1beta1/storageclasses/{name}",
      "method": "patchStorageV1Beta1StorageClass",
      "httpMethod": "patch",
      "tag": "storage_v1beta1",
      "typeScriptTag": "storageV1Beta1",
      "description": "partially update the specified StorageClass",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1beta1/storageclasses/{name}",
      "method": "replaceStorageV1Beta1StorageClass",
      "httpMethod": "put",
      "tag": "storage_v1beta1",
      "typeScriptTag": "storageV1Beta1",
      "description": "replace the specified StorageClass",
      "parameters": [
        {
          "name": "allowVolumeExpansion",
          "schema": "boolean",
          "required": false,
          "description": ""
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "mountOptions",
          "schema": "array",
          "required": false,
          "description": ""
        },
        {
          "name": "parameters",
          "schema": "object",
          "required": false,
          "description": ""
        },
        {
          "name": "provisioner",
          "schema": "string",
          "required": true,
          "description": ""
        },
        {
          "name": "reclaimPolicy",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "volumeBindingMode",
          "schema": "string",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        },
        {
          "statusCode": "201",
          "description": "StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1beta1/volumeattachments",
      "method": "deleteStorageV1Beta1CollectionVolumeAttachment",
      "httpMethod": "delete",
      "tag": "storage_v1beta1",
      "typeScriptTag": "storageV1Beta1",
      "description": "delete collection of VolumeAttachment",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1beta1/volumeattachments",
      "method": "listStorageV1Beta1VolumeAttachment",
      "httpMethod": "get",
      "tag": "storage_v1beta1",
      "typeScriptTag": "storageV1Beta1",
      "description": "list or watch objects of kind VolumeAttachment",
      "parameters": [
        {
          "name": "continue",
          "schema": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
        },
        {
          "name": "fieldSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything."
        },
        {
          "name": "includeUninitialized",
          "schema": "boolean",
          "description": "If true, partially initialized resources are included in the response."
        },
        {
          "name": "labelSelector",
          "schema": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything."
        },
        {
          "name": "limit",
          "schema": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned."
        },
        {
          "name": "resourceVersion",
          "schema": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv."
        },
        {
          "name": "timeoutSeconds",
          "schema": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity."
        },
        {
          "name": "watch",
          "schema": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "VolumeAttachmentList is a collection of VolumeAttachment objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1beta1/volumeattachments",
      "method": "createStorageV1Beta1VolumeAttachment",
      "httpMethod": "post",
      "tag": "storage_v1beta1",
      "typeScriptTag": "storageV1Beta1",
      "description": "create a VolumeAttachment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        },
        {
          "statusCode": "201",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        },
        {
          "statusCode": "202",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1beta1/volumeattachments/{name}",
      "method": "deleteStorageV1Beta1VolumeAttachment",
      "httpMethod": "delete",
      "tag": "storage_v1beta1",
      "typeScriptTag": "storageV1Beta1",
      "description": "delete a VolumeAttachment",
      "parameters": [
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately."
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
        },
        {
          "name": "apiVersion",
          "schema": "string",
          "description": ""
        },
        {
          "name": "gracePeriodSeconds",
          "schema": "integer",
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "description": ""
        },
        {
          "name": "orphanDependents",
          "schema": "boolean",
          "description": ""
        },
        {
          "name": "preconditions",
          "schema": "undefined",
          "description": ""
        },
        {
          "name": "propagationPolicy",
          "schema": "string",
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "Status is a return value for calls that don't return other objects."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1beta1/volumeattachments/{name}",
      "method": "readStorageV1Beta1VolumeAttachment",
      "httpMethod": "get",
      "tag": "storage_v1beta1",
      "typeScriptTag": "storageV1Beta1",
      "description": "read the specified VolumeAttachment",
      "parameters": [
        {
          "name": "exact",
          "schema": "boolean",
          "description": "Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'."
        },
        {
          "name": "export",
          "schema": "boolean",
          "description": "Should this value be exported.  Export strips fields that a user can not specify."
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1beta1/volumeattachments/{name}",
      "method": "patchStorageV1Beta1VolumeAttachment",
      "httpMethod": "patch",
      "tag": "storage_v1beta1",
      "typeScriptTag": "storageV1Beta1",
      "description": "partially update the specified VolumeAttachment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1beta1/volumeattachments/{name}",
      "method": "replaceStorageV1Beta1VolumeAttachment",
      "httpMethod": "put",
      "tag": "storage_v1beta1",
      "typeScriptTag": "storageV1Beta1",
      "description": "replace the specified VolumeAttachment",
      "parameters": [
        {
          "name": "apiVersion",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "kind",
          "schema": "string",
          "required": false,
          "description": ""
        },
        {
          "name": "metadata",
          "schema": "undefined",
          "required": false,
          "description": ""
        },
        {
          "name": "spec",
          "schema": "undefined",
          "required": true,
          "description": ""
        },
        {
          "name": "status",
          "schema": "undefined",
          "required": false,
          "description": ""
        }
      ],
      "responses": [
        {
          "statusCode": "200",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        },
        {
          "statusCode": "201",
          "description": "VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.\n\nVolumeAttachment objects are non-namespaced."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1beta1/watch/storageclasses",
      "method": "watchStorageV1Beta1StorageClassList",
      "httpMethod": "get",
      "tag": "storage_v1beta1",
      "typeScriptTag": "storageV1Beta1",
      "description": "watch individual changes to a list of StorageClass",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1beta1/watch/storageclasses/{name}",
      "method": "watchStorageV1Beta1StorageClass",
      "httpMethod": "get",
      "tag": "storage_v1beta1",
      "typeScriptTag": "storageV1Beta1",
      "description": "watch changes to an object of kind StorageClass",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1beta1/watch/volumeattachments",
      "method": "watchStorageV1Beta1VolumeAttachmentList",
      "httpMethod": "get",
      "tag": "storage_v1beta1",
      "typeScriptTag": "storageV1Beta1",
      "description": "watch individual changes to a list of VolumeAttachment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/apis/storage.k8s.io/v1beta1/watch/volumeattachments/{name}",
      "method": "watchStorageV1Beta1VolumeAttachment",
      "httpMethod": "get",
      "tag": "storage_v1beta1",
      "typeScriptTag": "storageV1Beta1",
      "description": "watch changes to an object of kind VolumeAttachment",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Event represents a single event to a watched resource."
        }
      ]
    },
    {
      "url": "/logs/",
      "method": "logFileListHandler",
      "httpMethod": "get",
      "tag": "logs",
      "typeScriptTag": "logs",
      "description": "",
      "parameters": [],
      "responses": []
    },
    {
      "url": "/logs/{logpath}",
      "method": "logFileHandler",
      "httpMethod": "get",
      "tag": "logs",
      "typeScriptTag": "logs",
      "description": "",
      "parameters": [],
      "responses": []
    },
    {
      "url": "/version/",
      "method": "getCodeVersion",
      "httpMethod": "get",
      "tag": "version",
      "typeScriptTag": "version",
      "description": "get the code version",
      "parameters": [],
      "responses": [
        {
          "statusCode": "200",
          "description": "Info contains versioning information. how we'll want to distribute that information."
        }
      ]
    }
  ],
  "apiBaseUrl": "kubernetes.local",
  "apiTitle": "Kubernetes",
  "endpoints": 488,
  "sdkMethods": 1381,
  "schemas": 834,
  "parameters": 2820,
  "difficultyScore": 2503,
  "difficulty": "Very Hard"
}