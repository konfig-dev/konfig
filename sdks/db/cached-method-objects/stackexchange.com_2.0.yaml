hash: 4b39e6bda7036f5492c032217f9f1feced983bbf124dba295099507a5a03599b
methodObjects:
  - url: /access-tokens/{accessTokens}
    method: listPropertiesForMultipleTokens
    httpMethod: get
    tag: AccessToken
    typeScriptTag: accessToken
    description: >
      Reads the properties for a set of access tokens.
       
      {accessTokens} can contain up to 20 access tokens. These are obtained by
      authenticating a user using OAuth 2.0.
       
      This method returns a list of access_tokens.
    parameters:
      - name: accessTokens
        schema: string
        required: true
        description: String list (semicolon delimited).
        example: ACCESSTOKENS
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /access-tokens/{accessTokens}/invalidate
    method: invalidateList
    httpMethod: get
    tag: AccessToken
    typeScriptTag: accessToken
    description: >
      Immediately expires the access tokens passed. This method is meant to
      allow an application to discard any active access tokens it no longer
      needs.
       
      {accessTokens} can contain up to 20 access tokens. These are obtained by
      authenticating a user using OAuth 2.0.
       
      This method returns a list of access_tokens.
    parameters:
      - name: accessTokens
        schema: string
        required: true
        description: String list (semicolon delimited).
        example: ACCESSTOKENS
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /answers
    method: getList
    httpMethod: get
    tag: Answer
    typeScriptTag: answer
    description: >
      Returns all the undeleted answers in the system.
       
      The sorts accepted by this method operate on the follow fields of the
      answer object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of answers.
    parameters:
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /answers/{ids}
    method: getListByIds
    httpMethod: get
    tag: Answer
    typeScriptTag: answer
    description: >
      Gets the set of answers identified by ids.
       
      This is meant for batch fetcing of questions. A useful trick to poll for
      updates is to sort by activity, with a minimum date of the last time you
      polled.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for answer_id on answer objects.
       
      The sorts accepted by this method operate on the follow fields of the
      answer object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of answers.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /answers/{ids}/comments
    method: getCommentsByIds
    httpMethod: get
    tag: Answer
    typeScriptTag: answer
    description: >
      Gets the comments on a set of answers.
       
      If you know that you have an answer id and need the comments, use this
      method. If you know you have a question id, use /questions/{id}/comments.
      If you are unsure, use /posts/{id}/comments.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for answer_id on answer objects.
       
      The sorts accepted by this method operate on the follow fields of the
      comment object:
       - creation - creation_date
       - votes - score
        creation is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of comments.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /apps/{accessTokens}/de-authenticate
    method: deauthenticateList
    httpMethod: get
    tag: AccessToken
    typeScriptTag: accessToken
    description: >
      Passing valid access_tokens to this method causes the application that
      created them to be de-authorized by the user associated with each
      access_token. This will remove the application from their apps tab, and
      cause all other existing access_tokens to be destroyed.
       
      This method is meant for uninstalling applications, recovering from
      access_token leaks, or simply as a stronger form of
      /access-tokens/{accessTokens}/invalidate.
       
      Nothing prevents a user from re-authenticate to an application that has
      de-authenticated itself, the user will be prompted to approve the
      application again however.
       
      {accessTokens} can contain up to 20 access tokens. These are obtained by
      authenticating a user using OAuth 2.0.
       
      This method returns a list of access_tokens.
    parameters:
      - name: accessTokens
        schema: string
        required: true
        description: String list (semicolon delimited).
        example: ACCESSTOKENS
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /badges
    method: listBadges
    httpMethod: get
    tag: Badge
    typeScriptTag: badge
    description: >
      Returns all the badges in the system.
       
      Badge sorts are a tad complicated. For the purposes of sorting (and
      min/max) tag_based is considered to be greater than named.
       
      This means that you can get a list of all tag based badges by passing
      min=tag_based, and conversely all the named badges by passing max=named,
      with sort=type.
       
      For ranks, bronze is greater than silver which is greater than gold. Along
      with sort=rank, set max=gold for just gold badges, max=silver&min=silver
      for just silver, and min=bronze for just bronze.
       
      rank is the default sort.
       
      This method returns a list of badges.
    parameters:
      - name: inname
        schema: string
        description: ''
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = rank => string
          sort = name => string
          sort = type => string
      - name: min
        schema: string
        description: |
          sort = rank => string
          sort = name => string
          sort = type => string
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /badges/name
    method: getAllNamedBadges
    httpMethod: get
    tag: Badge
    typeScriptTag: badge
    description: >
      Gets all explicitly named badges in the system.
       
      A named badged stands in opposition to a tag-based badge. These are
      referred to as general badges on the sites themselves.
       
      For the rank sort, bronze is greater than silver which is greater than
      gold. Along with sort=rank, set max=gold for just gold badges,
      max=silver&min=silver for just silver, and min=bronze for just bronze.
       
      rank is the default sort.
       
      This method returns a list of badges.
    parameters:
      - name: inname
        schema: string
        description: ''
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = rank => string
          sort = name => string
      - name: min
        schema: string
        description: |
          sort = rank => string
          sort = name => string
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /badges/recipients
    method: getRecentAwardedBadges
    httpMethod: get
    tag: Badge
    typeScriptTag: badge
    description: >
      Returns recently awarded badges in the system.
       
      As these badges have been awarded, they will have the badge.user property
      set.
       
      This method returns a list of badges.
    parameters:
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /badges/tags
    method: listTagsBadges
    httpMethod: get
    tag: Badge
    typeScriptTag: badge
    description: >
      Returns the badges that are awarded for participation in specific tags.
       
      For the rank sort, bronze is greater than silver which is greater than
      gold. Along with sort=rank, set max=gold for just gold badges,
      max=silver&min=silver for just silver, and min=bronze for just bronze.
       
      rank is the default sort.
       
      This method returns a list of badges.
    parameters:
      - name: inname
        schema: string
        description: ''
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = rank => string
          sort = name => string
      - name: min
        schema: string
        description: |
          sort = rank => string
          sort = name => string
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /badges/{ids}
    method: getBadgesByIds
    httpMethod: get
    tag: Badge
    typeScriptTag: badge
    description: >
      Gets the badges identified in id.
       
      Note that badge ids are not constant across sites, and thus should be
      looked up via the /badges method. A badge id on a single site is, however,
      guaranteed to be stable.
       
      Badge sorts are a tad complicated. For the purposes of sorting (and
      min/max) tag_based is considered to be greater than named.
       
      This means that you can get a list of all tag based badges by passing
      min=tag_based, and conversely all the named badges by passing max=named,
      with sort=type.
       
      For ranks, bronze is greater than silver which is greater than gold. Along
      with sort=rank, set max=gold for just gold badges, max=silver&min=silver
      for just silver, and min=bronze for just bronze.
       
      rank is the default sort.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for badge_id on badge objects.
       
      This method returns a list of badges.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = rank => string
          sort = name => string
          sort = type => string
      - name: min
        schema: string
        description: |
          sort = rank => string
          sort = name => string
          sort = type => string
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /badges/{ids}/recipients
    method: getRecentAwardedRecipients
    httpMethod: get
    tag: Badge
    typeScriptTag: badge
    description: >
      Returns recently awarded badges in the system, constrained to a certain
      set of badges.
       
      As these badges have been awarded, they will have the badge.user property
      set.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for badge_id on badge objects.
       
      This method returns a list of badges.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /comments
    method: listComments
    httpMethod: get
    tag: Comment
    typeScriptTag: comment
    description: >
      Gets all the comments on the site.
       
      If you're filtering for interesting comments (by score, creation date,
      etc.) make use of the sort paramter with appropriate min and max values.
       
      If you're looking to query conversations between users, instead use the
      /users/{ids}/mentioned and /users/{ids}/comments/{toid} methods.
       
      The sorts accepted by this method operate on the follow fields of the
      comment object:
       - creation - creation_date
       - votes - score
        creation is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of comments.
    parameters:
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /comments/{ids}
    method: getCommentsByIds
    httpMethod: get
    tag: Comment
    typeScriptTag: comment
    description: >
      Gets the comments identified in id.
       
      This method is most useful if you have a cache of comment ids obtained
      through other means (such as /questions/{id}/comments) but suspect the
      data may be stale.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for comment_id on comment objects.
       
      The sorts accepted by this method operate on the follow fields of the
      comment object:
       - creation - creation_date
       - votes - score
        creation is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of comments.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /comments/{id}/delete
    method: deleteAction
    httpMethod: post
    tag: Comment
    typeScriptTag: comment
    description: |
      Deletes a comment.
       
      Use an access_token with write_access to delete a comment.
       
      In practice, this method will never return an object.
    parameters:
      - name: id
        schema: integer
        required: true
        description: ''
        example: 0
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
      - name: preview
        schema: boolean
        description: ''
    responses:
      - statusCode: '200'
        description: OK
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /comments/{id}/edit
    method: editExisting
    httpMethod: post
    tag: Comment
    typeScriptTag: comment
    description: |
      Edit an existing comment.
       
      Use an access_token with write_access to edit an existing comment.
       
      This method return the created comment.
    parameters:
      - name: id
        schema: integer
        required: true
        description: ''
        example: 0
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
      - name: body
        schema: string
        description: ''
      - name: preview
        schema: boolean
        description: ''
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /errors
    method: listErrors
    httpMethod: get
    tag: Error
    typeScriptTag: error
    description: >
      Returns the various error codes that can be produced by the API.
       
      This method is provided for discovery, documentation, and testing
      purposes, it is not expected many applications will consume it during
      normal operation.
       
      For testing purposes, look into the /errors/{id} method which simulates
      errors given a code.
       
      This method returns a list of errors.
    parameters:
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /errors/{id}
    method: generateError
    httpMethod: get
    tag: Error
    typeScriptTag: error
    description: >
      This method allows you to generate an error.
       
      This method is only intended for use when testing an application or
      library. Unlike other methods in the API, its contract is not frozen, and
      new error codes may be added at any time.
       
      This method results in an error, which will be expressed with a 400 HTTP
      status code and setting the error* properties on the wrapper object.
    parameters:
      - name: id
        schema: integer
        required: true
        description: ''
        example: 0
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /events
    method: listEvents
    httpMethod: get
    tag: Event
    typeScriptTag: event
    description: >
      Returns a stream of events that have occurred on the site.
       
      The API considers the following "events":
       - posting a question
       - posting an answer
       - posting a comment
       - editing a post
       - creating a user

        

       
      Events are only accessible for 15 minutes after they occurred, and by
      default only events in the last 5 minutes are returned. You can specify
      the age of the oldest event returned by setting the since parameter.
       
      It is advised that developers batch events by ids and make as few
      subsequent requests to other methods as possible.
       
      This method returns a list of events.
    parameters:
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
      - name: since
        schema: integer
        description: Unix date.
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /filters/create
    method: createFilter
    httpMethod: get
    tag: Filter
    typeScriptTag: filter
    description: >
      Creates a new filter given a list of includes, excludes, a base filter,
      and whether or not this filter should be "unsafe".
       
      Filter "safety" is defined as follows. Any string returned as a result of
      an API call with a safe filter will be inline-able into HTML without
      script-injection concerns. That is to say, no additional sanitizing
      (encoding, HTML tag stripping, etc.) will be necessary on returned
      strings. Applications that wish to handle sanitizing themselves should
      create an unsafe filter. All filters are safe by default, under the
      assumption that double-encoding bugs are more desirable than script
      injections.
       
      If no base filter is specified, the default filter is assumed. When
      building a filter from scratch, the none built-in filter is useful.
       
      When the size of the parameters being sent to this method grows to large,
      problems can occur. This method will accept POST requests to mitigate
      this.
       
      It is not expected that many applications will call this method at
      runtime, filters should be pre-calculated and "baked in" in the common
      cases. Furthermore, there are a number of built-in filters which cover
      common use cases.
       
      This method returns a single filter.
    parameters:
      - name: base
        schema: string
        description: ''
      - name: exclude
        schema: string
        description: String list (semicolon delimited).
      - name: include
        schema: string
        description: String list (semicolon delimited).
      - name: unsafe
        schema: boolean
        description: ''
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /filters/{filters}
    method: getFilterDetailsByIds
    httpMethod: get
    tag: Filter
    typeScriptTag: filter
    description: >
      Returns the fields included by the given filters, and the "safeness" of
      those filters.
       
      It is not expected that this method will be consumed by many applications
      at runtime, it is provided to aid in debugging.
       
      {filters} can contain up to 20 semicolon delimited filters. Filters are
      obtained via calls to /filters/create, or by using a built-in filter.
       
      This method returns a list of filters.
    parameters:
      - name: filters
        schema: string
        required: true
        description: String list (semicolon delimited).
        example: FILTERS
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /inbox
    method: listInboxItems
    httpMethod: get
    tag: Message
    typeScriptTag: message
    description: >
      Returns a user's inbox.
       
      This method requires an access_token, with a scope containing
      "read_inbox".
       
      This method returns a list of inbox items.
    parameters:
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /inbox/unread
    method: getUnreadItems
    httpMethod: get
    tag: Message
    typeScriptTag: message
    description: >
      Returns the unread items in a user's inbox.
       
      This method requires an access_token, with a scope containing
      "read_inbox".
       
      This method returns a list of inbox items.
    parameters:
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: since
        schema: integer
        description: Unix date.
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /info
    method: getStatistics
    httpMethod: get
    tag: Information
    typeScriptTag: information
    description: >
      Returns a collection of statistics about the site.
       
      Data to facilitate per-site customization, discover related sites, and
      aggregate statistics is all returned by this method.
       
      This data is cached very aggressively, by design. Query sparingly, ideally
      no more than once an hour.
       
      This method returns an info object.
    parameters:
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me
    method: getUser
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: |
      Returns the user associated with the passed access_token.
       
      This method returns a user.
    parameters:
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = reputation => number
          sort = creation => date
          sort = name => string
          sort = modified => date
      - name: min
        schema: string
        description: |
          sort = reputation => number
          sort = creation => date
          sort = name => string
          sort = modified => date
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/answers
    method: getUserAnswersList
    httpMethod: get
    tag: Answer
    typeScriptTag: answer
    description: >
      Returns the answers owned by the user associated with the given
      access_token.
       
      This method returns a list of answers.
    parameters:
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/associated
    method: getUserAccounts
    httpMethod: get
    tag: Associated
    typeScriptTag: associated
    description: >
      Returns all of a user's associated accounts, given an access_token for
      them.
       
      This method returns a list of network users.
    parameters:
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/badges
    method: getUserBadges
    httpMethod: get
    tag: Badge
    typeScriptTag: badge
    description: >
      Returns the badges earned by the user associated with the given
      access_token.
       
      This method returns a list of badges.
    parameters:
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = rank => string
          sort = name => string
          sort = type => string
      - name: min
        schema: string
        description: |
          sort = rank => string
          sort = name => string
          sort = type => string
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/comments
    method: listOwnedComments
    httpMethod: get
    tag: Comment
    typeScriptTag: comment
    description: >
      Returns the comments owned by the user associated with the given
      access_token.
       
      This method returns a list of comments.
    parameters:
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/comments/{toId}
    method: getReplyList
    httpMethod: get
    tag: Comment
    typeScriptTag: comment
    description: >
      Returns the comments owned by the user associated with the given
      access_token that are in reply to the user identified by {toId}.
       
      This method returns a list of comments.
    parameters:
      - name: toId
        schema: integer
        required: true
        description: ''
        example: 0
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/favorites
    method: getUserFavorites
    httpMethod: get
    tag: Favorite
    typeScriptTag: favorite
    description: >
      Returns the questions favorites by the user associated with the given
      access_token.
       
      This method returns a list of questions.
    parameters:
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
          sort = added => date
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
          sort = added => date
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/inbox
    method: getInboxItems
    httpMethod: get
    tag: Message
    typeScriptTag: message
    description: >
      Returns the user identified by access_token's inbox.
       
      This method requires an access_token, with a scope containing
      "read_inbox".
       
      This method returns a list of inbox items.
    parameters:
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/inbox/unread
    method: getUnreadItemsInInbox
    httpMethod: get
    tag: Notification
    typeScriptTag: notification
    description: >
      Returns the unread items in the user identified by access_token's inbox.
       
      This method requires an access_token, with a scope containing
      "read_inbox".
       
      This method returns a list of inbox items.
    parameters:
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
      - name: since
        schema: integer
        description: Unix date.
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/mentioned
    method: userCommentsList
    httpMethod: get
    tag: Mention
    typeScriptTag: mention
    description: >
      Returns the comments mentioning the user associated with the given
      access_token.
       
      This method returns a list of comments.
    parameters:
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/merges
    method: getAccountMergeList
    httpMethod: get
    tag: Merge
    typeScriptTag: merge
    description: >
      Returns a record of merges that have occurred involving a user identified
      by an access_token.
       
      This method allows you to take now invalid account ids and find what
      account they've become, or take currently valid account ids and find which
      ids were equivalent in the past.
       
      This is most useful when confirming that an account_id is in fact "new" to
      an application.
       
      Account merges can happen for a wide range of reasons, applications should
      not make assumptions that merges have particular causes.
       
      Note that accounts are managed at a network level, users on a site may be
      merged due to an account level merge but there is no guarantee that a
      merge has an effect on any particular site.
       
      This method returns a list of account_merge.
    parameters:
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/notifications
    method: getUserNotificationsList
    httpMethod: get
    tag: Notification
    typeScriptTag: notification
    description: >
      Returns a user's notifications, given an access_token.
       
      This method requires an access_token, with a scope containing
      "read_inbox".
       
      This method returns a list of notifications.
    parameters:
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/notifications/unread
    method: getUnreadItemsInInbox
    httpMethod: get
    tag: Notification
    typeScriptTag: notification
    description: >
      Returns a user's unread notifications, given an access_token.
       
      This method requires an access_token, with a scope containing
      "read_inbox".
       
      This method returns a list of notifications.
    parameters:
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/privileges
    method: getUserPrivileges
    httpMethod: get
    tag: Privilege
    typeScriptTag: privilege
    description: |
      Returns the privileges the user identified by access_token has.
       
      This method returns a list of privileges.
    parameters:
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/questions
    method: getUserQuestionsList
    httpMethod: get
    tag: Question
    typeScriptTag: question
    description: >
      Returns the questions owned by the user associated with the given
      access_token.
       
      This method returns a list of questions.
    parameters:
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/questions/featured
    method: getUserFeatured
    httpMethod: get
    tag: Question
    typeScriptTag: question
    description: >
      Returns the questions that have active bounties offered by the user
      associated with the given access_token.
       
      This method returns a list of questions.
    parameters:
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/questions/no-answers
    method: listNoAnswerQuestions
    httpMethod: get
    tag: Answer
    typeScriptTag: answer
    description: >
      Returns the questions owned by the user associated with the given
      access_token that have no answers.
       
      This method returns a list of questions.
    parameters:
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/questions/unaccepted
    method: getUnacceptedList
    httpMethod: get
    tag: Question
    typeScriptTag: question
    description: >
      Returns the questions owned by the user associated with the given
      access_token that have no accepted answer.
       
      This method returns a list of questions.
    parameters:
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/questions/unanswered
    method: userUnansweredQuestionsGet
    httpMethod: get
    tag: Answer
    typeScriptTag: answer
    description: >
      Returns the questions owned by the user associated with the given
      access_token that are not considered answered.
       
      This method returns a list of questions.
    parameters:
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/reputation
    method: getUserReputationChanges
    httpMethod: get
    tag: Reputation
    typeScriptTag: reputation
    description: >
      Returns the reputation changed for the user associated with the given
      access_token.
       
      This method returns a list of reputation changes.
    parameters:
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/reputation-history
    method: getUserReputationHistory
    httpMethod: get
    tag: Reputation
    typeScriptTag: reputation
    description: |
      Returns user's public reputation history.
       
      This method returns a list of reputation_history.
    parameters:
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/reputation-history/full
    method: getFullHistory
    httpMethod: get
    tag: Reputation
    typeScriptTag: reputation
    description: |
      Returns user's full reputation history, including private events.
       
       This method requires an access_token, with a scope containing "private_info".

       
      This method returns a list of reputation_history.
    parameters:
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/suggested-edits
    method: getUserSuggestedEdits
    httpMethod: get
    tag: Edit
    typeScriptTag: edit
    description: >
      Returns the suggested edits the user identified by access_token has
      submitted.
       
      This method returns a list of suggested-edits.
    parameters:
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = creation => date
          sort = approval => date
          sort = rejection => date
      - name: min
        schema: string
        description: |
          sort = creation => date
          sort = approval => date
          sort = rejection => date
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/tags
    method: getUserTagsList
    httpMethod: get
    tag: Tag
    typeScriptTag: tag
    description: >
      Returns the tags the user identified by the access_token passed is active
      in.
       
      This method returns a list of tags.
    parameters:
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = popular => number
          sort = activity => date
          sort = name => string
      - name: min
        schema: string
        description: |
          sort = popular => number
          sort = activity => date
          sort = name => string
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/tags/{tags}/top-answers
    method: getUserTopAnswers
    httpMethod: get
    tag: Answer
    typeScriptTag: answer
    description: >
      Returns the top 30 answers the user associated with the given access_token
      has posted in response to questions with the given tags.
       
      This method returns a list of answers.
    parameters:
      - name: tags
        schema: string
        required: true
        description: String list (semicolon delimited).
        example: TAGS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/tags/{tags}/top-questions
    method: getUserTopQuestions
    httpMethod: get
    tag: Tag
    typeScriptTag: tag
    description: >
      Returns the top 30 questions the user associated with the given
      access_token has posted in response to questions with the given tags.
       
      This method returns a list of questions.
    parameters:
      - name: tags
        schema: string
        required: true
        description: String list (semicolon delimited).
        example: TAGS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
          sort = hot => none
          sort = week => none
          sort = month => none
          sort = relevance => none
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
          sort = hot => none
          sort = week => none
          sort = month => none
          sort = relevance => none
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/timeline
    method: getUserTimeline
    httpMethod: get
    tag: Timeline
    typeScriptTag: timeline
    description: >
      Returns a subset of the actions the user identified by the passed
      access_token has taken on the site.
       
      This method returns a list of user timeline objects.
    parameters:
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/top-answer-tags
    method: getUserTopTags
    httpMethod: get
    tag: Answer
    typeScriptTag: answer
    description: |
      Returns the user identified by access_token's top 30 tags by answer score.
       
      This method returns a list of top tag objects.
    parameters:
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/top-question-tags
    method: getUserTopTagsList
    httpMethod: get
    tag: Tag
    typeScriptTag: tag
    description: >
      Returns the user identified by access_token's top 30 tags by question
      score.
       
      This method returns a list of top tag objects.
    parameters:
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /me/write-permissions
    method: getUserWritePermissions
    httpMethod: get
    tag: Permission
    typeScriptTag: permission
    description: >
      Returns the write permissions a user has via the api, given an access
      token.
       
      The Stack Exchange API gives users the ability to create, edit, and delete
      certain types. This method returns whether the passed user is capable of
      performing those actions at all, as well as how many times a day they can.
       
      This method does not consider the user's current quota (ie. if they've
      already exhausted it for today) nor any additional restrictions on write
      access, such as editing deleted comments.
       
      This method returns a list of write_permissions.
    parameters:
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /notifications
    method: getUserNotifications
    httpMethod: get
    tag: Notification
    typeScriptTag: notification
    description: >
      Returns a user's notifications.
       
      This method requires an access_token, with a scope containing
      "read_inbox".
       
      This method returns a list of notifications.
    parameters:
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /notifications/unread
    method: getUserUnreadNotifications
    httpMethod: get
    tag: Notification
    typeScriptTag: notification
    description: >
      Returns a user's unread notifications.
       
      This method requires an access_token, with a scope containing
      "read_inbox".
       
      This method returns a list of notifications.
    parameters:
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /posts
    method: getAllPosts
    httpMethod: get
    tag: Post
    typeScriptTag: post
    description: >
      Fetches all posts (questions and answers) on the site.
       
      In many ways this method is the union of /questions and /answers,
      returning both sets of data albeit only the common fields.
       
      Most applications should use the question or answer specific methods, but
      /posts is available for those rare cases where any activity is of
      intereset. Examples of such queries would be: "all posts on Jan. 1st 2011"
      or "top 10 posts by score of all time".
       
      The sorts accepted by this method operate on the follow fields of the post
      object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of posts.
    parameters:
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /posts/{ids}
    method: getPostsByIds
    httpMethod: get
    tag: Post
    typeScriptTag: post
    description: >
      Fetches a set of posts by ids.
       
      This method is meant for grabbing an object when unsure whether an id
      identifies a question or an answer. This is most common with user entered
      data.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for post_id, answer_id, or question_id on post,
      answer, and question objects respectively.
       
      The sorts accepted by this method operate on the follow fields of the post
      object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of posts.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /posts/{ids}/comments
    method: commentsByIdsGet
    httpMethod: get
    tag: Post
    typeScriptTag: post
    description: >
      Gets the comments on the posts identified in ids, regardless of the type
      of the posts.
       
      This method is meant for cases when you are unsure of the type of the post
      id provided. Generally, this would be due to obtaining the post id
      directly from a user.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for post_id, answer_id, or question_id on post,
      answer, and question objects respectively.
       
      The sorts accepted by this method operate on the follow fields of the
      comment object:
       - creation - creation_date
       - votes - score
        creation is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of comments.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /posts/{ids}/revisions
    method: getPostRevisionsByIds
    httpMethod: get
    tag: Post
    typeScriptTag: post
    description: >
      Returns edit revisions for the posts identified in ids.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for post_id, answer_id, or question_id on post,
      answer, and question objects respectively.
       
      This method returns a list of revisions.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /posts/{ids}/suggested-edits
    method: listSuggestedEdits
    httpMethod: get
    tag: Post
    typeScriptTag: post
    description: |
      Returns suggsted edits on the posts identified in ids.
       
       - creation - creation_date
       - approval - approval_date
       - rejection - rejection_date
        creation is the default sort.
       
       {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for post_id, answer_id, or question_id on post, answer, and question objects respectively.

       
      This method returns a list of suggested-edits.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = creation => date
          sort = approval => date
          sort = rejection => date
      - name: min
        schema: string
        description: |
          sort = creation => date
          sort = approval => date
          sort = rejection => date
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /posts/{id}/comments/add
    method: addComment
    httpMethod: post
    tag: Post
    typeScriptTag: post
    description: |
      Create a new comment.
       
      Use an access_token with write_access to create a new comment on a post.
       
      This method returns the created comment.
    parameters:
      - name: id
        schema: integer
        required: true
        description: ''
        example: 0
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
      - name: body
        schema: string
        description: ''
      - name: preview
        schema: boolean
        description: ''
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /privileges
    method: getEarnableList
    httpMethod: get
    tag: Privilege
    typeScriptTag: privilege
    description: >
      Returns the earnable privileges on a site.
       
      Privileges define abilities a user can earn (via reputation) on any Stack
      Exchange site.
       
      While fairly stable, over time they do change. New ones are introduced
      with new features, and the reputation requirements change as a site
      matures.
       
      This method returns a list of privileges.
    parameters:
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /questions
    method: getAllQuestions
    httpMethod: get
    tag: Question
    typeScriptTag: question
    description: >
      Gets all the questions on the site.
       
      This method allows you make fairly flexible queries across the entire
      corpus of questions on a site. For example, getting all questions asked in
      the the week of Jan 1st 2011 with scores of 10 or more is a single query
      with parameters sort=votes&min=10&fromdate=1293840000&todate=1294444800.
       
      To constrain questions returned to those with a set of tags, use the
      tagged parameter with a semi-colon delimited list of tags. This is an and
      contraint, passing tagged=c;java will return only those questions with
      both tags. As such, passing more than 5 tags will always return zero
      results.
       
      The sorts accepted by this method operate on the follow fields of the
      question object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
       - hot - by the formula ordering the hot tab Does not accept min or max
       - week - by the formula ordering the week tab Does not accept min or max
       - month - by the formula ordering the month tab Does not accept min or max
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of questions.
    parameters:
      - name: tagged
        schema: string
        description: String list (semicolon delimited).
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
          sort = hot => none
          sort = week => none
          sort = month => none
          sort = relevance => none
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
          sort = hot => none
          sort = week => none
          sort = month => none
          sort = relevance => none
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /questions/featured
    method: listFeaturedQuestions
    httpMethod: get
    tag: Question
    typeScriptTag: question
    description: >
      Returns all the questions with active bounties in the system.
       
      The sorts accepted by this method operate on the follow fields of the
      question object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of questions.
    parameters:
      - name: tagged
        schema: string
        description: String list (semicolon delimited).
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /questions/no-answers
    method: listNoAnswerQuestions
    httpMethod: get
    tag: Answer
    typeScriptTag: answer
    description: >
      Returns questions which have received no answers.
       
      Compare with /questions/unanswered which mearly returns questions that the
      sites consider insufficiently well answered.
       
      This method corresponds roughly with the this site tab.
       
      To constrain questions returned to those with a set of tags, use the
      tagged parameter with a semi-colon delimited list of tags. This is an and
      contraint, passing tagged=c;java will return only those questions with
      both tags. As such, passing more than 5 tags will always return zero
      results.
       
      The sorts accepted by this method operate on the follow fields of the
      question object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of questions.
    parameters:
      - name: tagged
        schema: string
        description: String list (semicolon delimited).
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /questions/unanswered
    method: getListOfUnansweredQuestions
    httpMethod: get
    tag: Answer
    typeScriptTag: answer
    description: >
      Returns questions the site considers to be unanswered.
       
      Note that just because a question has an answer, that does not mean it is
      considered answered. While the rules are subject to change, at this time a
      question must have at least one upvoted answer to be considered answered.
       
      To constrain questions returned to those with a set of tags, use the
      tagged parameter with a semi-colon delimited list of tags. This is an and
      contraint, passing tagged=c;java will return only those questions with
      both tags. As such, passing more than 5 tags will always return zero
      results.
       
      Compare with /questions/no-answers.
       
      This method corresponds roughly with the unanswered tab.
       
      The sorts accepted by this method operate on the follow fields of the
      question object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of questions.
    parameters:
      - name: tagged
        schema: string
        description: String list (semicolon delimited).
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /questions/{ids}
    method: getByIds
    httpMethod: get
    tag: Question
    typeScriptTag: question
    description: >
      Returns the questions identified in {ids}.
       
      This is most useful for fetching fresh data when maintaining a cache of
      question ids, or polling for changes.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for question_id on question objects.
       
      The sorts accepted by this method operate on the follow fields of the
      question object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of questions.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /questions/{ids}/answers
    method: getListByQuestionIds
    httpMethod: get
    tag: Answer
    typeScriptTag: answer
    description: >
      Gets the answers to a set of questions identified in id.
       
      This method is most useful if you have a set of interesting questions, and
      you wish to obtain all of their answers at once or if you are polling for
      new or updates answers (in conjunction with sort=activity).
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for question_id on question objects.
       
      The sorts accepted by this method operate on the follow fields of the
      answer object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of answers.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /questions/{ids}/comments
    method: getCommentsList
    httpMethod: get
    tag: Comment
    typeScriptTag: comment
    description: >
      Gets the comments on a question.
       
      If you know that you have an question id and need the comments, use this
      method. If you know you have a answer id, use /answers/{ids}/comments. If
      you are unsure, use /posts/{ids}/comments.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for question_id on question objects.
       
      The sorts accepted by this method operate on the follow fields of the
      comment object:
       - creation - creation_date
       - votes - score
        creation is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of comments.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /questions/{ids}/linked
    method: getLinkedQuestions
    httpMethod: get
    tag: Question
    typeScriptTag: question
    description: >
      Gets questions which link to those questions identified in {ids}.
       
      This method only considers questions that are linked within a site, and
      will never return questions from another Stack Exchange site.
       
      A question is considered "linked" when it explicitly includes a hyperlink
      to another question, there are no other heuristics.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for question_id on question objects.
       
      The sorts accepted by this method operate on the follow fields of the
      question object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
       - rank - a priority sort by site applies, subject to change at any time Does not accept min or max
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of questions.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
          sort = rank => none
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
          sort = rank => none
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /questions/{ids}/related
    method: listRelatedQuestions
    httpMethod: get
    tag: Question
    typeScriptTag: question
    description: >
      Returns questions that the site considers related to those identified in
      {ids}.
       
      The algorithm for determining if questions are related is not documented,
      and subject to change at any time. Futhermore, these values are very
      heavily cached, and may not update immediately after a question has been
      editted. It is also not guaranteed that a question will be considered
      related to any number (even non-zero) of questions, and a consumer should
      be able to handle a variable number of returned questions.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for question_id on question objects.
       
      The sorts accepted by this method operate on the follow fields of the
      question object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
       - rank - a priority sort by site applies, subject to change at any time Does not accept min or max
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of questions.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
          sort = rank => none
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
          sort = rank => none
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /questions/{ids}/timeline
    method: getTimelineEvents
    httpMethod: get
    tag: Question
    typeScriptTag: question
    description: >
      Returns a subset of the events that have happened to the questions
      identified in id.
       
      This provides data similar to that found on a question's timeline page.
       
      Voting data is scrubbed to deter inferencing of voter identity.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for question_id on question objects.
       
      This method returns a list of question timeline events.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /revisions/{ids}
    method: listRevisionsByIds
    httpMethod: get
    tag: Revision
    typeScriptTag: revision
    description: >
      Returns edit revisions identified by ids in {ids}.
       
      {ids} can contain up to 20 semicolon delimited ids, to find ids
      programatically look for revision_guid on revision objects. Note that
      unlike most other id types in the API, revision_guid is a string.
       
      This method returns a list of revisions.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Guid list (semicolon delimited).
        example: IDS
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /search
    method: siteQuestionsSearch
    httpMethod: get
    tag: Query
    typeScriptTag: query
    description: >
      Searches a site for any questions which fit the given criteria.
       
      This method is intentionally quite limited. For more general searching,
      you should use a proper internet search engine restricted to the domain of
      the site in question.
       
      At least one of tagged or intitle must be set on this method. nottagged is
      only used if tagged is also set, for performance reasons.
       
      tagged and nottagged are semi-colon delimited list of tags. At least 1 tag
      in tagged will be on each returned question if it is passed, making it the
      OR equivalent of the AND version of tagged on /questions.
       
      The sorts accepted by this method operate on the follow fields of the
      question object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
       - relevance - matches the relevance tab on the site itself Does not accept min or max
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of questions.
    parameters:
      - name: tagged
        schema: string
        description: String list (semicolon delimited).
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
          sort = relevance => none
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
          sort = relevance => none
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
      - name: intitle
        schema: string
        description: ''
      - name: nottagged
        schema: string
        description: String list (semicolon delimited).
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /search/advanced
    method: siteQuestionsAdvancedSearch
    httpMethod: get
    tag: Search
    typeScriptTag: search
    description: >
      Searches a site for any questions which fit the given criteria.
       
      Search criteria are expressed using the following parameters:
        - q - a free form text parameter, will match all question properties based on an undocumented algorithm.
       - accepted - true to return only questions with accepted answers, false to return only those without. Omit to elide constraint.
       - answers - the minimum number of answers returned questions must have.
       - body - text which must appear in returned questions' bodies.
       - closed - true to return only closed questions, false to return only open ones. Omit to elide constraint.
       - migrated - true to return only questions migrated away from a site, false to return only those not. Omit to elide constraint.
       - notice - true to return only questions with post notices, false to return only those without. Omit to elide constraint.
       - nottagged - a semicolon delimited list of tags, none of which will be present on returned questions.
       - tagged - a semicolon delimited list of tags, of which at least one will be present on all returned questions.
       - title - text which must appear in returned questions' titles.
       - user - the id of the user who must own the questions returned.
       - url - a url which must be contained in a post, may include a wildcard.
       - views - the minimum number of views returned questions must have.
       - wiki - true to return only community wiki questions, false to return only non-community wiki ones. Omit to elide constraint.

        
      At least one additional parameter must be set if nottagged is set, for
      performance reasons.
       
      The sorts accepted by this method operate on the follow fields of the
      question object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
       - relevance - matches the relevance tab on the site itself Does not accept min or max
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of questions.
    parameters:
      - name: tagged
        schema: string
        description: String list (semicolon delimited).
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
          sort = relevance => none
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
          sort = relevance => none
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
      - name: accepted
        schema: string
        description: ''
      - name: answers
        schema: integer
        description: ''
      - name: body
        schema: string
        description: ''
      - name: closed
        schema: string
        description: ''
      - name: migrated
        schema: string
        description: ''
      - name: notice
        schema: string
        description: ''
      - name: nottagged
        schema: string
        description: String list (semicolon delimited).
      - name: q
        schema: string
        description: ''
      - name: title
        schema: string
        description: ''
      - name: url
        schema: string
        description: ''
      - name: user
        schema: integer
        description: ''
      - name: views
        schema: integer
        description: ''
      - name: wiki
        schema: string
        description: ''
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /similar
    method: similarQuestionsSearch
    httpMethod: get
    tag: Query
    typeScriptTag: query
    description: >
      Returns questions which are similar to a hypothetical one based on a title
      and tag combination.
       
      This method is roughly equivalent to a site's related questions suggestion
      on the ask page.
       
      This method is useful for correlating data outside of a Stack Exchange
      site with similar content within one.
       
      Note that title must always be passed as a parameter. tagged and nottagged
      are optional, semi-colon delimited lists of tags.
       
      If tagged is passed it is treated as a preference, there is no guarantee
      that questions returned will have any of those tags. nottagged is treated
      as a requirement, no questions will be returned with those tags.
       
      The sorts accepted by this method operate on the follow fields of the
      question object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
       - relevance - order by "how similar" the questions are, most likely candidate first with a descending order Does not accept min or max
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of questions.
    parameters:
      - name: tagged
        schema: string
        description: String list (semicolon delimited).
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
          sort = relevance => none
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
          sort = relevance => none
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
      - name: nottagged
        schema: string
        description: String list (semicolon delimited).
      - name: title
        schema: string
        description: ''
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /sites
    method: listSites
    httpMethod: get
    tag: Site
    typeScriptTag: site
    description: >
      Returns all sites in the network.
       
      This method allows for discovery of new sites, and changes to existing
      ones. Be aware that unlike normal API methods, this method should be
      fetched very infrequently, it is very unusual for these values to change
      more than once on any given day. It is suggested that you cache its return
      for at least one day, unless your app encounters evidence that it has
      changed (such as from the /info method).
       
      The pagesize parameter for this method is unbounded, in acknowledgement
      that for many applications repeatedly fetching from /sites would
      complicate start-up tasks needlessly.
       
      This method returns a list of sites.
    parameters:
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /suggested-edits
    method: listSuggestedEdits
    httpMethod: get
    tag: Edit
    typeScriptTag: edit
    description: >
      Returns all the suggested edits in the systems.
       
      This method returns a list of suggested-edits.
       
      The sorts accepted by this method operate on the follow fields of the
      suggested_edit object:
       - creation - creation_date
       - approval - approval_date Does not return unapproved suggested_edits
       - rejection - rejection_date Does not return unrejected suggested_edits
        creation is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    parameters:
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = creation => date
          sort = approval => date
          sort = rejection => date
      - name: min
        schema: string
        description: |
          sort = creation => date
          sort = approval => date
          sort = rejection => date
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /suggested-edits/{ids}
    method: listSuggestedEdits
    httpMethod: get
    tag: Edit
    typeScriptTag: edit
    description: >
      Returns suggested edits identified in ids.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for suggested_edit_id on suggested_edit objects.
       
      The sorts accepted by this method operate on the follow fields of the
      suggested_edit object:
       - creation - creation_date
       - approval - approval_date Does not return unapproved suggested_edits
       - rejection - rejection_date Does not return unrejected suggested_edits
        creation is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of suggested-edits.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = creation => date
          sort = approval => date
          sort = rejection => date
      - name: min
        schema: string
        description: |
          sort = creation => date
          sort = approval => date
          sort = rejection => date
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /tags
    method: getTagsList
    httpMethod: get
    tag: Information
    typeScriptTag: information
    description: >
      Returns the tags found on a site.
       
      The inname parameter lets a consumer filter down to tags that contain a
      certain substring. For example, inname=own would return both "download"
      and "owner" amongst others.
       
      This method returns a list of tags.
       
      The sorts accepted by this method operate on the follow fields of the tag
      object:
       - popular - count
       - activity - the creation_date of the last question asked with the tag
       - name - name
        popular is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    parameters:
      - name: inname
        schema: string
        description: ''
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = popular => number
          sort = activity => date
          sort = name => string
      - name: min
        schema: string
        description: |
          sort = popular => number
          sort = activity => date
          sort = name => string
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /tags/moderator-only
    method: getModeratorOnlyTagsList
    httpMethod: get
    tag: Tag
    typeScriptTag: tag
    description: >
      Returns the tags found on a site that only moderators can use.
       
      The inname parameter lets a consumer filter down to tags that contain a
      certain substring. For example, inname=own would return both "download"
      and "owner" amongst others.
       
      This method returns a list of tags.
       
      The sorts accepted by this method operate on the follow fields of the tag
      object:
       - popular - count
       - activity - the creation_date of the last question asked with the tag
       - name - name
        popular is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    parameters:
      - name: inname
        schema: string
        description: ''
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = popular => number
          sort = activity => date
          sort = name => string
      - name: min
        schema: string
        description: |
          sort = popular => number
          sort = activity => date
          sort = name => string
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /tags/required
    method: listRequiredTags
    httpMethod: get
    tag: Tag
    typeScriptTag: tag
    description: >
      Returns the tags found on a site that fulfill required tag constraints on
      questions.
       
      The inname parameter lets a consumer filter down to tags that contain a
      certain substring. For example, inname=own would return both "download"
      and "owner" amongst others.
       
      This method returns a list of tags.
       
      The sorts accepted by this method operate on the follow fields of the tag
      object:
       - popular - count
       - activity - the creation_date of the last question asked with the tag
       - name - name
        popular is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    parameters:
      - name: inname
        schema: string
        description: ''
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = popular => number
          sort = activity => date
          sort = name => string
      - name: min
        schema: string
        description: |
          sort = popular => number
          sort = activity => date
          sort = name => string
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /tags/synonyms
    method: synonymsList
    httpMethod: get
    tag: Tag
    typeScriptTag: tag
    description: >
      Returns all tag synonyms found a site.
       
      When searching for synonyms of specific tags, it is better to use
      /tags/{tags}/synonyms over this method.
       
      The sorts accepted by this method operate on the follow fields of the
      tag_synonym object:
       - creation - creation_date
       - applied - applied_count
       - activity - last_applied_date
        creation is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of tag_synonyms.
    parameters:
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = creation => date
          sort = applied => number
          sort = activity => date
      - name: min
        schema: string
        description: |
          sort = creation => date
          sort = applied => number
          sort = activity => date
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /tags/{tags}/faq
    method: getFaqQuestions
    httpMethod: get
    tag: Tag
    typeScriptTag: tag
    description: >
      Returns the frequently asked questions for the given set of tags in
      {tags}.
       
      For a question to be returned, it must have all the tags in {tags} and be
      considered "frequently asked". The exact algorithm for determining whether
      a question is considered a FAQ is subject to change at any time.
       
      {tags} can contain up to 5 individual tags per request.
       
      This method returns a list of questions.
    parameters:
      - name: tags
        schema: string
        required: true
        description: String list (semicolon delimited).
        example: TAGS
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /tags/{tags}/info
    method: getTagInfo
    httpMethod: get
    tag: Tag
    typeScriptTag: tag
    description: >
      Returns tag objects representing the tags in {tags} found on the site.
       
      This method diverges from the standard naming patterns to avoid to
      conflicting with existing methods, due to the free form nature of tag
      names.
       
      This method returns a list of tags.
       
      The sorts accepted by this method operate on the follow fields of the tag
      object:
       - popular - count
       - activity - the creation_date of the last question asked with the tag
       - name - name
        popular is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    parameters:
      - name: tags
        schema: string
        required: true
        description: String list (semicolon delimited).
        example: TAGS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = popular => number
          sort = activity => date
          sort = name => string
      - name: min
        schema: string
        description: |
          sort = popular => number
          sort = activity => date
          sort = name => string
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /tags/{tags}/related
    method: getRelatedTags
    httpMethod: get
    tag: Tag
    typeScriptTag: tag
    description: >
      Returns the tags that are most related to those in {tags}.
       
      Including multiple tags in {tags} is equivalent to asking for "tags
      related to tag #1 and tag #2" not "tags related to tag #1 or tag #2".
       
      count on tag objects returned is the number of question with that tag that
      also share all those in {tags}.
       
      {tags} can contain up to 4 individual tags per request.
       
      This method returns a list of tags.
    parameters:
      - name: tags
        schema: string
        required: true
        description: String list (semicolon delimited).
        example: TAGS
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /tags/{tags}/synonyms
    method: listSynonyms
    httpMethod: get
    tag: Tag
    typeScriptTag: tag
    description: >
      Gets all the synonyms that point to the tags identified in {tags}. If
      you're looking to discover all the tag synonyms on a site, use the
      /tags/synonyms methods instead of call this method on all tags.
       
      {tags} can contain up to 20 individual tags per request.
       
      The sorts accepted by this method operate on the follow fields of the
      tag_synonym object:
       - creation - creation_date
       - applied - applied_count
       - activity - last_applied_date
        creation is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of tag synonyms.
    parameters:
      - name: tags
        schema: string
        required: true
        description: String list (semicolon delimited).
        example: TAGS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = creation => date
          sort = applied => number
          sort = activity => date
      - name: min
        schema: string
        description: |
          sort = creation => date
          sort = applied => number
          sort = activity => date
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /tags/{tags}/wikis
    method: getTagWikis
    httpMethod: get
    tag: Tag
    typeScriptTag: tag
    description: |
      Returns the wikis that go with the given set of tags in {tags}.
       
      Be aware that not all tags have wikis.
       
      {tags} can contain up to 20 individual tags per request.
       
      This method returns a list of tag wikis.
    parameters:
      - name: tags
        schema: string
        required: true
        description: String list (semicolon delimited).
        example: TAGS
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /tags/{tag}/top-answerers/{period}
    method: tagTopAnswerers
    httpMethod: get
    tag: Answer
    typeScriptTag: answer
    description: >
      Returns the top 30 answerers active in a single tag, of either all-time or
      the last 30 days.
       
      This is a view onto the data presented on the tag info page on the sites.
       
      This method returns a list of tag score objects.
    parameters:
      - name: tag
        schema: string
        required: true
        description: ''
        example: TAG
      - name: period
        schema: string
        required: true
        description: ''
        example: PERIOD
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /tags/{tag}/top-askers/{period}
    method: getTopAskersByPeriod
    httpMethod: get
    tag: Tag
    typeScriptTag: tag
    description: >
      Returns the top 30 askers active in a single tag, of either all-time or
      the last 30 days.
       
      This is a view onto the data presented on the tag info page on the sites.
       
      This method returns a list of tag score objects.
    parameters:
      - name: tag
        schema: string
        required: true
        description: ''
        example: TAG
      - name: period
        schema: string
        required: true
        description: ''
        example: PERIOD
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users
    method: listUsers
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Returns all users on a site.
       
      This method returns a list of users.
       
      The sorts accepted by this method operate on the follow fields of the user
      object:
       - reputation - reputation
       - creation - creation_date
       - name - display_name
       - modified - last_modified_date
        reputation is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      The inname parameter lets consumers filter the results down to just those
      users with a certain substring in their display name. For example,
      inname=kevin will return all users with both users named simply "Kevin" or
      those with Kevin as one of (or part of) their names; such as "Kevin
      Montrose".
    parameters:
      - name: inname
        schema: string
        description: ''
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = reputation => number
          sort = creation => date
          sort = name => string
          sort = modified => date
      - name: min
        schema: string
        description: |
          sort = reputation => number
          sort = creation => date
          sort = name => string
          sort = modified => date
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/moderators
    method: listModeratorUsers
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Gets those users on a site who can exercise moderation powers.
       
      Note, employees of Stack Exchange Inc. will be returned if they have been
      granted moderation powers on a site even if they have never been appointed
      or elected explicitly. This method checks abilities, not the manner in
      which they were obtained.
       
      The sorts accepted by this method operate on the follow fields of the user
      object:
       - reputation - reputation
       - creation - creation_date
       - name - display_name
       - modified - last_modified_date
        reputation is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of users.
    parameters:
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = reputation => number
          sort = creation => date
          sort = name => string
          sort = modified => date
      - name: min
        schema: string
        description: |
          sort = reputation => number
          sort = creation => date
          sort = name => string
          sort = modified => date
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/moderators/elected
    method: listElectedModeratorUsers
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Returns those users on a site who both have moderator powers, and were
      actually elected.
       
      This method excludes Stack Exchange Inc. employees, unless they were
      actually elected moderators on a site (which can only have happened prior
      to their employment).
       
      The sorts accepted by this method operate on the follow fields of the user
      object:
       - reputation - reputation
       - creation - creation_date
       - name - display_name
       - modified - last_modified_date
        reputation is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of users.
    parameters:
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = reputation => number
          sort = creation => date
          sort = name => string
          sort = modified => date
      - name: min
        schema: string
        description: |
          sort = reputation => number
          sort = creation => date
          sort = name => string
          sort = modified => date
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{ids}
    method: getUserProfilesByIds
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Gets the users identified in ids in {ids}.
       
      Typically this method will be called to fetch user profiles when you have
      obtained user ids from some other source, such as /questions.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for user_id on user or shallow_user objects.
       
      The sorts accepted by this method operate on the follow fields of the user
      object:
       - reputation - reputation
       - creation - creation_date
       - name - display_name
       - modified - last_modified_date
        reputation is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of users.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = reputation => number
          sort = creation => date
          sort = name => string
          sort = modified => date
      - name: min
        schema: string
        description: |
          sort = reputation => number
          sort = creation => date
          sort = name => string
          sort = modified => date
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{ids}/answers
    method: getUserAnswersList
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Returns the answers the users in {ids} have posted.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for user_id on user or shallow_user objects.
       
      The sorts accepted by this method operate on the follow fields of the
      answer object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of answers.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{ids}/associated
    method: getAssociatedAccounts
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Returns all of a user's associated accounts, given their account_ids in
      {ids}.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for account_id on user objects.
       
      This method returns a list of network_users.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{ids}/badges
    method: listUserBadges
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Get the badges the users in {ids} have earned.
       
      Badge sorts are a tad complicated. For the purposes of sorting (and
      min/max) tag_based is considered to be greater than named.
       
      This means that you can get a list of all tag based badges a user has by
      passing min=tag_based, and conversely all the named badges by passing
      max=named, with sort=type.
       
      For ranks, bronze is greater than silver which is greater than gold. Along
      with sort=rank, set max=gold for just gold badges, max=silver&min=silver
      for just silver, and min=bronze for just bronze.
       
      rank is the default sort.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for user_id on user or shallow_user objects.
       
      This method returns a list of badges.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = rank => string
          sort = name => string
          sort = type => string
          sort = awarded => date
      - name: min
        schema: string
        description: |
          sort = rank => string
          sort = name => string
          sort = type => string
          sort = awarded => date
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{ids}/comments
    method: getCommentsByIds
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Get the comments posted by users in {ids}.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for user_id on user or shallow_user objects.
       
      The sorts accepted by this method operate on the follow fields of the
      comment object:
       - creation - creation_date
       - votes - score
        creation is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of comments.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{ids}/comments/{toid}
    method: getUserCommentsByIdsAndToid
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Get the comments that the users in {ids} have posted in reply to the
      single user identified in {toid}.
       
      This method is useful for extracting conversations, especially over time
      or across multiple posts.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for user_id on user or shallow_user objects. {toid}
      can contain only 1 id, found in the same manner as those in {ids}.
       
      The sorts accepted by this method operate on the follow fields of the
      comment object:
       - creation - creation_date
       - votes - score
        creation is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of comments.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: toid
        schema: integer
        required: true
        description: ''
        example: 0
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{ids}/favorites
    method: getFavoritesList
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Get the questions that users in {ids} have favorited.
       
      This method is effectively a view onto a user's favorites tab.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for user_id on user or shallow_user objects.
       
      The sorts accepted by this method operate on the follow fields of the
      question object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
       - added - when the user favorited the question
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of questions.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
          sort = added => date
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
          sort = added => date
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{ids}/mentioned
    method: mentionedCommentsList
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Gets all the comments that the users in {ids} were mentioned in.
       
      Note, to count as a mention the comment must be considered to be "in reply
      to" a user. Most importantly, this means that a comment can only be in
      reply to a single user.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for user_id on user or shallow_user objects.
       
      The sorts accepted by this method operate on the follow fields of the
      comment object:
       - creation - creation_date
       - votes - score
        It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of comments.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{ids}/merges
    method: listAccountMerges
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Returns a record of merges that have occurred involving the passed account
      ids.
       
      This method allows you to take now invalid account ids and find what
      account they've become, or take currently valid account ids and find which
      ids were equivalent in the past.
       
      This is most useful when confirming that an account_id is in fact "new" to
      an application.
       
      Account merges can happen for a wide range of reasons, applications should
      not make assumptions that merges have particular causes.
       
      Note that accounts are managed at a network level, users on a site may be
      merged due to an account level merge but there is no guarantee that a
      merge has an effect on any particular site.
       
      This method returns a list of account_merge.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{ids}/questions
    method: getQuestionsByUserIds
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Gets the questions asked by the users in {ids}.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for user_id on user or shallow_user objects.
       
      The sorts accepted by this method operate on the follow fields of the
      question object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of questions.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{ids}/questions/featured
    method: getFeaturedQuestions
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Gets the questions on which the users in {ids} have active bounties.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for user_id on user or shallow_user objects.
       
      The sorts accepted by this method operate on the follow fields of the
      question object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of questions.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{ids}/questions/no-answers
    method: listNoAnswerQuestions
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Gets the questions asked by the users in {ids} which have no answers.
       
      Questions returns by this method actually have zero undeleted answers. It
      is completely disjoint /users/{ids}/questions/unanswered and
      /users/{ids}/questions/unaccepted, which only return questions with at
      least one answer, subject to other contraints.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for user_id on user or shallow_user objects.
       
      The sorts accepted by this method operate on the follow fields of the
      question object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of questions.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{ids}/questions/unaccepted
    method: getUnacceptedQuestions
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Gets the questions asked by the users in {ids} which have at least one
      answer, but no accepted answer.
       
      Questions returned by this method have answers, but the owner has not
      opted to accept any of them.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for user_id on user or shallow_user objects.
       
      The sorts accepted by this method operate on the follow fields of the
      question object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of questions.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{ids}/questions/unanswered
    method: getUnansweredQuestions
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Gets the questions asked by the users in {ids} which the site consideres
      unanswered, while still having at least one answer posted.
       
      These rules are subject to change, but currently any question without at
      least one upvoted or accepted answer is considered unanswered.
       
      To get the set of questions that a user probably considers unanswered, the
      returned questions should be unioned with those returned by
      /users/{id}/questions/no-answers. These methods are distinct so that truly
      unanswered (that is, zero posted answers) questions can be easily
      separated from mearly poorly or inadequately answered ones.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for user_id on user or shallow_user objects.
       
      The sorts accepted by this method operate on the follow fields of the
      question object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of questions.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{ids}/reputation
    method: getReputationChanges
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Gets a subset of the reputation changes for users in {ids}.
       
      Reputation changes are intentionally scrubbed of some data to make it
      difficult to correlate votes on particular posts with user reputation
      changes. That being said, this method returns enough data for reasonable
      display of reputation trends.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for user_id on user or shallow_user objects.
       
      This method returns a list of reputation objects.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{ids}/reputation-history
    method: getReputationHistory
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: |
      Returns users' public reputation history.
       
      This method returns a list of reputation_history.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{ids}/suggested-edits
    method: getSuggestedEditsByIds
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Returns the suggested edits a users in {ids} have submitted.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for user_id on user or shallow_user objects.
       
      The sorts accepted by this method operate on the follow fields of the
      suggested_edit object:
       - creation - creation_date
       - approval - approval_date Does not return unapproved suggested_edits
       - rejection - rejection_date Does not return unrejected suggested_edits
        creation is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of suggested-edits.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = creation => date
          sort = approval => date
          sort = rejection => date
      - name: min
        schema: string
        description: |
          sort = creation => date
          sort = approval => date
          sort = rejection => date
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{ids}/tags
    method: getTags
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Returns the tags the users identified in {ids} have been active in.
       
      This route corresponds roughly to user's stats tab, but does not include
      tag scores. A subset of tag scores are available (on a single user basis)
      in /users/{id}/top-answer-tags and /users/{id}/top-question-tags.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for user_id on user or shallow_user objects.
       
      The sorts accepted by this method operate on the follow fields of the tag
      object:
       - popular - count
       - activity - the creation_date of the last question asked with the tag
       - name - name
        popular is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of tags.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = popular => number
          sort = activity => date
          sort = name => string
      - name: min
        schema: string
        description: |
          sort = popular => number
          sort = activity => date
          sort = name => string
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{ids}/timeline
    method: getUserTimelineByIds
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Returns a subset of the actions the users in {ids} have taken on the site.
       
      This method returns users' posts, edits, and earned badges in the order
      they were accomplished. It is possible to filter to just a window of
      activity using the fromdate and todate parameters.
       
      {ids} can contain up to 100 semicolon delimited ids, to find ids
      programatically look for user_id on user or shallow_user objects.
       
      This method returns a list of user timeline objects.
    parameters:
      - name: ids
        schema: string
        required: true
        description: Number list (semicolon delimited).
        example: IDS
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{id}/inbox
    method: getInboxItems
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Returns a user's inbox.
       
      This method requires an access_token, with a scope containing
      "read_inbox".
       
      This method is effectively an alias for /inbox. It is provided for
      consumers who make strong assumptions about operating within the context
      of a single site rather than the Stack Exchange network as a whole.
       
      {id} can contain a single id, to find it programatically look for user_id
      on user or shallow_user objects.
       
      This method returns a list of inbox items.
    parameters:
      - name: id
        schema: integer
        required: true
        description: ''
        example: 0
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{id}/inbox/unread
    method: getInboxUnread
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Returns the unread items in a user's inbox.
       
      This method requires an access_token, with a scope containing
      "read_inbox".
       
      This method is effectively an alias for /inbox/unread. It is provided for
      consumers who make strong assumptions about operating within the context
      of a single site rather than the Stack Exchange network as a whole.
       
      {id} can contain a single id, to find it programatically look for user_id
      on user or shallow_user objects.
       
      This method returns a list of inbox items.
    parameters:
      - name: id
        schema: integer
        required: true
        description: ''
        example: 0
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
      - name: since
        schema: integer
        description: Unix date.
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{id}/notifications
    method: getNotificationsList
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Returns a user's notifications.
       
      This method requires an access_token, with a scope containing
      "read_inbox".
       
      This method returns a list of notifications.
    parameters:
      - name: id
        schema: integer
        required: true
        description: ''
        example: 0
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{id}/notifications/unread
    method: getUnreadNotifications
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Returns a user's unread notifications.
       
      This method requires an access_token, with a scope containing
      "read_inbox".
       
      This method returns a list of notifications.
    parameters:
      - name: id
        schema: integer
        required: true
        description: ''
        example: 0
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{id}/privileges
    method: getPrivilegesList
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Returns the privileges a user has.
       
      Applications are encouraged to calculate privileges themselves, without
      repeated queries to this method. A simple check against the results
      returned by /privileges and user.user_type would be sufficient.
       
      {id} can contain only a single, to find it programatically look for
      user_id on user or shallow_user objects.
       
      This method returns a list of privileges.
    parameters:
      - name: id
        schema: integer
        required: true
        description: ''
        example: 0
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{id}/reputation-history/full
    method: getFullReputationHistory
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Returns a user's full reputation history, including private events.
       
      This method requires an access_token, with a scope containing
      "private_info".
       
      This method returns a list of reputation_history.
    parameters:
      - name: id
        schema: integer
        required: true
        description: ''
        example: 0
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{id}/tags/{tags}/top-answers
    method: getUserTopAnswers
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Returns the top 30 answers a user has posted in response to questions with
      the given tags.
       
      {id} can contain a single id, to find it programatically look for user_id
      on user or shallow_user objects. {tags} is limited to 5 tags, passing more
      will result in an error.
       
      The sorts accepted by this method operate on the follow fields of the
      answer object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of answers.
    parameters:
      - name: id
        schema: integer
        required: true
        description: ''
        example: 0
      - name: tags
        schema: string
        required: true
        description: String list (semicolon delimited).
        example: TAGS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{id}/tags/{tags}/top-questions
    method: getTopQuestionsByTags
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Returns the top 30 questions a user has asked with the given tags.
       
      {id} can contain a single id, to find it programatically look for user_id
      on user or shallow_user objects. {tags} is limited to 5 tags, passing more
      will result in an error.
       
      The sorts accepted by this method operate on the follow fields of the
      question object:
       - activity - last_activity_date
       - creation - creation_date
       - votes - score
        activity is the default sort.
       
       It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.

       
      This method returns a list of questions.
    parameters:
      - name: id
        schema: integer
        required: true
        description: ''
        example: 0
      - name: tags
        schema: string
        required: true
        description: String list (semicolon delimited).
        example: TAGS
      - name: order
        schema: string
        description: ''
      - name: max
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: min
        schema: string
        description: |
          sort = activity => date
          sort = creation => date
          sort = votes => number
      - name: sort
        schema: string
        description: ''
      - name: fromdate
        schema: integer
        description: Unix date.
      - name: todate
        schema: integer
        description: Unix date.
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{id}/top-answer-tags
    method: getUserTopAnswerTags
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Returns a single user's top tags by answer score.
       
      This a subset of the data returned on a user's tags tab.
       
      {id} can contain a single id, to find it programatically look for user_id
      on user or shallow_user objects.
       
      This method returns a list of top_tag objects.
    parameters:
      - name: id
        schema: integer
        required: true
        description: ''
        example: 0
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{id}/top-question-tags
    method: getTopQuestionTags
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Returns a single user's top tags by question score.
       
      This a subset of the data returned on a user's tags tab.
       
      {id} can contain a single id, to find it programatically look for user_id
      on user or shallow_user objects.
       
      This method returns a list of top_tag objects.
    parameters:
      - name: id
        schema: integer
        required: true
        description: ''
        example: 0
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
  - url: /users/{id}/write-permissions
    method: getWritePermissions
    httpMethod: get
    tag: User
    typeScriptTag: user
    description: >
      Returns the write permissions a user has via the api.
       
      The Stack Exchange API gives users the ability to create, edit, and delete
      certain types. This method returns whether the passed user is capable of
      performing those actions at all, as well as how many times a day they can.
       
      This method does not consider the user's current quota (ie. if they've
      already exhausted it for today) nor any additional restrictions on write
      access, such as editing deleted comments.
       
      This method returns a list of write_permissions.
    parameters:
      - name: id
        schema: integer
        required: true
        description: ''
        example: 0
      - name: pagesize
        schema: integer
        description: ''
      - name: page
        schema: integer
        description: ''
      - name: filter
        schema: string
        description: >
          #Discussion


          The Stack Exchange API allows applications to exclude almost every
          field returned. For example, if an application did not care about a
          user's badge counts it could exclude user.badge_counts whenever it
          calls a method that returns users.


          An application excludes fields by creating a filter (via
          /filter/create) and passing it to a method in the filter parameter.


          Filters are immutable and non-expiring. An application can safely
          "bake in" any filters that are created, it is not necessary (or
          advisable) to create filters at runtime.


          The motivation for filters are several fold. Filters allow
          applications to reduce API responses to just the fields they are
          concerned with, saving bandwidth. With the list of fields an
          application is actually concerned with, the API can avoid unneccessary
          queries thereby decreasing response time (and reducing load on our
          infrastructure). Finally, filters allow us to be more conservative in
          what the API returns by default without a proliferation of parameters
          (as was seen with body, answers, and comments in the 1.x API family).


          #Safety


          Filters also carry a notion of safety, which is defined as follows.
          Any string returned as a result of an API call with a safe filter will
          be inline-able into HTML without script-injection concerns. That is to
          say, no additional sanitizing (encoding, HTML tag stripping, etc.)
          will be necessary on returned strings. Applications that wish to
          handle sanitizing themselves should create an unsafe filter. All
          filters are safe by default, under the assumption that double-encoding
          bugs are more desirable than script injections.


          Note that this does not mean that "safe" filter is mearly an "unsafe"
          one with all fields passed though UrlEncode(...). Many fields can and
          will contain HTML in all filter types (most notably, the *.body
          fields).


          When using unsafe filters, the API returns the highest fidelity data
          it can reasonably access for the given request. This means that in
          cases where the "safe" data is the only accessible data it will be
          returned even in "unsafe" filters. Notably the *.body fields are
          unchanged, as they are stored in that form. Fields that are unchanged
          between safe and unsafe filters are denoted in their types
          documentation.


          #Built In Filters


          The following filters are built in:


          default, each type documents which fields are returned under the
          default filter (for example, answers).

          withbody, which is default plus the *.body fields

          none, which is empty

          total, which includes just .total


          #Compatibility with V1.x


          For ease of transition from earlier API versions, the filters _b, _ba,
          _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and
          exclude a combination of question and answer body, comments, and
          answers so as to mimic the body, answers, and comments parameters that
          have been removed in V2.0. New applications should not use these
          filters.
      - name: callback
        schema: string
        description: >
          All API responses are JSON, we do support JSONP with the callback
          query parameter.
      - name: site
        schema: string
        required: true
        description: >
          Each of these methods operates on a single site at a time, identified
          by the site parameter. This parameter can be the full domain name (ie.
          "stackoverflow.com"), or a short form identified by api_site_parameter
          on the site object.
        example: SITE
    responses:
      - statusCode: '200'
        description: ''
      - statusCode: '400'
        description: >
          bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this
          includes even "high level" parameters like key or site.
      - statusCode: '401'
        description: >
          access_token_required Ã¢â‚¬â€œ 401 A method that requires an access
          token (obtained via authentication) was called without one.
      - statusCode: '402'
        description: >
          invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed
          to a method.
      - statusCode: '403'
        description: >
          access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions
          was called with an access token that lacks those permissions.
      - statusCode: '404'
        description: >
          no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does
          not exist. Note, calling methods that expect numeric ids (like
          /users/{ids}) with non-numeric ids can also result in this error.
      - statusCode: '405'
        description: >
          key_required Ã¢â‚¬â€œ 405 A method was called in a manner that
          requires an application key (generally, with an access token), but no
          key was passed.
      - statusCode: '406'
        description: >
          access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer
          believed to be secure, normally because it was used on a non-HTTPS
          call. The access token will be invalidated if this error is returned.
      - statusCode: '500'
        description: >
          internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API.
          It has been logged, and Stack Exchange developers have been notified.
          You should report these errors on Stack Apps if you want to be
          notified when they're fixed.
      - statusCode: '502'
        description: >
          throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of
          the rate limiting contract, so the request was terminated.
      - statusCode: '503'
        description: >
          temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is
          unavailable. Applications should backoff on requests to the method
          invoked.
numberOfSchemas: 34
apiDescription: |
  Stack Exchange is a network of 130+ Q&A communities including Stack Overflow.
