publishJson:
  company: Miso
  serviceName: false
  sdkName: miso-{language}-sdk
  clientName: Miso
  metaDescription: >-
    Miso’s simple APIs empower product teams to realize unlimited
    personalization opportunities. Leading brands are using Miso’s semantic
    intelligence and real-time clickstream analysis to drive a new generation of
    personalized experiences and lift revenues sitewide. And unlike traditional
    solutions, Miso can personalize 100% anonymously — no tracking users or
    mining data.
  apiStatusUrls: inherit
  homepage: miso.ai
  developerDocumentation: docs.miso.ai/
  categories:
    - ai
    - search
rawSpecString: |
  openapi: 3.0.2
  info:
    title: Miso API
    description: >

      # Overview

      Miso’s approach to personalization is to train machine learning Engines on
      three core data sets:


      1. Your site’s log of historical and real-time interactions,

      2. Your catalog of products and content, and

      3. Your users. Miso provides the output of its Engines to you, so you can
      build search and recommendation

      experiences that are personalized down to the individual level (n=1
      personalization).


      To see how Miso works and explore the power of its Engines, we recommend
      following

      [this tutorial](https://docs.askmiso.com/) to get

      started with our Playground data. Integrating your site or application with
      Miso happens in three basic steps:


      1. Upload your data

      2. Train your Engines

      3. Build search and recommendation experiences with the output of your
      Engines.



      Miso provides two main integration points. The first is your [Dojo
      Dashboard](https://dojo.askmiso.com/),

      which is used to set up your Engines with the conversions you want to
      optimize and your training schedule.

      Dojo is also a great way to get familiar with Miso by manually uploading
      data and exploring the output of

      Miso’s Engines. In Dojo’s Sandboxes, you can tweak your Engine settings and
      see visual examples of Miso’s search

      and recommendations running on your live data.


      The second integration point is Miso’s API, which lets you automatically
      manage your data in Miso and build

      experiences that leverage the output of Miso’s personalization Engines.



      Miso’s API is composed of two major groups of REST API endpoints: Data APIs
      and Engine APIs.


      ### Data APIs

      Data APIs collect input to Miso's personalization Engines. These APIs all
      support high-throughput

      data ingestion through bulk insert, and satisfy GDPR and CCPA compliance by
      letting users delete their data

      from Miso. Subcategories of Data APIs are:


      * [Interaction APIs](https://api.askmiso.com), for managing your Interaction
      records. By uploading historical and real-time Interaction

      records, you tell Miso how users are engaging with the products and content
      on your site, and in turn, Miso’s

      Engines learn how to optimize your conversion funnels.

      * [Product / Content APIs](https://api.askmiso.com), for managing your
      Product / Content records. These records provide a deep semantic

      understanding of your catalog and keep Miso up to date about your offerings
      so it can make smart and timely

      suggestions. The `product_id` is how Miso links Product / Content records to
      your Interaction records.

      * [User APIs](https://api.askmiso.com), for managing your User records.
      These records tell Miso about your site’s users and visitors,

      so Miso can build an understanding of user segmentation and behavior in
      relation to products and content.

      The `user_id` is how Miso links User records to your Interaction records.


      As a rule of thumb, we recommend batching up data to avoid timeout risks.
      For the Product / Content and User

      Upload APIs, we recommend limiting each API upload call to about 100 records
      at a time. For the Interaction

      Upload API, we recommend limiting your calls to around 10,000 records at a
      time.


      ### Engine APIs

      Engine APIs provide the output of Miso's personalization Engines. We
      designed these APIs with a focus on low

      latency and high availability. Most of these APIs' 95th percentile response
      time is under 75ms,

      and the services are replicated to at least three separate instances for
      high availability.

      The types of Engine APIs are:


      * [Search APIs](https://api.askmiso.com), for getting Miso’s personalized
      search results for a user, with search-as-you-type and

      autocompletion.

      * [Recommendation APIs](https://api.askmiso.com), for retrieving Miso’s
      recommendations that match users with

      the products, categories, and product attributes that are likely to drive
      conversions.


      # Authentication

      [View your API Keys in your Dojo
      Dashboard.](https://dojo.askmiso.com/docs/api-browser)


      There are three environments in Miso:

      * **Playground**, a read-only tutorial environment with sample data.

      * **Development**, for staging, QA, and experimentation.

      * **Production**, where you run your live integration with Miso.


      Access a Miso environment by passing in the corresponding API key in your
      API calls. There is one publishable

      key and one secret key per environment.


      API Key can passed with query parameter `api_key`, or using the `X-API-KEY`
      header.
    version: 1.1.4
  paths:
    /v1/experiments/{experiment_id_or_slug}/events:
      post:
        tags:
          - Experiment APIs
        summary: Send Experiment Event
        operationId: send_experiment_event_v1_experiments__experiment_id_or_slug__events_post
        requestBody:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ExperimentRequest'
          required: true
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/SendExperimentResponse'
          '401':
            description: Unauthorized
            content:
              application/json:
                example:
                  message: api_key is invalid. Please check your api_key in Dojo.
          '404':
            description: Not Found
            content:
              application/json:
                example:
                  message: Variant is not found. Please check your variant_name.
          '422':
            description: Unprocessable Entity
            content:
              application/json:
                example:
                  message: Request schema error. See "data.errors" for details
                  data:
                    errors:
                      - loc:
                          - body
                          - 35
                        msg: 'Expecting '','' delimiter: line 3 column 5 (char 35)'
                        type: value_error.jsondecode
        security:
          - Secret API Key: []
    /v1/interactions:
      post:
        tags:
          - Interaction APIs
        summary: Interaction Upload API
        description: >-
          Bulk API to insert Interaction records. This endpoint accepts POST
          requests with JSON data  containing an array of

          Interaction records wrapped in a dictionary:


          ```

          POST /v1/interactions


          {"data": [interaction_1, interaction_2, interaction_3]}

          ```


          For real-time tracking, we recommend sending the interaction records to
          this API as soon as the interactions take

          place. This API is also ideal for bulk-inserting historical records that
          your site collected before using Miso.
           Miso can analyze the historical records and provide personalization for your users from the get-go. We recommend
           limiting your calls to around 10,000 records at a time to avoid memory issues or timeout risks.

          ###  Anonymous users

          For users who did not sign in, we can still make recommendations for
          them by tracking their `anonymous_id`, which is a pseudo-unique
          substitute for the `user_id`. The personalization and search APIs all
          accept `anonymous_id` in the place of `user_id` to return tailored
          results for anonymous users.


          When an anonymous user later signs in and the `user_id` and
          `anonymous_id` are both present, the `anonymous_id` will be linked to
          the `user_id` along with the past interactions associated with it.


          The typical mechanism to generate an `anonymous_id` is to use cookies or
          the browser localStorage. However, if you don't collect such information
          in your historical records, a hash of the IP address, optionally
          combined with the User-Agent string, is also a reasonable substitute for
          `anonymous_id`, and is most likely collected by your web server logs
          already.


          ### Schema validation

          The Interaction Upload API will validate the inserted records against
          the API schema.

          Any schema errors will cause the whole request to fail, and none of the
          records will be inserted (`status_code=422`).

          You should check the `response.errors` field to see if there are any
          errors.


          For example, the response below means there are no errors
          (`status_code=200`):

          ```javascript

          {
              "message": "success"
          }

          ```


          Any schema error will cause the whole request to fail: the API will
          return `status_code=422`, and none of the

          records will be inserted. You should check `data` field in the response
          to see where the errors are located. For

          example, the response below means there are schema errors in the
          interaction record at index 0:

          ```javascript

          {
              "errors": true, // there are errors. please check!
              "message": "None of the records were inserted because at least one of them contained schema errors. Please see the `data` field for details.",
              "data": [
                  "data.0.product_ids is invalid. The attribute was expected to be of type ''array', 'null'' but type 'string' was given.",
                  "data.0.timestamp is invalid. The attribute should match the 'date-time' format."
              ]
          }

          ```
        operationId: interaction_upload_api_v1_interactions_post
        requestBody:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InteractionBulkIn'
          required: true
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/InteractionCreateOut'
          '401':
            description: Unauthorized
            content:
              application/json:
                example:
                  message: invalid api key.
          '403':
            description: Forbidden
            content:
              application/json:
                example:
                  message: >-
                    Request is denied due to bot blocking. Please only access this
                    API from a real browser or use Secret API Key instead.
          '422':
            description: Unprocessable Entity
            content:
              application/json:
                example:
                  errors: true
                  message: >-
                    None of the records were inserted because at least one of them
                    contained schema errors. Please see the `data` field for
                    details.
                  data:
                    - >-
                      data.0.product_ids is invalid. The attribute was expected to
                      be of type ''array', 'null'' but type 'string' was given.
                    - >-
                      data.0.timestamp is invalid. The attribute should match the
                      'date-time' format.
        security:
          - Secret API Key: []
          - Publishable API Key: []
      delete:
        tags:
          - Interaction APIs
        summary: Interaction Delete API
        description: >-
          The endpoint will delete users' interaction data entirely from the log
          of interactions you have uploaded to Miso.

          This API enables you to comply with users' data removal requests (i.e.
          right to be forgotten). Once a user's

          interactions are deleted, we will not be able to recover them, and they
          will no longer contribute to model

          training.
        operationId: interaction_delete_api_v1_interactions_delete
        requestBody:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InteractionDeleteIn'
          required: true
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/InteractionDeleteOut'
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
        security:
          - Secret API Key: []
    /v1/products:
      post:
        tags:
          - Product / Content APIs
        summary: Product / Content Upload API
        description: >-
          Bulk API to insert Product records. This API endpoint accepts POST
          requests with JSON data

          containing a list of Product / Content records wrapped in a dictionary:

          ```

          POST /v1/products


          {"data": [product_1, product_2, product_3]}

          ```


          Each product is uniquely identified by its `product_id`. If a record
          with the same `product_id`

          already exists in the dataset, the existing one will be **replaced** by
          the insertion (no

          partial update is allowed at this time). We recommend limiting your
          calls to around 100

          records at a time to avoid memory issues or timeout risks.


          ### Schema validation

          This API validates the inserted records against the API schema; any
          schema error will cause

          the whole request to fail (`status_code=422`), and none of the records
          will be inserted. You

          should check the `response.errors` field to see if there are any errors.
          For example,

          the response below means there are no errors (`status_code=200`):


          ```json

          {
            "message": "success",
            "data": {
              "task_id": "{task_id}"
            }
          }

          ```


          A common source of errors when uploading Product records is that the
          custom attributes' data

          types are not consistent with the data types of the existing records. In
          such cases,

          you can check the individual error message in the `data` array. For
          example, if there is an

          error regarding the second record you tried to insert, the response
          might look like:


          ```json

          {
            "errors": true, // there are errors. please check!
            "data": [
              "data.0.custom_attributes.designer is invalid. Its data type is not consistent with other records",
              "data.0.product_id is invalid. The attribute expected to be of type 'string', but 'array' is given.",
              "data.0.created_at is invalid. The attribute should match 'date-time' format."
            ]
          }

          ```


          ### Internationalization (I18N)

          Miso has the built-in support for majority of Western European
          languages, including `English`, `French`, `German`,

          `Spanish`, `Italian`, `Dutch`, `Russian`, and `Ukrainian`, as well as,
          major Asian languages, including `Mandarin`
           (both Simplified and Traditional), `Japanese`, and `Korean`.

          In Dojo, you can choose the *Primary Language* for your product catalog
          (default is English).

          However, you can also have more than one language in your product
          catalog that is

          beyond your primary languages using the `i18n_$LN` fields (replace `$LN`
          with the [two-letter language
          code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) of your
          choice),

          and let Miso apply the language-specific preprocessing for you, such as
          tokenization, stemming, elision

          removal, folding, decompounding, and traditional to simplified Chinese
          conversion.


          For example, you may have a product called "Arizona, Green Tea with
          Ginseng & Honey" in your catalog, and you also

          sell it in your Spanish, French, and Chinese sites, and want your
          customers to be able to search for this product

          in their native languages.


          In this case, your product records will like the following sample
          record, where English is the primary language of

          the record, and `i18n_es`, `i18n_fr`, `i18n_zh` fields contain product
          details in their corresponding languages.

          ```javascript

          {
              "product_id": "arizona-ginseng-honey",
              // the primary language is English
              "title": "Arizona, Green Tea with Ginseng & Honey",
              // ... other product details in English
              "i18n_es": {
                 "title": "AriZona, Té verde con ginseng y miel"
                  // ... other product details in Spanish
              },
              "i18n_fr": {
                 "title": "AriZona - Thé Vert Aromatisé au Miel"
                  // ... other product details in French
              },
              "i18n_zh": {
                 "title": "美國ARIZONA亞歷桑納 - 蜂蜜人蔘綠茶"
                  // ... other product details in Chinese
              }
           }
          ```

          In this way, your customer can find this product with any of the
          following search queries

          without additional configuration:

          * `arizona green tea`

          * `arizona te verde`

          * `arizona the vert`

          * `arizona 綠茶`


          The similar concept applies to Autocomplete as well. You can specify a
          `language` parameter

          in the requests to Autocomplete API, and the autocomplete results for
          the specific language

          will be returned.
        operationId: content_write_api_v1_products_post
        requestBody:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProductBulkIn'
          required: true
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/CreateResponse'
          '400':
            description: Bad Request
            content:
              application/json:
                example:
                  'message:': Request timeout.
          '401':
            description: Unauthorized
            content:
              application/json:
                example:
                  message: invalid api key.
          '403':
            description: Forbidden
            content:
              application/json:
                example:
                  message: >-
                    Request is denied due to bot blocking. Please only access this
                    API from a real browser or use Secret API Key instead.
          '422':
            description: Unprocessable Entity
            content:
              application/json:
                example:
                  errors: true
                  message: >-
                    None of the records are inserted, because at least one of them
                    contain schema errors. Please see `data` field for details.
                  data:
                    - >-
                      data.0.product_id is invalid. The attribute expected to be
                      of type 'string', but 'array' is given.
                    - >-
                      data.0.created_at is invalid. The attribute should match
                      'date-time' format.
          '500':
            description: Internal Server Error
            content:
              application/json:
                example:
                  message: Something went wrong. Please contact miso product team.
        security:
          - Secret API Key: []
    /v1/products/{product_id}:
      get:
        tags:
          - Product / Content APIs
        summary: Product / Content Read API
        description: >-
          This API endpoint retrieves the details of a specific product / content
          using its `product_id`.

          To fetch the product / content information, make a GET request to the
          following URL:


          **Notice**: Make sure the product_id is an urlencode string.


          ```

          GET /v1/products/{product_id}

          ```


          Replace `{product_id}` with the unique identifier of the product /
          content you wish to fetch.


          ## Response Format


          The API will return the product / content details in a JSON object if
          the given `product_id`

          is valid and exists in the system. The JSON object will include fields
          like `title`,

          `description`, `price`, `images`, and any internationalization fields
          (`i18n_$LN`).


          ### Example Response


          Here's an example of a successful API response for a product / content
          with the `product_id`

          "arizona-ginseng-honey":


          ```json

          {
            "product_id": "arizona-ginseng-honey",
            "title": "Arizona, Green Tea with Ginseng & Honey",
            "description": "A refreshing and delicious blend of green tea with ginseng and honey.",
            "price": 1.99,
            "i18n_es": {
              "title": "AriZona, Té verde con ginseng y miel"
              // ... other product details in Spanish
            },
            "i18n_fr": {
              "title": "AriZona - Thé Vert Aromatisé au Miel"
              // ... other product details in French
            },
            "i18n_zh": {
              "title": "美國ARIZONA亞歷桑納 - 蜂蜜人蔘綠茶"
              // ... other product details in Chinese
            }
          }

          ```


          If the provided `product_id` is invalid or does not exist in the system,
          the API will return

          an error response with a `status_code=404`.


          ### Example Error Response

          ```json

          {
            "message": "not found"
          }

          ```
        operationId: content_read_api_v1_products__product_id__get
        parameters:
          - required: true
            schema:
              title: Product Id
              maxLength: 512
              type: string
            name: product_id
            in: path
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/ProductReadOut'
          '401':
            description: Unauthorized
            content:
              application/json:
                example:
                  message: invalid api key.
          '404':
            description: Product not Found
            content:
              application/json:
                example:
                  message: not found
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
          '500':
            description: Internal Server Error
            content:
              application/json:
                example:
                  message: Something went wrong. Please contact miso product team.
        security:
          - Secret API Key: []
      delete:
        tags:
          - Product / Content APIs
        summary: Product / Content Delete API
        description: >-
          This API endpoint allows you to delete a specific product / content from
          the system using its

          `product_id`. To remove a product, make a DELETE request to:


          **Notice**: Make sure the product_id is an urlencode string.


          ```

          DELETE /v1/products/{product_id}

          ```


          Replace `{product_id}` with the unique identifier of the product /
          content you wish to delete.


          ## Response Format


          The API will return a JSON object indicating the success or failure of
          the deletion request.

          If the deletion is successful, the `status_code` will be `200`, and the
          `message` field will

          confirm the successful deletion.


          ### Example Successful Deletion Response


          ```json

          {
            "message": "deleted",
            "data":  [
              {
                "task_id": "{task_id}"
              }
            ]
          }

          ```


          To check the exact response body of this task_id, make a GET request to
          the following endpoint:


          ```

          GET /v1/products/_status/{task_id}

          ```


          Replace `{task_id}` with the task_id returned from the response.
        operationId: content_delete_api_v1_products__product_id__delete
        parameters:
          - required: true
            schema:
              title: Product Id
              maxLength: 512
              type: string
            name: product_id
            in: path
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/DeleteResponse'
          '400':
            description: Bad Request
            content:
              application/json:
                example:
                  'message:': Request timeout.
          '401':
            description: Unauthorized
            content:
              application/json:
                example:
                  message: invalid api key.
          '403':
            description: Forbidden
            content:
              application/json:
                example:
                  message: >-
                    Request is denied due to bot blocking. Please only access this
                    API from a real browser or use Secret API Key instead.
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
          '500':
            description: Internal Server Error
            content:
              application/json:
                example:
                  message: Something went wrong. Please contact miso product team.
        security:
          - Secret API Key: []
    /v1/products/_ids:
      get:
        tags:
          - Product / Content APIs
        summary: Product / Content ID List API
        description: >-
          This API endpoint allows you to fetch the unique identifiers
          (product_ids) of all products

          stored in the app. To get a list of product_ids, make a GET request to
          the following URL:


          ```

          GET /v1/products/_ids

          ```


          ## Response Format


          The API will return an array of product_ids in a JSON object. The
          `status_code` will be `200`

          if the request is successful. If any error occurs during the request,
          the `status_code` will

          not be `200` and the `message` field will indicate the error.


          ### Example Successful Response


          ```json

          {
            "message": "success",
            "data": {
              "ids": [
                "product_1",
                "product_2",
                "product_3",
                // ... more product_ids
              ]
            }
          }

          ```


          ### Example Error Response


          If the dataset cannot be found, the API will return a `404` error:


          ```json

          {
            "status_code": 404,
            "message": "not found"
          }

          ```


          If another error occurs during the request, the API will return a `500`
          error


          ```json

          {
            "message": "Something went wrong. Please contact miso product team."
          }

          ```
        operationId: content_read_ids_api_v1_products__ids_get
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/ProductListOut'
          '401':
            description: Unauthorized
            content:
              application/json:
                example:
                  message: invalid api key.
          '500':
            description: Internal Server Error
            content:
              application/json:
                example:
                  message: Something went wrong. Please contact miso product team.
        security:
          - Secret API Key: []
    /v1/products/_delete:
      post:
        tags:
          - Product / Content APIs
        summary: Product / Content Bulk Delete API
        description: >-
          This API endpoint allows you to delete multiple products by providing
          their product_ids.


          To delete multiple products, make a POST request to the following URL:


          ```

          POST /v1/products/_delete

          ```


          The request body should contain a JSON object with an array of
          product_ids:


          ```json

          {
            "data": {
              "product_ids": [
                "product-1",
                "product-2",
                // ... more product_ids to delete
              ]
            }
          }

          ```


          ## Response Format


          The API will return a JSON object with a `message` and an array of
          `data`

          containing a `task_id` that can be used to get the status of the bulk
          deletion process.


          #### Example Successful Response


          ```json

          {
            "message": "deleted",
            "data": {
              "task_id": "{task_id}"
            }
          }

          ```


          To check the exact response body of this task_id, make a GET request to
          the following endpoint:


          ```

          GET /v1/products/_status/{task_id}

          ```


          Replace `{task_id}` with the task_id returned from the response.
        operationId: content_bulk_delete_api_v1_products__delete_post
        requestBody:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProductBulkDeleteIn'
          required: true
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/DeleteResponse'
          '400':
            description: Bad Request
            content:
              application/json:
                example:
                  'message:': Request timeout.
          '401':
            description: Unauthorized
            content:
              application/json:
                example:
                  message: invalid api key.
          '403':
            description: Forbidden
            content:
              application/json:
                example:
                  message: >-
                    Request is denied due to bot blocking. Please only access this
                    API from a real browser or use Secret API Key instead.
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
          '500':
            description: Internal Server Error
            content:
              application/json:
                example:
                  message: Something went wrong. Please contact miso product team.
        security:
          - Secret API Key: []
    /v1/users:
      post:
        tags:
          - User APIs
        summary: User Upload API
        description: >-
          Bulk API to insert User records. This API endpoint accepts POST requests
          with JSON data

          containing a list of User records wrapped in a dictionary.


          ```

          POST /v1/users

          ```


          ```json

          {
            "data": [user_1, user_2, user_3]
          }

          ```


          If a record with the same `user_id` already exists in the dataset, the
          existing record will

          be replaced (no partial update is allowed at this time). We recommend
          limiting your calls to

          around 100 records at a time to avoid memory issues or timeout risks.


          ### Schema validation


          This API validates the inserted records against the API schema. Any
          schema error will cause

          the whole request to fail (`status_code=422`), and none of the records
          will be inserted. As

          long as the request passes the schema validation, the API will return
          `status_code=200`, but

          you should still check if there is any error occurring with individual
          records.


          ```json

          {
              "errors": true,
              "data": [
                  "data.0.user_id is invalid. The attribute was expected to be a `string`"
              ]
          }

          ```


          ## Response Format


          The API will return a JSON object with a `task_id` that can be used to
          retrieve.


          #### Example Successful Response


          ```json

          {
            "data": {
              "task_id": "{task_id}"
            }
          }

          ```


          To check the exact response body of this task_id, make a GET request to
          the following endpoint:


          ```

          GET /v1/users/_status/{task_id}

          ```


          Replace `{task_id}` with the task_id returned from the response.
        operationId: user_write_api_v1_users_post
        requestBody:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserBulkIn'
          required: true
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/CreateResponse'
          '400':
            description: Bad Request
            content:
              application/json:
                example:
                  'message:': Request timeout.
          '401':
            description: Unauthorized
            content:
              application/json:
                example:
                  message: invalid api key.
          '403':
            description: Forbidden
            content:
              application/json:
                example:
                  message: >-
                    Request is denied due to bot blocking. Please only access this
                    API from a real browser or use Secret API Key instead.
          '422':
            description: Unprocessable Entity
            content:
              application/json:
                example:
                  errors: true
                  message: >-
                    None of the records are inserted, because at least one of them
                    contain schema errors. Please see `data` field for details.
                  data:
                    - >-
                      data.0.user_id is invalid. The attribute expected to be of
                      type 'string', but 'array' is given.
                    - >-
                      data.0.created_at is invalid. The attribute should match
                      'date-time' format.
          '500':
            description: Internal Server Error
            content:
              application/json:
                example:
                  message: Something went wrong. Please contact miso product team.
        security:
          - Secret API Key: []
    /v1/users/{user_id}:
      get:
        tags:
          - User APIs
        summary: User Read API
        description: >-
          This API endpoint retrieves the details of a specific user using their
          `user_id`.

          To fetch the user information, make a GET request to the following URL:


          **Notice**: Make sure the user_id is an urlencode string.


          ```

          GET /v1/users/{user_id}

          ```


          Replace `{user_id}` with the unique identifier of the user you wish to
          fetch.


          ## Response Format


          The API will return the user details in a JSON object if the given
          `user_id` is valid and

          exists in the system. The JSON object will include fields like `name`,
          `age`, `city`, `gender`

          , and other user information.


          ### Example Response


          Here's an example of a successful API response for a user with the
          `user_id` "user123":


          ```json

          {
              "message": "success",
              "data": {
                  "user_id": "user123",
                  "name": "johndoe",
                  // ... other user details
              }
          }

          ```


          If the provided `user_id` is invalid or does not exist in the system,
          the API will return an

          error response with a `status_code=404`.


          ### Example Error Response


          ```json

          {
              "message": "not found"
          }

          ```
        operationId: user_read_api_v1_users__user_id__get
        parameters:
          - required: true
            schema:
              title: Userid
              maxLength: 512
              type: string
            name: userId
            in: query
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/UserReadOut'
          '401':
            description: Unauthorized
            content:
              application/json:
                example:
                  message: invalid api key.
          '403':
            description: Forbidden
            content:
              application/json:
                example:
                  message: >-
                    Request is denied due to bot blocking. Please only access this
                    API from a real browser or use Secret API Key instead.
          '404':
            description: User not Found
            content:
              application/json:
                example:
                  message: not found
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
          '500':
            description: Internal Server Error
            content:
              application/json:
                example:
                  message: Something went wrong. Please contact miso product team.
        security:
          - Secret API Key: []
      delete:
        tags:
          - User APIs
        summary: User Delete API
        description: >-
          This API endpoint allows you to delete a specific user from the system
          using their `user_id`.


          **Notice**: Make sure the user_id is an urlencode string.


          To remove a user, make a DELETE request to:


          ```

          DELETE /v1/users/{user_id}

          ```


          Replace `{user_id}` with the unique identifier of the user you wish to
          delete.


          ## Response Format


          The API will return a JSON object with a `task_id` that can be used to
          retrieve.


          #### Example Error Response


          ```json

          {
            "message": "deleted",
            "data": {
              "task_id": "{task_id}"
            }
          }

          ```


          To check the exact response body of this task_id, make a GET request to
          the following endpoint:


          ```

          GET /v1/users/_status/{task_id}

          ```


          Replace `{task_id}` with the task_id returned from the response.
        operationId: user_delete_api_v1_users__user_id__delete
        parameters:
          - required: true
            schema:
              title: User Id
              maxLength: 512
              type: string
            name: user_id
            in: path
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/DeleteResponse'
          '400':
            description: Bad Request
            content:
              application/json:
                example:
                  'message:': Request timeout.
          '401':
            description: Unauthorized
            content:
              application/json:
                example:
                  message: invalid api key.
          '403':
            description: Forbidden
            content:
              application/json:
                example:
                  message: >-
                    Request is denied due to bot blocking. Please only access this
                    API from a real browser or use Secret API Key instead.
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
          '500':
            description: Internal Server Error
            content:
              application/json:
                example:
                  message: Something went wrong. Please contact miso product team.
        security:
          - Secret API Key: []
    /v1/users/_delete:
      post:
        tags:
          - User APIs
        summary: User Bulk Delete API
        description: >-
          This API endpoint allows you to delete multiple users by providing their
          user_ids.


          To delete multiple users, make a POST request to the following URL:


          ```

          POST /v1/users/_delete

          ```


          The request body should contain a JSON object with an array of user_ids:


          ```json

          {
            "data": {
              "user_ids": [
                "product-1",
                "product-2",
                // ... more product_ids to delete
              ]
            }
          }

          ```


          ## Response Format


          The API will return a JSON object with a `message` and an array of
          `data`

          containing a `task_id` that can be used to get the status of the bulk
          deletion process.


          #### Example Successful Response


          ```json

          {
            "message": "deleted",
            "data": {
              "task_id": "{task_id}"
            }
          }

          ```


          To check the exact response body of this task_id, make a GET request to
          the following endpoint:


          ```

          GET /v1/users/_status/{task_id}

          ```


          Replace `{task_id}` with the task_id returned from the response.
        operationId: user_bulk_delete_api_v1_users__delete_post
        requestBody:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserBulkDeleteIn'
          required: true
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/DeleteResponse'
          '400':
            description: Bad Request
            content:
              application/json:
                example:
                  'message:': Request timeout.
          '401':
            description: Unauthorized
            content:
              application/json:
                example:
                  message: invalid api key.
          '403':
            description: Forbidden
            content:
              application/json:
                example:
                  message: >-
                    Request is denied due to bot blocking. Please only access this
                    API from a real browser or use Secret API Key instead.
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
          '500':
            description: Internal Server Error
            content:
              application/json:
                example:
                  message: Something went wrong. Please contact miso product team.
        security:
          - Secret API Key: []
    /v1/search/search:
      post:
        tags:
          - Search APIs
        summary: Search API
        description: >-
          The Search API provides personalized, typo-correcting, semantic search
          for your site.

          You send this API the search queries users entered, and the API returns
          the relevant search results tailored to your

          users' interests.


          ### Personalized search

          Personalized search is a key factor in driving search conversion on many
          major sites.

          It is particularly powerful for short search queries (<= 3 keywords),
          which account for [up to 80% of search traffic in the
          U.S.](https://www.statista.com/statistics/269740/number-of-search-terms-in-internet-research-in-the-us/),

          but are usually the hardest to get right with traditional search
          engines. This is because shorter search queries tend

          to match a larger number of results, but there

          is not enough information in the query strings alone to determine which
          results the users

          are actually looking for.


          For example, when users search for *jeans* on Levi's.com, it is

          impossible to know which *jeans* the user is looking for, among
          thousands of options.

          Even if the user adds: *jeans for men*, it is still unclear to a
          traditional search engine what style, material,

          or size the user wants.


          In the contrary, with Miso's personalized search, we not only analyze
          the search query itself, but also take into

          account the *context* in which the searches are made, including who are
          the users, where are they from, what are their

          past interactions on the site, what other searches the user made, etc.
          These signals together

          allow Miso to generate more than 15% to 20% higher search conversion
          rate than the traditional non-personalized search

          engines.


          ### Balancing relevancy and personalization

          Although personalization is a powerful technique, over-using it can be
          harmful to the user experiences. In the

          context of search optimization, the relevancy of the search results are
          still the most important criteria, and we

          don't want personalization to overwhelm the search relevancy.

          For example, when users search for a very specific term, or directly
          search for the product names,

          Miso's algorithm will respond with the most relevant search results
          first, and then only apply personalization to

          rerank more ambiguous search results.



          ### Basic usage

          For every search query, you let Miso know the user's `user_id` and the
          search keywords in the API request body,

          for example:

          ```

          POST /v1/search/search

          {
            "q": "jeans",
            "user_id": "user-123"
          }

          ```


          For site visitors who do not sign in, you can let Miso know the
          `anonymous_id` of this visitor:

          ```

          POST /v1/search/search

          {
            "q": "jeans",
            "anonymous_id": "visitor-123"
          }

          ```


          ### Search response

          With the query above, Miso responds with the search results like the
          following:

          ```javascript

          {
             "message":"success",
             "data":{
                "took":50,
                "total":30,
                "start":0,
                "miso_id":"f34b90de-086b-11eb-b498-1ee8abb1818b",
                "products":[
                   {
                      "product_id":"505-regular-fit-mens-jeans",
                      "title":"The 505 Regular Fit Men's Jeans",
                      "url":"https://levi.com/jeans/505-regular-fit-mens-jeans/",
                      "size":"29",
                      "material":"Cotton",
                      "color":"Rinse - Dark Wash",
                      "_search_score": 78.12,
                      "_personalization_score": 0.98
                   }
                ],
                "spellcheck":{
                   "spelling_errors":false
                }

             }
          }

          ```

          * **took**: the amount of time (in milliseconds) Miso took to answer the
          query

          * **total**: the total number of matched products. You can paginate
          through all the products by using the combination

          of *start* and *rows* parameters (see *Request Body Schema* below)

          * **miso_id**: a UUID of the search request. You should include
          **miso_id** in the Interaction records for every

          interactions that result from this search request, e.g. user
          click-through a product in the search results.

          Miso use miso_id to track the search performance and fine-tune the
          algorithm accordingly.

          * **products**: an array of [Product records](https://api.askmiso.com)
          that match the search

          query, ranked in the order of relevancy and

          probability that the user will be interested in this product. By
          default, only the `product_id` of the Product is

          returned. You can ask Miso to return additional fields by using the *fl*
          parameter (see *Request Body Schema* below)

          * **products[ ]._search_score**: the search relevancy score of the
          products based on keyword matching and Miso's

          semantic matching. This score is similar to traditional Lucene search
          score.

          * **products[ ]._personalization_score**: the score assigned by Miso's
          personalization algorithm based on users'

          profile and their interactions on the site. This score quantifies the
          probability of whether users will be

          interested in this product or not.

          * **spellcheck**: an dictionary contains spell checking information.


          ### Spellcheck and auto-correction

          According to a [Microsoft Research
          study](https://www.aclweb.org/anthology/W04-3238.pdf), roughly 10-15% of
          the

          queries sent to search engines contain errors. A misspelled search
          keyword often results in poor search

          quality, and users have been accustomed to Google's automatic spelling
          correction functionality and expect the same

          on your site.


          However, correcting spelling and typos at scale is a non-trivial machine
          learning problem.

          Miso's spellcheck is based on a sequence-to-sequence

          deep learning model, trained and updated regularly on a corpus of
          billion tokens. It detects hard-to-spot errors,

          auto-correct keywords according to its context, and recognize terms that
          are newer or lesser known.


          Spellcheck is always on for every search request so you don't need to
          turn it on.

          What you need to decide is whether to turn on *auto spelling
          correction*.

          For example, the following search request turns on the
          auto-spelling-correction, and Miso will automatically

          replace any misspelled queries with their correct spelling:

          ```

          POST /v1/search/search

          {
             "q":"whte denem jeans",
             "user_id":"user-123",
             "spellcheck":{
                "enable_auto_spelling_correction":true
             }
          }

          ```

          The API will respond:

          ```javascript

          {
             "message":"success",
             "data":{
                "took":50,
                "total":30,
                "start":0,
                "miso_id":"f34b90de-086b-11eb-b498-1ee8abb1818b",
                "spellcheck":{
                   "spelling_errors":true,
                   "auto_spelling_correction":true,
                   "original_query":"whte denem jeans",
                   "original_query_with_markups":"<mark>whte</mark> <mark>denem</mark> jeans",
                   "corrected_query":"white denim jeans",
                   "corrected_query_with_markups":"<mark>white</mark> <mark>denim</mark> jeans"
                },
                "products":[
                   ......
                ]
             }
          }

          ```

          The *spellcheck* object contains the following fields:

          * **spelling_errors** indicates whether there is a spelling error in the
          query

          * **auto_spelling_correction** indicates whether the search query has
          been replaced with the *corrected_query*

          * **original_query** the original search query

          * **original_query_with_markups** the original search query with the
          misspelled words highlighted by \<mark\> html tags

          * **corrected_query** the search query with misspelling and typos
          corrected

          * **corrected_query_with_markups** the search query with misspelling and
          typos corrected, and the corrected parts are highlighted by \<mark\>
          html tags


          You can opt-out the auto-spelling-correction by setting
          `enable_auto_spelling_correction=false`. For example:

          ```

          POST /v1/search/search

          {
             "q":"whte denem jeans",
             "user_id":"user-123",
             "spellcheck":{
                "enable_auto_spelling_correction":false
             }
          }

          ```

          In this case, Miso will still run spellcheck against the query. However,
          users' queries will be used as it is,

          and **auto_spelling_correction** field will be *false*.


          ### Boosting and Diversification

          While Miso's personalized search can drive conversion by showing search
          results that are tailored

          to users' interests, ultimately, it is important to make sure that the
          search results meet your business goals.

          To that end, Miso provides a great set of tools that enable you to
          fine-tune the search ranking and make it aligned
           with your goals.

          One great example is **boosting**. Boosting allows you to define a query
          that can be used to boost a

          subset of products to the top of the ranking, or to specific *boost
          positions*. You can use boosting to run

          different kinds of promotion campaigns, or to promote certain set of
          products for individual users that you know

          they will be interested in.


          For example, consider a scenario where you need to promote the sales of
          Nike's products. Then, you might want to

          use the query below, that will promote the sneakers whose brand are
          `Nike` to the top of the search result:

          ```

          POST /v1/search/search

          {
             "q":"sneaker",
             "user_id":"user-123",
             "boost_fq": "brand:\"Nike\""
          }

          ```


          For a slightly more complex example, the query below will promote the
          Nike products which have also been tagged

          as `ON SALE`:

          ```

          POST /v1/search/search

          {
             "q":"sneaker",
             "user_id":"user-123",
             "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\""
          }

          ```


          You can have as complex boosting logic as you want in the boosting
          query,

          but it is worth mentioning that Miso will only boost

          products that are relevant and have high likelihood to convert. In other
          words, Miso will not boost low

          performance products even if they match the boosting query.


          Depending on your boosting rules, in certain cases, you would like to
          prevent search results from becoming

          too "plain" due to boosting. For example, you don't want the first page
          of the search result to contain only Nike

          products.


          With Miso, you have two tools to avoid so. First, you can specify
          `boost_positions` to place boosted products at

          specific positions in the ranking. For example, the query below will
          place boosted products only at the first,

          fourth, seventh places in the ranking (positions are 0-based), and place
          the remaining products in their original

          ranking, skipping these three positions.


          ```

          POST /v1/search/search

          {
             "q":"sneaker",
             "user_id":"user-123",
             "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
             "boost_positions": [0, 3, 6]
          }

          ```


          The second tool is `diversification`. Miso's `diversification` algorithm
          will maintain a desired minimum distance

          between any two products that have the same attributes. For example, the

          following query will make sure products made by the same *brand* are at
          least two slots apart from each

          other in the search results.


          ```

          POST /v1/search/search

          {
             "q":"sneaker",
             "user_id":"user-123",
             "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
             "diversification": {
                 "brand": {"minimum_distance": 2}
              }
          }

          ```


          It is also very often to use both "boost_positions" and
          "diversification" at the same time to make sure that

          (1) the search results are not overwhelmed by the boosted products, and
          (2) there is a good mix of products from

          different brands showing side-by-side to increase product discovery
          rate.


          ### Result ordering


          You can override Miso's default ranking order by specifing a list of
          fields for Miso to rank the search results.

          These fields can be any numeric or boolean fields in your Product
          catalog, or one of the following special

          fields:

          * **_personalization_score**: the score that estimates the probability
          that a user will interact with a product

          determined by Miso's personalization algorithm. The range of this score
          is between [0, 1]. The scores are

          non-uniformly distributed. The Products that are relevant to users'
          interests will have scores much closer to 1,

          than products that are not.

          * **_search_score**: the score that rates the degree of "match" between
          search keywords and a product's catalog

          with a focus on Product's titles.

          This score is mostly based on a variant of
          [BM25](https://en.wikipedia.org/wiki/Okapi_BM25), but additionally

          consider the term proximity, typos, term semantic similarity.

          Its value is always larger than 0, but its range is unbounded.

          * **_boosting_score**: a binary score indicates whether a Product is
          boosted by your boosting query.

          * **_geo_distance**: distance between any point on map, `geo` must be
          specified when sorting with this field.


          For example, the following query returns all the Products (because
          `q=*`), ranked by the `_personalization_score`

          first, and then by the values in the `custom_attributes.promote_score`
          field in the Product catalog, then the

          distance between the product and New York city.

          ```

          {
            "q": "*",
            "order_by": [
                  {
                      "field": "_personalization_score",
                      "tie_breaker": {
                          "type": "relative_difference",
                          "threshold": "0.05"
                      },
                      "order": "desc"
                  },
                  {
                      "field": "custom_attributes.promote_score",
                      "order": "desc"
                  },
                  {
                      "field": "_geo_distance",
                      "geo": {
                          "lat": 40.711967,
                          "lon": -74.006076,
                      }
                      "order": "asc"
                  }
            ]
          }

          ```

          #### Mathematical Functions

          Miso supports mathematical functions that transform and combine
          different sorting criteria into one.

          For example, a powerful strategy to improve gross merchandise volume
          (GMV), but maintain user

          experience is

          to sort the products based on the multiplication of personalization
          scores and product prices. You can achieve this with

          the following `order_by` query:

          ```

          {
            "q": "*",
            "order_by": [
                  {
                      "field": "_personalization_score * pow(sale_price, 0.5)",
                      "order": "desc"
                  }

            ]
          }

          ```

          Function `pow(sale_price, 0.5)` takes the square root of the sale price
          and avoids very expensive products from

          overwhelming the ranking.


          Miso supports all the common mathematical operators including `+`, `-`,
          `*`, `/`, `%`, `^`, `**`, and more

          advanced functions including:
            * Power functions: `pow(X, y)`, `sqrt(X)`
            * Exponents and logarithms: `exp(X)`, `log(X)`, `log2(X)`, `log10(X)`
            * Element-wise maximum / minimum: `maximum(X, y)`, `minimum(X, y)`
            * Absolute function: `abs(X)`
            * Rounding functions: `round(X)`, `floor(X)`, `ceil(X)`
            * Trigonometric functions: `sin(X)`, `cos(X)`, `tan(X)`, `asin(X)`, `acos(X)`, `atan(X)`


          #### Soft Tie-Breaker

          For scores that have granular resolutions, for example
          `_personalization_score`,`_search_scores`, or

          Products' `sale_price`, we usually don't want to rank Products by their
          raw values. After all,

          a 0.001 difference in `_personalization_score` or $0.01 difference in
          sale price typically will not make a

          difference in users' preferences. In such cases, *soft* tie-breakers
          should be used to smooth out these minor

          differences in scores.


          For example, in the query above, we apply a soft tie-breaker to
          `_personalization_score` based on score values'

          relative difference. Specifically, we first sort the score's raw values
          in the descending order, then

          for two consecutive values, if their relative difference is no more than
          a pre-defined threshold

          (in this case `0.05` or `5%`), they are considered as a tie, and the
          next field

          (i.e. `custom_attributes.promote_score`)

          will be used to determine their ranking.


          It is also common to utilize tie-breakers to combine the effect of two
          types of scores. For example, in the

          following query, we set `threshold=0.2` or `20%` for
          `_personalization_score`, then only the

          Products that users are 20% more likely to interact with will be ranked
          higher, the remaining Products will be

          ranked by their sale prices. In this way, we combine the effect of
          personalization score and sale prices, where

          the Products are roughly ranked by personalization, but favor the
          pricier products when they have comparable

          personalization scores.

          ```

          {
            "q": "*",
            "order_by": [
                  {
                      "field": "_personalization_score",
                      "tie_breaker": {
                          "type": "relative_difference",
                          "threshold": "0.20"
                      },
                      "order": "desc"
                  },
                  {
                      "field": "sale_price",
                      "order": "desc"
                  }

            ]
          }

          ```


          Also note that, when search keywords are present, it is recommended to
          always include `_search_score`

          as the first field (plus a tie-breaker) to maintain the relevance of the
          search results. A tie-breaker is usually

          required as well to let the subsequent score have effect to the ranking.

          ```

          {
            "q": "toy story",
            "order_by": [
                {
                      "field": "_search_score",
                      "tie_breaker": {
                          "type": "relative_difference",
                          "threshold": "0.20"
                      },
                      "order": "desc"
                  },
                  {
                      "field": "_personalization_score",
                      "tie_breaker": {
                          "type": "relative_difference",
                          "threshold": "0.20"
                      },
                      "order": "desc"
                  },
                  {
                      "field": "sale_price",
                      "order": "desc"
                  }

            ]
          }

          ```
        operationId: search_v1_search_search_post
        requestBody:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SearchRequest'
          required: true
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/SearchResponse'
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
        security:
          - Secret API Key: []
    /v1/search/autocomplete:
      post:
        tags:
          - Search APIs
        summary: Autocomplete API
        description: >-
          The Autocompletion API provides real-time, personalized, typo resistant
          typeahead for your search bar.

          You send this API what users are currently typing, and the API returns
          the complete search query suggestions.


          ### Personalized typeahead

          Personalized typeahead is an extreme example of personalized search. The
          personalization starts immediately when

          users enter even just one character. The typeahead results are
          personalized so that the entries most likely to drive

          conversion for the current user are ranked at the top. Miso will predict
          what the user is looking for in real-time

          based on their interests and past behaviors.


          ### Basic usage

          The request schema of Autocompletion API is similar to that of Search
          API: you put the search query users typed so

          far, and the `user_id` or `anonymous_id` for Miso to identify the
          current user.

          For example, when a user types the first character `r`, you send Miso
          the following request:

          ```

          POST /v1/search/autocomplete

          {
             "q":"r",
             "user_id":"user-123"
          }

          ```


          The response will be like:

          ```javascript

          {
            "message": "success",
            "data": {
              "took": 50,
              "miso_id": "e93a6d02-0a7a-11eb-a896-d28586dc1386",
              "completions": {
                "title": [
                  {
                    "text": "Robin Hood: Prince of Thieves (1991)",
                    "text_with_markups": "R<mark>obin Hood: Prince of Thieves (1991)</mark>",
                    "product": {
                      "product_id": "tmdb-8367"
                    }
                  },
                  {
                    "text": "Reservoir Dogs (1992)",
                    "text_with_markups": "R<mark>eservoir Dogs (1992)</mark>",
                    "product": {
                      "product_id": "tmdb-500"
                    }
                  },
                  ...
                ]
              }
            }
          }

          ```

          * **took**: the amount of time (in milliseconds) Miso took to answer the
          query

          * **completions**: an dictionary of autocompletion candidates from
          different sources. By default, we only run

          autocompletion against the titles of products, but you can choose to get
          autocompletion candidates from other fields

          using the `completion_fields` parameters.

          * **completions.title[].text**: the text of completion candidates

          * **completions.title[].text_with_markups**: the completion candidates
          with the part of text that users

          haven't typed yet surrounded by \<mark\> HTML tags.

          * **completions.title[].product**: the product record whose title
          matches the autocompletion candidate. This object can be used to
          implement direct-to-product links: when they click on the link they will
          go

          directly to the product page instead of the search result page. By
          default, only the `product_id` field is returned,
           you use `fl` request parameter to get more fields returned in the product object.


          ### Typo resistance

          Miso's autocompletion algorithm accepts up to 4 typos in the query
          string. For example, users may try to find the
           movie `Robin Hood`, but make two typos in the query, which becomes `robonhood` instead (`robin`->`robon`, and a space is missing).

          ```

          POST /v1/search/autocomplete

          {
             "q":"robanhood",
             "user_id":"user-123"
          }

          ```


          Miso can still find the movie "*Robin Hood: Prince of Thieves*" as a
          autocompletion candidate.

          ```javascript

          {
            "message": "success",
            "data": {
              "took": 50,
              "miso_id": "e93a6d02-0a7a-11eb-a896-d28586dc1386",
              "completions": {
                "title": [
                  {
                    "text": "Robin Hood: Prince of Thieves (1991)",
                    "text_with_markups": "Rob<mark>in Hood: Prince of Thieves (1991)</mark>",
                    "product": {
                      "product_id": "tmdb-8367"
                    }
                  },
                  ...
                ]
              }
            }
          }

          ```


          ### Completion fields

          The auto-completions are made against your product attributes. By
          default, Miso finds completion candidates from the

          `title` field. The `completion_fields` parameter

          lets you specify the attributes you want to perform auto-completion for.

          For example, the following query will return auto-completion candidates
          from the `title` and a custom attribute

          field:`custom_attributes.director`.

          ```

          POST /v1/search/autocomplete

          {
            "q": "rob",
            "user_id": "user-123",
            "completion_fields": [
              "title",
              "custom_attributes.director"
            ]
          }

          ```

          The response will be like the following:

          ```javascript

          {
            "message": "success",
            "data": {
              "took": 52,
              "miso_id": "16d95080-0bb0-11eb-948d-66359cf29022",
              "completions": {
                "title": [
                  {
                    "text": "Robin Hood: Prince of Thieves (1991)",
                    "text_with_markups": "Rob<mark>in Hood: Prince of Thieves (1991)</mark>",
                    "product": {
                      "product_id": "tmdb-8367"
                    }
                  },
                  {
                    "text": "RoboCop (1987)",
                    "text_with_markups": "Rob<mark>oCop (1987)</mark>",
                    "product": {
                      "product_id": "tmdb-5548"
                    }
                  },
                  ...
                ],
                "custom_attributes.director": [
                  {
                    "text": "Robert Z. Leonard",
                    "text_with_markups": "<mark>Rob</mark>ert Z. Leonard",
                  },
                  ...
                ]
              }
            }
          }

          ```
        operationId: autocomplete_v1_search_autocomplete_post
        requestBody:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AutocompleteRequest'
          required: true
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/AutocompleteResponse'
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
        security:
          - Secret API Key: []
    /v1/search/mget:
      post:
        tags:
          - Search APIs
        summary: Multiple Get API
        description: >-
          The Multiple Get API provides a simple and fast interface to retrieve
          Products by their product ids.

          For example, the following query will retrieve products whose
          product_ids are `123ABC-S-Black` and `123ABC-S-Blue`

          ```

          {
              "product_ids": ["123ABC-S-Black", "123ABC-S-Blue"]
          }

          ```

          Miso will respond with the complete Products records in the same order
          as the given `product_ids`:

          ```

          {
            "message": "success",
            "data": {
              "products": [
                {
                  "_found": true,
                  "product_id": "123ABC-S-Black",
                  "title": "Product ABC in Black",
                  ...
                },
                {
                  "_found": true,
                  "product_id": "123ABC-S-Blue",
                  "title": "Product ABC in Blue",
                  ...
                }
              ]
            }
          }


          ```

          You can use the `_found` field to determine whether a product is found
          in the Miso database or not.

          When the given product_id is not found, the `_found` field in the
          corresponding Product record

          will become `false`.


          For example, the following query requests a `product_id` that does not
          exist in the Miso database:

          ```

          {
              "product_ids": ["Product_Not_Exists", "123ABC-S-Black"]
          }

          ```

          Miso will respond:

          ```

          {
            "message": "success",
            "data": {
              "products": [
                {
                  "_found": false,
                  "product_id": "Product_Not_Exists"
                },
                {
                  "_found": true,
                  "product_id": "123ABC-S-Black",
                  "title": "Product ABC in Black",
                  ...
                }
              ]
            }
          }

          ```

          Finally, like every Miso API, you can use `fl` to control what Product
          fields to return. By default, all the Product

          fields will be returned, but the following query will return only
          `title` field of the product (in addition

          to `product_id`)

          ```

          {
              "product_ids": ["123ABC-S-Black", "123ABC-S-Blue"],
              "fl": ["title"]
          }

          ```
        operationId: mget_v1_search_mget_post
        requestBody:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MultipleGetRequest'
          required: true
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/MultipleGetResponse'
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
        security:
          - Secret API Key: []
    /v1/ask/questions:
      post:
        tags:
          - Ask APIs
        summary: Create a new qestion
        description: |-
          This API is used to submit questions to Miso.

          After a question is submitted, a `question_id` is returned.
          Then you can use `question_id` to check the latest status of it's answer
          as it is being compiled.
              
        operationId: questions_v1_ask_questions_post
        requestBody:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/QuestionRequest'
          required: true
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/QuestionResponse'
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
        security:
          - Secret API Key: []
    /v1/ask/questions/{question_id}/answer:
      get:
        tags:
          - Ask APIs
        summary: Get latest answer of asked question
        description: >-
          This API is used to fetch the latest answer of previous submitted
          question from Miso


          A submitted question is put into a job with following stage:


          - Initialization

          - Parsing and fecthing related content

          - Relevance checking

          - Summarization


          This API will tell you at what stage current question is in.

          If answer is fetched and being summerized, it will also return the
          latest summarization result.


          Besides human readable answer, the products used to generate answer are
          also returned.
              
        operationId: questions_answer_v1_ask_questions__question_id__answer_get
        parameters:
          - required: true
            schema:
              title: Question Id
              type: string
              format: uuid
            name: question_id
            in: path
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/PollAnswerResponse'
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
        security:
          - Secret API Key: []
    /v1/recommendation/user_to_products:
      post:
        tags:
          - Recommendation APIs
        summary: User to Products API
        description: >-
          Returns the products that are most likely to drive conversion for the
          given user. Depending on the conversion

          metrics you choose when training your Miso Engines in Dojo, this API
          returns products that are most likely to

          optimize those metrics (such as `add_to_cart`, `checkout`, or `read`).


          This API considers both user's interests and the conversion probability.
          The user's interests are determined from

          their past interactions on the site and the context of their current
          browsing session, including recent trending

          products, time of the day, recent search behaviors, etc.


          ### Application scenarios

          The User to Products API is usually used in homepage recommendations,
          such as "*Inspired by your shopping trends*" on

          Amazon, or "*Recommended videos*" on Youtube. It can also be used to run
          an email marketing campaign such as a

          newsletter from Medium with recent articles you might like. These kind
          of recommendations are particularly powerful

          in driving product discovery.


          ### Basic usage

          For basic usage of this API, you just need to let Miso knows the id of
          the current user or visitor via `user_id`

          or `anonymous_id` field. For example, for a currently logged-in user,
          your request may look like the following:

          ```

          POST /v1/recommendation/user_to_products

          {"user_id": "user-123"}

          ```

          For a un-signed visitor, your request may look like the following:

          ```

          POST /v1/recommendation/user_to_products

          {"anonymous_id": "visitor-123"}

          ```


          This API will respond with the recommended products for the specified
          user or visitor:

          ```javascript

          {
            "message": "success",
            "data": {
              "took": 37,
              "miso_id": "517452b0-0ccf-11eb-948d-66359cf29022",
              "products": [
                {
                  "product_id": "tmdb-475557",
                  "_personalization_score": 0.91
                },
                {
                  "product_id": "tmdb-299534",
                  "_personalization_score": 0.89
                },
                ...
              ]
            }
          }

          ```

          * **took**: the amount of time (in milliseconds) Miso took to answer the
          query

          * **miso_id**: a UUID of the search request. You should include
          **miso_id** in the Interaction records for every

          interactions that result from this search request, e.g. user
          click-through a product in the search results.

          Miso use miso_id to track the search performance and fine-tune the
          algorithm accordingly.

          * **products**: an array of [Product records](https://api.askmiso.com)
          recommended to this

          user ranked by the probability that the user will be interested in this
          product. By default, only the `product_id`

          of the Product is returned. You can ask Miso to return additional fields
          by using the *fl* request argument (see example below)

          * **products[ ]._personalization_score**: the score assigned by Miso's
          personalization algorithm based on users'

          profile and their interactions on the site. This score quantifies the
          probability of whether users will be

          interested in this product or not.


          You can use the `fl` request argument to ask Miso to return more product
          fields. For example, the following request

          asks Miso to additionally return the *title* and *category* fields of
          every recommended product:

          ```

          POST /v1/recommendation/user_to_products

          {
              "user_id": "user-123",
              "fl": ["title", "categories"]
          }

          ```

          The response will be like:

          ```javascript

          {
            "message": "success",
            "data": {
              "took": 37,
              "miso_id": "517452b0-0ccf-11eb-948d-66359cf29022",
              "products": [
                {
                  "product_id": "tmdb-475557",
                  "categories": [
                    [
                      "Crime"
                    ],
                    [
                      "Thriller"
                    ],
                    [
                      "Drama"
                    ]
                  ],
                  "title": "Joker (2019)",
                  "_personalization_score": 0.91
                },
                {
                  "product_id": "tmdb-299534",
                  "categories": [
                    [
                      "Adventure"
                    ],
                    [
                      "Science Fiction"
                    ],
                    [
                      "Action"
                    ]
                  ],
                  "title": "Avengers: Endgame (2019)",
                  "_personalization_score": 0.89
                },
               ...
              ]
            }
          }

          ```

          ### Filtering and Boosting

          Like every other Miso API, `User To Products` API supports filter query
          (`fq`) and boost query (`boost_fq`) to

          generate recommendations that meet your business needs.


          #### Filter Query

          You can use filter query to filter recommendation results against

          arbitrary criteria, and Miso will *guarantee* to return sufficient
          number of recommendation results that meet the

          criteria. For example, the following requests will limit the
          recommendations to only `Drama` films:

          ```

          POST /v1/recommendation/user_to_products

          {
              "user_id": "user-123",
              "fl": ["title", "categories"],
              "fq": "categories:Drama"
          }

          ```


          For another example with `custom_attributes`, the following requests
          will limit the recommendations to
           only `Drama` films after `2010`:
          ```

          POST /v1/recommendation/user_to_products

          {
              "user_id": "user-123",
              "fl": ["title", "categories"],
              "fq": "categories:Drama AND custom_attributes.year:[2010 to *]"
          }

          ```


          #### Latency Consideration

          Miso achieves **instant** recommendations by pre-computing a large pool
          of candidates (N>1,000)

          for each user with the products they are mostly likely to be interested
          in. However, when the given filter query do

          not match a sufficient number of

          candidates, Miso will fall back to Search API to find additional matches
          to fill in the remaining

          slots. While falling back to Search API will increase the latency, the
          latency increase is usually minimum if the

          same filter query is being used repeatedly due to Miso's caching
          mechanism.



          #### Boost Query

          You can use `boost_fq` to boost Products with arbitrary criteria. The
          relevant Products that match the `boost_fq`

          will be ranked at the top of the recommendations or at the positions
          specified in the

          `boost_positions` parameter. Boosting is particularly useful for product
          promotions (e.g. sponsored products) to

          highlight the Products you want more impression.


          For example, the following request will boost the `Sci-Fi` films
          directed by `Ridley Scott`:

          ```

          POST /v1/recommendation/user_to_products

          {
              "user_id": "user-123",
              "fl": ["title", "categories"],
              "boost_fq": "categories:\"Sci-Fi\" AND custom_attributes.director:\"Ridley Scott\""
          }

          ```

          The response will be like:


          ```javascript

          {
            "message": "success",
            "data": {
              "took": 83,
              "miso_id": "54bf6d9a-dd32-11eb-99d6-a62d401473b5",
              "products": [
                {
                  "product_id": "tmdb-286217",
                  "title": "The Martian (2015)",
                  "_personalization_score": 0.5364759309088403,
                  "_boosted": true,
                  "categories": [
                    [
                      "Drama"
                    ],
                    [
                      "Adventure"
                    ],
                    [
                      "Science Fiction"
                    ]
                  ]
                },
                ...
              ]
            }
          }

          ```

          The additional field **products[ ].boosted** is a boolean that indicates
          whether the Product matches the `boost_fq`.


          You can also use `boost_positions` to specify the positions in the
          recommendation list you want the

          boosted Products to be placed. For example, the following request will
          place the boosted Product at the second place,

          and the third place (the `boost_positions` are 0-based):


          ```

          POST /v1/recommendation/user_to_products

          {
              "user_id": "user-123",
              "fl": ["title", "categories"],
              "boost_fq": "categories:\"Sci-Fi\" AND custom_attributes.director:\"Ridley Scott\"",
              "boost_positions": [1, 2]
          }

          ```


          ### Filtering "already seen" items

          Typically, the User to Products API is used to let users discover new
          products they might be interested in. Therefore,

          it is important not to recommend products users have already interacted
          with recently. By default, the User to Products

          API filters out the most recent 50 products users have had interactions
          with (except for `impression` interactions)
        operationId: user_to_products_v1_recommendation_user_to_products_post
        requestBody:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserToItemsRequest'
          required: true
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/RecResponse'
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
        security:
          - Secret API Key: []
    /v1/recommendation/user_to_categories:
      post:
        tags:
          - Recommendation APIs
        summary: User to Categories API
        description: >-
          The User to Categories API returns the product categories that will
          drive the conversion for the current user,

          along with the recommended products for each returned category.


          ### Application scenarios

          This API is usually used in homepage recommendations, or category
          recommendations

          where recommendations are organized by categories,

          such as Netflix's "*Action / Sci-Fi / Drama movies for you*"

          or Amazon's "*Recommendations for you in Grocery & Gourmet Food*". The
          goal of such recommendations is to help

          users discover attractive products under the categories they

          have a high chance to be interested in.


          ### Basic usage

          For basic usage of this API, you just need to let Miso knows the
          `user_id` or

          `anonymous_id` of the current users. Miso will return a list of top
          categories along with the recommended

          Products under each of the categories.

          ```

          POST https://api.askmiso.com/v1/recommendation/user_to_categories

          {
              "user_id": "user-123",
              "rows": 2,
              "products_per_category": 3,
              "fl": ["title"]
          }

          ```

          * **rows**: the number of categories to return

          * **products_per_category**: the number of Products to return per each
          category

          * **fl**: like in other Miso API, you can use `fl` to control which
          fields to return for each Product


          The response of this request will be like:

          ```

          {
            "message": "success",
            "data": {
              "took": 85,
              "miso_id": "7cd6059c-dd54-11eb-8050-a62d401473b5",
              "categories": [
                {
                  "category": [
                    "Drama"
                  ],
                  "total": 61510,
                  "recommended_products": [
                    {
                      "product_id": "tmdb-286217",
                      "title": "The Martian (2015)"
                    },
                    {
                      "product_id": "tmdb-281957",
                      "title": "The Revenant (2015)"
                    },
                    {
                      "product_id": "tmdb-68718",
                      "title": "Django Unchained (2012)"
                    }
                  ]
                },
                {
                  "category": [
                    "Thriller"
                  ],
                  "total": 21870,
                  "recommended_products": [
                    {
                      "product_id": "tmdb-11324",
                      "title": "Shutter Island (2010)"
                    },
                    {
                      "product_id": "tmdb-1949",
                      "title": "Zodiac (2007)"
                    },
                    {
                      "product_id": "tmdb-1422",
                      "title": "The Departed (2006)"
                    }
                  ]
                }
              ]
            }
          }

          ```

          * **categories**: a list of categories recommended to the users.

          * **categories[].category**: the recommended category in the format of
          category hierarchy. `["Sci-Fi"]` is a top level category,

          `["Sci-Fi", "Space Travel"]` is a second-level category under `Sci-Fi`
          (a.k.a subcategory).

          * **categories[].total**: the total number of Products belonging to the
          category

          * **categories[].recommended_products**: a list of Products (in that
          category) recommended to the users


          ### Root Category

          By default, `User To Categories` API recommends top level categories,
          but you can change this behavior

          via `root_category` parameter. Miso will recommend the immediate
          sub-categories of the given `root_category`

          For example, the following request will recommend sub-categories under

          `Science Fiction`, for example `["Science Fiction", "Space Travel"]` or
          `["Science Fiction", "Steampunk"]`:

          ```

          POST https://api.askmiso.com/v1/recommendation/user_to_categories

          {
              "user_id": "test",
              "root_category": ["Science Fiction"]
          }

          ```


          In some cases, you may want to get recommendations from *any*
          subcategories (regardless their parent category).

          In such case, you can use wildcard `*` to achieve such results. For
          example, the following request will recommend

          any sub-categories regardless their parent category:

          ```

          POST https://api.askmiso.com/v1/recommendation/user_to_categories

          {
              "user_id": "test",
              "root_category": ["*"]
          }

          ```

          ### Filter and boost query

          Like every Miso API, `User To Categories` supports `fq` for filtering,
          and `boost_fq` for boosting. You can use

          these parameters to make the recommendation results meet your exact
          business needs. For example, the following

          request will recommend categories

          that contain sufficient number of Products that meet the `fq` criteria
          (i.e. films after 2010), and each Product

          returned in the `recommended_products` list will also meet the `fq`
          criteria:

          ```

          POST https://api.askmiso.com/v1/recommendation/user_to_categories

          {
              "user_id": "user-123",
              "rows": 2,
              "products_per_category": 3,
              "fq": "custom_attributes.year: [2010 TO *]"
          }

          ```

          Similarly, you can use `boost_fq` to promote Products that meet your
          business criteria in each category. For example,

          the following request will prioritize Products that are promoted
          (indicated by `custom_attributes.promoted`):

          ```

          POST https://api.askmiso.com/v1/recommendation/user_to_categories

          {
              "user_id": "user-123",
              "rows": 2,
              "products_per_category": 3,
              "boost_fq": "custom_attributes.promoted: true"
          }

          ```

          ### Latency considerations

          `User To Categories` API is one of more complex API because it needs to
          first identify categories the user will be

          interested in, and then find the top Products in that categories. We
          make this process real-time by pre-computing a

          large number of top Products users may find interesting in for each
          category, therefore the end-to-end latency is

          usually under 100ms. To further reduce the latency, you can:

          * Use a smaller `products_per_category` to reduce number of products to
          return, or set it to zeros if you don't need any.

          * Request only the necessary fields using `fl` parameters

          * Use a smaller `rows` to reduce number of categories to return
        operationId: user_to_categories_v1_recommendation_user_to_categories_post
        requestBody:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserToCategories'
          required: true
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/CategoryRecResponse'
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
        security:
          - Secret API Key: []
    /v1/recommendation/user_to_attributes:
      post:
        tags:
          - Recommendation APIs
        summary: User to Attributes API
        description: >-
          The `User to Attributes` API is a generalized version of `User to
          Categories` API --- it returns the product

          attributes that Miso expects to drive a conversion for the current

          user. You specify a field in your Product catalog you want
          recommendations for, e.g. the `brand` or a custom field like

          `custom_attributes.director`, and this API will return a list of values
          from that fields Miso expects users will be most

          interested in, as well as a list of personalized product suggestions.


          ### Applicable scenarios

          This API is usually used in homepage recommendations, where users can
          interact with recommended attributes.

          For example, this API could generate suggestions for "the brands you may
          like" or "the creators you may like."


          ### Basic usage

          For basic usage of this API, you just need to let Miso knows the
          `user_id` or `anonymous_id`, and the `field` you

          want to get recommendations for. For example, the following request will
          return the recommended `director` for

          the given users:

          ```

          POST https://api.askmiso.com/v1/recommendation/user_to_attributes

          {
              "user_id": "test",
              "field": "custom_attributes.director",
              "rows": 3,
              "products_per_attribute": 2,
              "fl": ["title"]
          }

          ```

          * **field**: the name of the field you want to get recommendation for

          * **rows**: the number of categories to return

          * **products_per_attribute**: the number of Products to return per each
          attribute

          * **fl**: like in other Miso API, you can use `fl` to control which
          fields to return for each Product


          The response of this request will be like:

          ```javascript

          {
            "message": "success",
            "data": {
              "took": 296,
              "miso_id": "9d7c8d9c-dd73-11eb-b20d-9a566192e5c6",
              "attributes": [
                {
                  "value": "Christopher Nolan",
                  "total": 12,
                  "recommended_products": [
                    {
                      "product_id": "tmdb-272",
                      "title": "Batman Begins (2005)"
                    },
                    {
                      "product_id": "tmdb-77",
                      "title": "Memento (2000)"
                    }
                  ]
                },
                {
                  "value": "Ridley Scott",
                  "total": 26,
                  "recommended_products": [
                    {
                      "product_id": "tmdb-286217",
                      "title": "The Martian (2015)"
                    },
                    {
                      "product_id": "tmdb-4982",
                      "title": "American Gangster (2007)"
                    }
                  ]
                },
                {
                  "value": "Quentin Tarantino",
                  "total": 13,
                  "recommended_products": [
                    {
                      "product_id": "tmdb-680",
                      "title": "Pulp Fiction (1994)"
                    },
                    {
                      "product_id": "tmdb-68718",
                      "title": "Django Unchained (2012)"
                    }
                  ]
                }
              ]
            }
          }


          ```

          * **attributes**: a list of attributes recommended to the users.

          * **attributes[ ].value**: the recommended attribute value (in this
          case, director name)

          * **attributes[ ].total**: the total number of Products that have this
          attribute

          * **attributes[ ].recommended_products**: a list of Products (with the
          attribute) recommended to the users
        operationId: user_to_attributes_v1_recommendation_user_to_attributes_post
        requestBody:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserToAttributes'
          required: true
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/AttributeRecResponse'
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
        security:
          - Secret API Key: []
    /v1/recommendation/user_to_trending:
      post:
        tags:
          - Recommendation APIs
        summary: User to Trending API
        description: >-
          The User to Trending API returns the products that are currently
          trending

          and are most likely to be of interest to this user. It's different from
          the User to Products API because it will only

          recommend trending products. However, each user should still see unique
          recommendations that are not only trending but

          also suit their interests.


          ### Applicable scenarios

          This API is typically used to make homepage recommendations such as
          "Trending products for users like you" or

          "Trending on Youtube".


          ### Filtering "already seen" items

          The User to Trending API will not recommend products users have recently
          interacted with.
        operationId: trending_items_v1_recommendation_user_to_trending_post
        requestBody:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserToItemsRequest'
          required: true
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/TrendRecResponse'
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
        security:
          - Secret API Key: []
    /v1/recommendation/product_to_products:
      post:
        tags:
          - Recommendation APIs
        summary: Product to Products API
        description: >-
          The Product to Products API returns the products that are related to an
          anchor product (often the product the user

          is currently engaging with) and are also likely to drive conversions by
          connecting with the user’s interests. It is

          different from the User to Products API as it not only considers the
          user’s interests but also considers the

          recommended products' relevancy to the anchor product.


          ### Applicable scenarios

          This API is frequently used in product detail page to show related
          products that users can consume

          further, such as "Related products you may like" on Amazon or "Up next
          video" on Youtube. It is one of Miso's best

          performing APIs. Our customers usually see more than 30% and some times
          110% relative lift in click-through rate after

          deploying this a feature using this API.


          ### Basic usage

          To use this API, you just need to let Miso knows the `user_id` (or
          `anonymous_id`) and the `product_id` you

          want to get related recommendations for. For example, the following
          request will return the products that are

          related to the movie `Toy Story`.

          ```

          POST https://api.askmiso.com/v1/recommendation/product_to_products

          {
              "user_id": "user_123",
              "product_id": ["toy-story-1995"],
              "rows": 3,
              "fl": ["title"]
          }

          ```

          * **product_id**: the id of the anchor product

          * **rows**: the number of related products to return

          * **fl**: like in other Miso API, you can use `fl` to control which
          fields to return for each Product


          The response will be like:

          ```javascript

          {
              "message": "success",
              "data": {
                  "took": 56,
                  "miso_id": "f98b1904-ddce-11eb-be53-fa1729b23183",
                  "products": [
                      {
                          "product_id": "toy-story-2-1999",
                          "title": "Toy Story 2 (1999)"
                      },
                      {
                          "product_id": "toy-story-3-2010",
                          "title": "Toy Story 3 (2010)"
                      },
                      {
                          "product_id": "the-lion-king-1994",
                          "title": "The Lion King (1994)"
                      }
                  ]
              }
          }

          ```

          * **products**: a list of products related to the anchor product

          * **products[ ].product_id**: the id of the recommended product

          * **products[ ].title**: the title of the recommended product. You can
          use `fl` parameter to make Miso return more fields


          ### Boosting and filtering

          Like every Miso API, you can utilize `fq` and `boost_fq` to fine-tune
          the recommendations returned by Miso, and

          Miso will guarantee to return the required number of recommendations
          that meet the given criteria.


          For example, the following request still recommends movies related to
          "Toy Story" but limits the recommendations

          to only the movies released after year 2010.

          ```

          POST https://api.askmiso.com/v1/recommendation/product_to_products

          {
              "user_id": "user_123",
              "product_id": ["toy-story-1995"],
              "rows": 3,
              "fl": ["title"],
              "fq": "custom_attributes.year: [2010 TO *]"
          }

          ```


          For another example, the following request will *boost* the movies that
          are acted by `Tom Hanks`. The boosting is

          different from filtering as it only prioritizes those products that
          match the boosting criteria and are relevant to

          the anchor products, but it will not limit the results to only such
          products.

          ```

          POST https://api.askmiso.com/v1/recommendation/product_to_products

          {
              "user_id": "user_123",
              "product_id": ["toy-story-1995"],
              "rows": 3,
              "fl": ["title"],
              "boost_fq": "custom_attributes.actors:\"Tom Hanks\""
          }

          ```


          ### Multiple anchor products

          In the scenarios where you want to recommend products related to
          **multiple** anchor products, for example,

          for shopping cart cross-sell or up-sell, you can utilize `product_ids`

          parameter and have multiple product ids in it.


          For instance, the following request recommends products related to
          movies "Toy Story" and "Monsters, Inc."

          that will be of interest to the the current user.

          ```

          POST https://api.askmiso.com/v1/recommendation/product_to_products

          {
              "user_id": "user_123",
              "product_ids": ["toy-story-1995", "monsters-inc-2001"],
              "rows": 3,
              "fl": ["title"]
          }

          ```
        operationId: product_to_products_v1_recommendation_product_to_products_post
        requestBody:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/YMALRequest'
          required: true
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/ProductToProductsResponse'
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
        security:
          - Secret API Key: []
    /v1/qa/question_answering:
      post:
        tags:
          - Q&A APIs
        summary: Q&A API
        description: >-
          Question Answering API analyzes each Product's `html` field and extracts
          paragraphs that can answer users'

          questions.


          For example, Miso can take question likes `What is python?`, and extract
          an answer like

          `Python is an interpreted, object-oriented, high-level programming
          language.` from a product's `html` field.


          Each answer is assigned a `probability` score that determines how likely
          a paragraph can accurately answer the

          question. A probability at least 0.7 is recommended, but you usually
          will need to fine-tune

          this threshold to find the precision-and-recall sweet-spot for your
          application.


          ### Limitations

          Miso will only extract answers from the `html` field and from products
          that have `enable_question_answering` set to `true`. Also,

          since Q&A is a much more complex search problem, the response time of
          this API is usually between 1 to 2 seconds

          for a new question. For an old question this API has answered before,
          the response time will be less than 75ms.
        operationId: question_and_answer_v1_qa_question_answering_post
        requestBody:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/QuestionAnsweringRequest'
          required: true
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/QAResponse'
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
        security:
          - Secret API Key: []
    /v1/qa/questions:
      post:
        tags:
          - Q&A APIs
        summary: Upload Question Bank API
        description: >-
          Question Bank API lets you upload your *question bank* to Miso. A
          *question bank* is a list of questions that

          can be used for **Question Autocomplete** and **Similar Question
          Search**.


          This API follows a *replace-all* model, i.e. a successful upload request
          will replace all the existing questions

          in the question bank.


          For example, the following request will replace the existing question
          bank with the given three questions:

          ```

          POST /v1/qa/questions

          {"data": [
              {"question": "What is python?"},
              {"question": "What is list comprehension?"},
              {"question": "How to sort a list in Python?"}
          ]}

          ```



              
        operationId: post_questions_v1_qa_questions_post
        requestBody:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PostQuestionRequest'
          required: true
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/BaseResponse'
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
        security:
          - Secret API Key: []
    /v1/qa/question_autocomplete:
      post:
        tags:
          - Q&A APIs
        summary: Question Autocomplete API
        description: >-
          Question Autocomplete is an important feature for Q&A applications. It
          not only saves your users from typing

          the complete questions, but also showcases what questions your app is
          capable answering. This is important because

          Q&A is an advanced search feature that not every user is familar with.


          Miso generates autocomplete candidates from the question bank you
          uploaded (see [Question Bank Upload API](...)).

          Given a partial question string, Question Autocomplete API will suggest
          question candidates that match the query

          the user is typing.



          For example, let's first upload three questions to the question bank:

          ```

          POST /v1/qa/questions

          {"data": [
              {"question": "What is python?"},
              {"question": "What is pypy?"},
              {"question": "How to sort a list in Python?"}
          ]}

          ```


          Then, immediately after the above request finished, you can send the
          request below to get autocompletion

          candidates for any partial query string. For example, if the query
          string the user types so far is *"what is p"*:


          ```

          POST /v1/qa/question_autocomplete

          {
              "q": "what is p",
              "rows": 5
          }

          ```


          The API will respond the completion candidates like the following:

          ```

          {
              "data":
                  "completions": [
                      {"question": "What is python?"},
                      {"question": "What is pypy?"}
                  ]
              }
          }

          ```


          The API supports adaptive fuzzy matching such that even if there are
          typos in the query string, the API

          is still able to return the question candidates with the correct
          spellings. For example, if the query string is

          "*How to sorta*". The API is still able to match the completion
          candidate:

          "*How to sort a list in Python?*"


          The API is optimized for instant experience and has an average response
          time lower than 50ms.
        operationId: post_autocomplete_v1_qa_question_autocomplete_post
        requestBody:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/QuestionAutocompleteRequest'
          required: true
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/QAAutocompleteResponse'
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
        security:
          - Secret API Key: []
    /v1/bulk:
      post:
        tags:
          - Bulk API
        summary: Bulk Request API
        operationId: bulk_v1_bulk_post
        requestBody:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BulkRequest'
          required: true
        responses:
          '200':
            description: Successful Response
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/BulkResponse'
          '422':
            description: Validation Error
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/HTTPValidationError'
        security:
          - Secret API Key: []
  components:
    schemas:
      AddToCart:
        title: add_to_cart
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - add_to_cart
            type: string
            description: >

              Used when a user adds a product into their shopping cart. This is a
              strong

              positive signal of the user's interest in the product, and may
              eventually lead to a purchase.
          quantities:
            title: Quantities
            anyOf:
              - type: array
                items:
                  type: number
              - type: number
            description: >

              The quantities of products the user adds to their cart or checks out
              with. This field should be a list of positive values.

              Specifically, if `product_ids` is a list of N products, the
              `quantities` needs to be a list with N numbers as well.

              If `quantities` are not specified, we will assume the quantity to be
              1 for every product.


              Example:

              ```

              {"quantities": [1, 2]}

              ```
            example:
              - 1
              - 2
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      AddToCollection:
        title: add_to_collection
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - add_to_collection
            type: string
            description: >

              Used when a user adds a product to their personal collection. This
              is a strong

              signal of their interest in the product.
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      AnchoringEntry:
        title: AnchoringEntry
        required:
          - product_id
          - anchor_ids
        type: object
        properties:
          product_id:
            title: Product Id
            type: string
            description: Product to boost
          anchor_ids:
            title: Anchor Ids
            minLength: 1
            type: array
            items:
              type: string
              minLength: 1
            description: A list of anchor products
          relative_position:
            title: Relative Position
            type: integer
            description: Relative position to the top anchor product
            default: -1
          start_time:
            title: Start Time
            type: string
            description: When does the anchoring start. Leave it unset to start immediately
            format: date-time
          end_time:
            title: End Time
            type: string
            description: When will the anchoring end. Leave it unset to not have an end time
            format: date-time
      Answer:
        title: Answer
        required:
          - probability
          - text
          - css_selector
        type: object
        properties:
          probability:
            title: Probability
            maximum: 1
            minimum: 0
            type: number
            description: >-
              The probability this paragraph can sufficiently answer the user's
              question (from 0.0 to 1.0).
          html:
            title: Html
            type: string
            description: >-
              The answer paragraph in its original html tag, i.e. or the
              `outerHTML` of the
                                    answer paragraph node.
                                    
          text:
            title: Text
            type: string
            description: The plain text version of answer paragraph.
          css_selector:
            title: Css Selector
            type: string
            description: >

              The CSS selector that uniquely identifies the answer paragraph node
              in the original HTML content. This css selector

              matches exactly one HTML node that contains the answer paragraph. In
              order to be as unambiguous as possible,

              the returned CSS selector is in the form of a series of nth-child
              selectors starting from `:root` node

              (which is usually the `<html>`). For example,

              ```

              :root > div:nth-child(1) > p:nth-child(2)

              ```

              . This selector means the answer paragraph is a `<p>` tag that is
              the second child of a `<div>` node, which is in turn, the

              first child of the `:root` node.


              This CSS selector is useful when you want to make the answer
              paragraph stand out from the

              rest of the document. For example,

              the following JQuery code turns the background color of the answer
              paragraph to yellow:


              ```

              $(answer.css_selector).css("background-color", "yellow");

              ```
      AnswerBlock:
        title: AnswerBlock
        required:
          - html
          - css_selector
          - relevant_children_slice
          - answer_css_selector
          - title
        type: object
        properties:
          html:
            title: Html
            type: string
            description: The HTML content of the answer block
          css_selector:
            title: Css Selector
            type: string
            description: >-
              The CSS selector that uniquely identifies the answer block from the
              HTML root
          relevant_children_slice:
            title: Relevant Children Slice
            type: array
            items:
              - type: integer
              - type: integer
            description: >-
              The range of children nodes inside the *answer block* that is
              relevant to the selected answer.
          answer_css_selector:
            title: Answer Css Selector
            type: string
            description: |2-

                      The CSS selector to the selected answer paragraph inside the answer block. You can use this selector to select
                      the answer from the answer block (as supposed to selecting from the HTML root)
                      
          title:
            title: Title
            type: string
            description: >-
              The relevant title to the answer paragraph. This title is extracted
              from a header node close
                      to the answer paragraph. If there is no such node, the title will be an empty string
      AnswerData:
        title: AnswerData
        required:
          - question
          - question_id
        type: object
        properties:
          question:
            title: Question
            type: string
            description: The question given by the user
          question_id:
            title: Question Id
            type: string
            description: The UUID of the question for which the latest answer is requested.
            format: uuid
          parent_question_id:
            title: Parent Question Id
            type: string
            description: >-
              The UUID of the parent question if the current question is a
              follow-up to a previous question.
            format: uuid
          answer_stage:
            title: Answer Stage
            type: string
            description: The status of the answer generating process.
            default: ''
          finished:
            title: Finished
            type: boolean
            description: Whether the answer generating process is finished.
            default: false
          answer:
            title: Answer
            type: string
            description: The latest answer for the given question.
            default: ''
          sources:
            title: Sources
            type: array
            items:
              type: object
            description: A list of sources related to the answer.
            default: []
          related_resources:
            title: Related Resources
            type: array
            items:
              type: object
            description: A list of related resources relevant to the question and answer.
            default: []
          followup_questions:
            title: Followup Questions
            type: array
            items:
              type: string
            description: A list of suggested follow-up questions.
          affiliation_products:
            title: Affiliation Products
            type: array
            items:
              type: object
            description: A list of suggested affiliation products.
      AttributeRecRecord:
        title: AttributeRecRecord
        required:
          - value
          - total
          - recommended_products
        type: object
        properties:
          value:
            title: Value
            type: string
            description: The attribute we recommend to the user in their textual form.
            example: Miso T-Shirt Shop
          total:
            title: Total
            type: integer
            description: The total number of products that have this attribute.
            example: 1000
          recommended_products:
            title: Recommended Products
            type: array
            items:
              $ref: '#/components/schemas/Record'
            description: Top personalized recommendations of products have this attribute.
            example: 1000
      AttributeRecResponse:
        title: AttributeRecResponse
        required:
          - data
        type: object
        properties:
          message:
            title: Message
            type: string
            default: success
          data:
            $ref: '#/components/schemas/AttributeResponseBody'
      AttributeResponseBody:
        title: AttributeResponseBody
        required:
          - attributes
        type: object
        properties:
          took:
            title: Took
            type: integer
            description: Number of milliseconds Miso took to retrieve the results.
            default: 0
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            default: 00000000-0000-0000-0000-000000000000
            example: 123e4567-e89b-12d3-a456-426614174000
          attributes:
            title: Attributes
            type: array
            items:
              $ref: '#/components/schemas/AttributeRecRecord'
            description: The attribute recommendation results.
      AutocompleteRequest:
        title: AutocompleteRequest
        required:
          - q
        type: object
        properties:
          engine_id:
            title: Engine Id
            type: string
            description: >

              The engine you want to get results from. When you have more than one
              engine, you can use this parameter to

              specify the specific engine you want to get results from. If not
              specified, the default engine will be used.
          user_id:
            title: User Id
            type: string
            description: >

              The user who made the query and for whom Miso will personalize the
              results. For an anonymous visitor, use `anonymous_id` instead.
          anonymous_id:
            title: Anonymous Id
            type: string
            description: >-
              The anonymous visitor who made the query and for whom Miso will
              personalize the results. Either
                      `user_id` or `anonymous_id` needs to be specified for personalization to work. 
          user_hash:
            title: User Hash
            type: string
            description: >

              The hash of `user_id` (or `anonymous_id`) encrypted by your [Secret
              API Key](https://api.askmiso.com).

              `user_hash` is required to prevent unauthorized API access if you
              are

              making API calls with a [Publishable API
              Key](https://api.askmiso.com).


              You should generate the user_hash via HMAC scheme: you encrypt the
              desired user_id (or anonymous_id) with your

              [Secret API Key](https://api.askmiso.com) on your backend server,

              and then let the front-end code send the generated user_hash to Miso
              APIs to

              verify the identity of the API caller.


              As long as the [Secret API Key](https://api.askmiso.com)
               is kept secret, the user_hash prevents a malicious attacker from making unauthorized
              API calls or impersonating any of your users.


              Miso APIs accept the case-incentive "hex digest" of user hash, a
              sample Python 3 code to generate it on your backend server

              is as follow:


              ```python

              import hashlib

              import hmac


              YOUR_MISO_SECRET_API_KEY = "039c501ac8dfcac91"

              key_bytes = YOUR_MISO_SECRET_API_KEY.encode()

              user_id = "USER_123" # or anonymous_id

              user_id_bytes = user_id.encode()

              user_hash = hmac.new(
                  key_bytes,
                  user_id_bytes,
                  hashlib.sha256).hexdigest()
              # user_hash is "7eb04da5e..."

              ```


              You can find more examples for other languages in this [Github
              Gist](https://gist.github.com/thewheat/7342c76ade46e7322c3e)
          user_cohort:
            title: User Cohort
            type: object
            additionalProperties:
              anyOf:
                - type: boolean
                - type: string
            description: >

              The user cohort you want to cold-start the recommendation with. For
              example, the following query will make

              recommendations based on the preferences of the users whose
              `country="United States"`, and `gender="Female"`

              in the User Profile dataset.

              ```

              {
                  "user_cohort": {
                      "country": "United States",
                      "gender": "Female"
                  }
              }

              ```
          rows:
            title: Rows
            type: integer
            description: Number of search results to return.
            default: 5
          type:
            title: Type
            type: string
            description: >

              The type of products to return. Use this parameter to make the API
              return only

              a certain type of products (see [Product
              APIs](https://api.askmiso.com)).


              This is particularly useful for sites that have multiple types of
              products:

              For example, on a marketplace site, YOu may model *merchandise* and
              *store* as two types of *products*. You can

              then use type parameter to limit the recommendation or search
              results to return only one kind of them.


              For instance, the following query will return only *store* products:
               ```
              {"type": "store"}
               ```

              For another example, on a travel website, you might have: *hotel*,
              *thing to do*, and *restaurant*,

              three kinds

              of products. You can use `type` parameter to limit results to one
              kind of them. For instance, the following

              query will limit the results to only *hotels* product:
               ```
              {"type": "hotel"}
               ```
          dedupe_product_group_id:
            title: Dedupe Product Group Id
            type: boolean
            description: >

              Whether to dedupe product based on `product_group_id`. If
              `dedupe_product_group_id=true`,

              Miso will prevent products with the same `product_group_id` from
              showing multiple

              times in the search or recommendation results.



              This is particular useful when one product has multiple variants
              (for example, different

              sizes, colors, or materials), and you only want to show this product
              only once in the search or recommendation

              results. Miso will then return the variant that is most likely to be
              of the user's interest.
            default: true
          additional_interactions:
            title: Additional Interactions
            type: array
            items:
              anyOf:
                - $ref: '#/components/schemas/ProductDetailPageView'
                - $ref: '#/components/schemas/Search'
                - $ref: '#/components/schemas/AddToCart'
                - $ref: '#/components/schemas/RemoveFromCart'
                - $ref: '#/components/schemas/Checkout'
                - $ref: '#/components/schemas/Refund'
                - $ref: '#/components/schemas/Subscribe'
                - $ref: '#/components/schemas/AddToCollection'
                - $ref: '#/components/schemas/RemoveFromCollection'
                - $ref: '#/components/schemas/Read'
                - $ref: '#/components/schemas/Watch'
                - $ref: '#/components/schemas/Listen'
                - $ref: '#/components/schemas/Like'
                - $ref: '#/components/schemas/Dislike'
                - $ref: '#/components/schemas/Share'
                - $ref: '#/components/schemas/Rate'
                - $ref: '#/components/schemas/Bookmark'
                - $ref: '#/components/schemas/Complete'
                - $ref: '#/components/schemas/Feedback'
                - $ref: '#/components/schemas/Impression'
                - $ref: '#/components/schemas/ViewableImpression'
                - $ref: '#/components/schemas/Click'
                - $ref: '#/components/schemas/HomePageView'
                - $ref: '#/components/schemas/CategoryPageView'
                - $ref: '#/components/schemas/PromoPageView'
                - $ref: '#/components/schemas/ProductImageView'
                - $ref: '#/components/schemas/Custom'
            description: >

              A list of additional interaction records. You can use this fields to
              simulate user interactions without

              actually writing them to the interaction dataset.
            default: []
          fq:
            title: Fq
            type: string
            description: >


              Defines a query in Solr syntax that can be used to restrict the
              superset of

              products to return, without influencing the overall ranking. `fq`
              can enable users to drill down to products

              with specific features based on different product attributes


              For example, the query below limits the search results to only show
              products whose size is either `M` or `S` and

              brand is `Nike`:


              ```

              {"fq": "size:(\"M\" OR \"S\") AND brand:\"Nike\""}

              ```


              You can use `fq` to apply filters against your custom attributes as
              well. For example, the query below limits the

              search results to only products whose `designer` attribute is
              `Calvin Klein`


              ```

              {"fq": "attributes.designer:\"Calvin Klein\""}

              ```


              `fq` can also limit search results by numerical range. For example,
              the following query limits the results to

              products that have `rating >= 4`.


              ```

              {"fq": "rating:[4 TO *]"}

              ```
          boost_fq:
            title: Boost Fq
            type: string
            description: >

              Defines a query in Solr syntax that can be used to boost a subset of
              products to the top of the ranking, or to

              specific *boost positions* (See `boost_positions` parameter below.)

              For example, the query below will promote all the relevant products
              whose brand is `Nike` to the top of

              recommendation list:


              ```

              {
                  "boost_fq": "brand:\"Nike\""
              }

              ```


              For a slightly more complex example, the query below will promote
              the Nike products which have also been tagged

              as `ON SALE` to the top of the ranking:

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\""
              }

              ```

              It is worth mentioning that, Miso will only boost products that are
              relevant and have high likelihood to convert,

              and will not boost a low performance product only because it matches
              the boosting query.


              Depending on your boosting rules, in certain cases, you would like
              to prevent recommendation results from being

              too monotone due to boosting. With Miso, you have two tools to do
              so.


              First, you can specify `boost_positions` to place promoted products
              at specific positions in the ranking. For

              example, the query below will place boosted products only at the
              first and fourth places in the ranking

              (positions are 0-based), and place the remaining products in their
              original ranking, skipping these two positions.

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
                 "boost_positions": [0, 3]
              }

              ```


              The second tool is `diversification`. `diversification` parameter,
              on a best-effort basis, will try to

              maintain a minimum distance between products that have the same
              attributes. For example, the following query

              will place products made by the same brand apart from each other.

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
                 "diversification": {
                     "brand": {"minimum_distance": 1}
                  }
              }

              ```
          boost_positions:
            title: Boost Positions
            type: array
            items:
              type: integer
            description: >

              Defines a list of 0-based positions you want to place the boosted
              products at.


              For example, the query below will promote products whose brand is
              `Nike` as the top and second recommendations:

              ```

              {
                  "boost_fq": "brand:\"Nike\"",
                  "boost_positions": [0, 1]
              }

              ```

              If `boost_positions` is not specified (which is the default
              behavior), all the boosted products will be ranked

              higher than the rest of the products.
          boost_rules:
            title: Boost Rules
            type: array
            items:
              $ref: '#/components/schemas/BoostingFilterBase'
            description: >

              Define a list of boosting rules that will be applied to the search
              or recommendation results simultaneously. `boost_rules`

              parameter is particularly useful when you want to boost more than
              one sets of products, and promote each of them to different

              positions. For example, the query below will promote products whose
              brand is `Nike` to the top

              and second results, and products whose brand is `Adidas` to the
              third and fourth results:

              ```

              {
                  "boost_rules": [
                      {
                          "boost_fq": "brand:\"Nike\"",
                          "boost_positions": [0, 1]
                      },
                      {
                          "boost_fq": "brand:\"Adidas\"",
                          "boost_positions": [2, 3]
                      }
                  ]
              }

              ```
            default: []
          geo:
            title: Geo
            allOf:
              - $ref: '#/components/schemas/GeoQuery'
            description: >

              When set, filter result to include only products within certain
              geographic range from given point will be returned,

              or to boost product within the same range.


              Product should have a field that holds the location of the product,
              `location` is used by default,

              but other field can also be used.


              Distance can be in miles or kilometers. If `distance_unit` is not
              set, `mile` will be used.


              For example, to limit results to products within 100 miles of New
              York city:

              ```

              {
                  "geo": {
                      "filter": [{
                          "lat": 40.73061,
                          "lon": -73.93524,
                          "distance": 100
                      }]
                  }
              }

              ```


              To boost products within 2 kilometers around Alcatraz Island
              according to `loc` field:

              ```

              {
                  "geo": {
                      "boost": [{
                          "field": "loc",
                          "lat": 37.82667,
                          "lon": -122.42278,
                          "distance": 2,
                          "distance_unit": "km"
                      }]
                  }
              }

              ```
          q:
            title: Q
            minLength: 0
            type: string
            description: >

              The search query users typed so far. Please keep the trailing spaces
              (if any) intact so that we

              know whether the user has finished typing the last word or is still
              typing it. For example, the following query

              means the user has finished typing the word *Fight*:

              ```

              {"q": "Fight "}

              ```

              On the other hand, the following query means the user has not
              finished typing the last word *Clu*:

              ```

              {"q": "Fight Clu"}

              ```
          language:
            title: Language
            type: string
            description: >

              Two-letter (639-1) language code of the search query. If given, the
              autocomplete results will be from

              that specific language. If not given, the autocomplete results will
              be from the primary language

              of the environment. Example query:

              ```

              {"language": "en"}

              ```
          min_query_users:
            title: Min Query Users
            type: integer
            description: >

              Limits the query completion results to *historical queries* that
              have been made by at

              least this number of unique users. This parameter has no effect when
              `completion_fields` does not include

              `historical_queries`. We do not recommend setting `min_query_users`
              lower than 5. When

              `min_query_users` is too small, we might risk showing queries that
              contain typos or are too personal to the

              users who made the query.
            default: 5
          completion_fields:
            title: Completion Fields
            type: array
            items:
              type: string
            description: >+


              Controls the sources of autocompletion candidates. Miso performs
              autocompletion by matching

              what the user has typed so far to either the *title* of products or
              to other *attributes*.


              By default, we only autocomplete against the value in the `title`
              field. The `completion_fields` parameter lets you

              specify the attributes you want to perform autocompletion against.
              For example, the following

              query will limit the autocompletion candidates to the `title` and
              `tags` of products:


              ```

              {"completion_fields": ["title", "tags"]}

              ```


              Autocompletion also works on *custom attributes*. For example, if
              you have a custom attribute for the

              `designer_name` of the product, the following query limits
              autocompletion candidates to only the designer names:


              ```

              {"candidates": ["custom_attributes.designer_name"]}

              ```

            default:
              - title
          fl:
            title: Fl
            type: array
            items:
              type: string
            description: >

              List of fields to retrieve. For example, the following request
              retrieves only the `title` field of each product along

              with the `product_id`, which is always returned.


              ```

              {"fl": ["title"]}

              ```


              You can also match field names by using `*` as a wildcard. For
              example, the query below retrieves the `title`

              and any custom attributes under the `attributes` dictionary.


              ```

              {"fl": ["title", "attributes.*"]}

              ```


              The following retrieves all the available fields:


              ```

              {"fl": ["*"]}

              ```


              For the lowest latency, use an empty array to retrieve just the
              `product_id` field (which is the default).

              ```

              {"fl": []}

              ```
            default: []
        additionalProperties: false
      AutocompleteResponse:
        title: AutocompleteResponse
        required:
          - data
        type: object
        properties:
          message:
            title: Message
            type: string
            default: success
          data:
            $ref: '#/components/schemas/AutocompleteResponseBody'
      AutocompleteResponseBody:
        title: AutocompleteResponseBody
        required:
          - completions
        type: object
        properties:
          took:
            title: Took
            type: integer
            description: Number of milliseconds Miso took to retrieve the results.
            default: 0
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            default: 00000000-0000-0000-0000-000000000000
            example: 123e4567-e89b-12d3-a456-426614174000
          completions:
            title: Completions
            type: object
            additionalProperties:
              type: array
              items:
                anyOf:
                  - $ref: '#/components/schemas/TitleCompletion'
                  - $ref: '#/components/schemas/Completion'
            description: Autocompletion results.
            example:
              title:
                - text: Miso Japanese Shiba Inu Dog Eating Miso Soup T-Shirt
                  type: title
                  product:
                    product_id: 123ABC-S-Black
              brand:
                - text: Miso
                  type: brand
                - text: Mitsui
                  type: brand
        description: |-
          autocomplete api response body:
          {
           "completions": [{"text": "", "source": ""}]
          }
      BaseBody:
        title: BaseBody
        type: object
        properties:
          took:
            title: Took
            type: integer
            description: Number of milliseconds Miso took to retrieve the results.
            default: 0
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            default: 00000000-0000-0000-0000-000000000000
            example: 123e4567-e89b-12d3-a456-426614174000
      BaseGeo:
        title: BaseGeo
        required:
          - lat
          - lon
        type: object
        properties:
          lat:
            title: Lat
            maximum: 90
            minimum: -90
            type: number
            description: Latitude of the center point, should between 90 and -90
          lon:
            title: Lon
            maximum: 180
            minimum: -180
            type: number
            description: Longitude of the center point, should between 180 and -180
      BaseResponse:
        title: BaseResponse
        required:
          - data
        type: object
        properties:
          message:
            title: Message
            type: string
            default: success
          data:
            $ref: '#/components/schemas/BaseBody'
      BaseResponseBody:
        title: BaseResponseBody
        required:
          - products
        type: object
        properties:
          took:
            title: Took
            type: integer
            description: Number of milliseconds Miso took to retrieve the results.
            default: 0
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            default: 00000000-0000-0000-0000-000000000000
            example: 123e4567-e89b-12d3-a456-426614174000
          products:
            title: Products
            type: array
            items:
              $ref: '#/components/schemas/Record'
            description: The recommendation results.
      Bookmark:
        title: bookmark
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - bookmark
            type: string
            description: |

              Used when a user bookmarks a product.
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      BoostItem:
        title: BoostItem
        required:
          - field
          - option
          - query
        type: object
        properties:
          field:
            title: Field
            type: string
            description: The boosting field of the rule.
          option:
            title: Option
            enum:
              - contains
              - not_contain
              - is
              - is_not
            type: string
            description: The boosting option of the field.
          query:
            title: Query
            type: string
            description: The boosting query of the field.
          action:
            title: Action
            enum:
              - pin
              - bury
              - remove
            type: string
            description: The boosting action of the field.
          pin_position:
            title: Pin Position
            minimum: 1
            exclusiveMinimum: 0
            type: integer
            description: >-
              This field is a 1-based integer to describe the position. This field
              is only used when action is "pin".
            example: 1
        example:
          field: title
          option: contains
          query: iphone
      BoostingFilterBase:
        title: BoostingFilterBase
        type: object
        properties:
          boost_fq:
            title: Boost Fq
            type: string
            description: >

              Defines a query in Solr syntax that can be used to boost a subset of
              products to the top of the ranking, or to

              specific *boost positions* (See `boost_positions` parameter below.)

              For example, the query below will promote all the relevant products
              whose brand is `Nike` to the top of

              recommendation list:


              ```

              {
                  "boost_fq": "brand:\"Nike\""
              }

              ```


              For a slightly more complex example, the query below will promote
              the Nike products which have also been tagged

              as `ON SALE` to the top of the ranking:

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\""
              }

              ```

              It is worth mentioning that, Miso will only boost products that are
              relevant and have high likelihood to convert,

              and will not boost a low performance product only because it matches
              the boosting query.


              Depending on your boosting rules, in certain cases, you would like
              to prevent recommendation results from being

              too monotone due to boosting. With Miso, you have two tools to do
              so.


              First, you can specify `boost_positions` to place promoted products
              at specific positions in the ranking. For

              example, the query below will place boosted products only at the
              first and fourth places in the ranking

              (positions are 0-based), and place the remaining products in their
              original ranking, skipping these two positions.

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
                 "boost_positions": [0, 3]
              }

              ```


              The second tool is `diversification`. `diversification` parameter,
              on a best-effort basis, will try to

              maintain a minimum distance between products that have the same
              attributes. For example, the following query

              will place products made by the same brand apart from each other.

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
                 "diversification": {
                     "brand": {"minimum_distance": 1}
                  }
              }

              ```
          boost_positions:
            title: Boost Positions
            type: array
            items:
              type: integer
            description: >

              Defines a list of 0-based positions you want to place the boosted
              products at.


              For example, the query below will promote products whose brand is
              `Nike` as the top and second recommendations:

              ```

              {
                  "boost_fq": "brand:\"Nike\"",
                  "boost_positions": [0, 1]
              }

              ```

              If `boost_positions` is not specified (which is the default
              behavior), all the boosted products will be ranked

              higher than the rest of the products.
      BulkIndividualResponse:
        title: BulkIndividualResponse
        required:
          - error
          - status_code
          - body
        type: object
        properties:
          error:
            title: Error
            type: boolean
            description: Whether there is an error
          status_code:
            title: Status Code
            type: integer
            description: Status code of the response
          body:
            title: Body
            allOf:
              - $ref: '#/components/schemas/GeneralBody'
            description: The response body
        description: 'Individual response in a bulk API request '
      BulkRequest:
        title: BulkRequest
        required:
          - requests
        type: object
        properties:
          requests:
            title: Requests
            maxItems: 100
            minItems: 1
            type: array
            items:
              $ref: '#/components/schemas/EngineAPIRequest'
            description: An array of request objects
        description: Bulk API request
      BulkResponse:
        title: BulkResponse
        required:
          - data
          - errors
        type: object
        properties:
          data:
            title: Data
            type: array
            items:
              $ref: '#/components/schemas/BulkIndividualResponse'
            description: The bulk request results
          errors:
            title: Errors
            type: boolean
            description: Whether there is any errors in the responses
        description: 'Bulk API response '
      Campaign:
        title: Campaign
        type: object
        properties:
          name:
            title: Name
            type: string
            description: >-
              Name of the campaign. Identifies a specific product promotion or
              strategic campaign.  (see [UTM
              parameters](https://en.wikipedia.org/wiki/UTM_parameters))
            example: spring_sale
          source:
            title: Source
            type: string
            description: >-
              Source of the campaign. Identifies which site sent the traffic. (see
              [UTM parameters](https://en.wikipedia.org/wiki/UTM_parameters))
            example: Google
          medium:
            title: Medium
            type: string
            description: >-
              Medium of the campaign that identifies what type of link was used,
              such as cost per click or email. (see [UTM
              parameters](https://en.wikipedia.org/wiki/UTM_parameters))
            example: cpc
          term:
            title: Term
            type: string
            description: >-
              Term of the campaign that identifies search terms. (see [UTM
              parameters](https://en.wikipedia.org/wiki/UTM_parameters))
            example: running+shoes
          content:
            title: Content
            type: string
            description: >-
              Content of the campaign that identifies what specifically was
              clicked to bring the user to the site, such as a banner ad or a text
              link. It is often used for A/B testing and content-targeted ads.
              Identifies search terms.  (see [UTM
              parameters](https://en.wikipedia.org/wiki/UTM_parameters))
            example: textlink
      CategoryPageView:
        title: category_page_view
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - category_page_view
            type: string
            description: >

              Used when a user views a category page for a specific “family” or
              “group” or products or content.

              This is a strong indicator of what types category of products or
              content the user is interested in.
          duration:
            title: Duration
            type: number
            description: >

              How long (in seconds) the user stayed on this page, or consumed
              (listened, read, or watched) a product. This field is

              optional, but it's very important in scenarios where consumption
              duration matters, including

              `product_detail_page_view`, `category_page_view`, `watch`, `listen`,
              and `read`. For example, if a user only

              views or consumes a product for less than 5 seconds, that user is
              probably not interested in the product. On

              the other hand, if a user stays on a page for a while, it usually
              means they are seriously engaging with or

              considering the product. When `duration` is absent, we will use the
              timestamp of the next interaction to

              infer a rough duration value.


              Example:

              ```

              {"duration": 61.5}

              ```
            example: 61.5
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
          category:
            title: Category
            type: array
            items:
              type: string
            description: >

              Categories usually fall in a hierarchy, such as *Home & Garden >
              Kitchen & Dining > Kitchen Tools & Utensils >

              Sushi Mats* Use this field to specify the full hierarchical list
              describing the category the user is viewing.


              The levels should be listed from broad to narrow:

              `["TOP_LEVEL_CATEGORY", "SUBCATEGORY_1", "SUBCATEGORY_2", ...]`.

              This field is only used by the category_page_view interaction type,
              but this data is very useful for

              determining the user’s interests.

              Example:

              ```

              [
               "Home & Garden",            // TOP_LEVEL_CATEGORY
               "Kitchen & Dining",         // SUBCATEGORY_1
               "Kitchen Tools & Utensils", // SUBCATEGORY_2
               "Sushi Mats"                // SUBCATEGORY_3
              ]

              ```
        additionalProperties: false
      CategoryRecRecord:
        title: CategoryRecRecord
        required:
          - category
          - total
          - recommended_products
        type: object
        properties:
          category:
            title: Category
            type: array
            items:
              type: string
            description: The attribute we recommend to the user in their textual form
            example:
              - Miso T-Shirt Shop
          total:
            title: Total
            type: integer
            description: The total number of products that are associated with this category.
            example: 1000
          recommended_products:
            title: Recommended Products
            type: array
            items:
              $ref: '#/components/schemas/Record'
            description: >-
              Top personalized recommendations for the user of products that are
              associated with this category.
            example: 1000
      CategoryRecResponse:
        title: CategoryRecResponse
        required:
          - data
        type: object
        properties:
          message:
            title: Message
            type: string
            default: success
          data:
            $ref: '#/components/schemas/CategoryResponseBody'
      CategoryResponseBody:
        title: CategoryResponseBody
        required:
          - categories
        type: object
        properties:
          took:
            title: Took
            type: integer
            description: Number of milliseconds Miso took to retrieve the results.
            default: 0
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            default: 00000000-0000-0000-0000-000000000000
            example: 123e4567-e89b-12d3-a456-426614174000
          categories:
            title: Categories
            type: array
            items:
              $ref: '#/components/schemas/CategoryRecRecord'
            description: The category recommendation results.
      CheckProductExistence:
        title: CheckProductExistence
        required:
          - product_ids
        type: object
        properties:
          product_ids:
            title: Product Ids
            minLength: 1
            type: array
            items:
              type: string
              minLength: 1
            description: >-
              A list of product ids to be checked if they will be returned in the
              search results
      Checkout:
        title: checkout
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - checkout
            type: string
            description: >

              Used when a user enters checks out with a set of products. For an
              eCommerce site, this is the strongest signal of the user's

              interest and has a high probability of leading to an eventual
              purchase.
          revenue:
            title: Revenue
            type: number
            description: >

              Total revenue associated with the checkout.  The revenue should
              include generally shipping, tax, etc. that you

              want to include as part of your revenue calculations.
            example: 23.32
          quantities:
            title: Quantities
            anyOf:
              - type: array
                items:
                  type: number
              - type: number
            description: >

              The quantities of products the user adds to their cart or checks out
              with. This field should be a list of positive values.

              Specifically, if `product_ids` is a list of N products, the
              `quantities` needs to be a list with N numbers as well.

              If `quantities` are not specified, we will assume the quantity to be
              1 for every product.


              Example:

              ```

              {"quantities": [1, 2]}

              ```
            example:
              - 1
              - 2
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      ChildrenObject:
        title: ChildrenObject
        required:
          - id
        type: object
        properties:
          id:
            title: Id
            type: string
          url:
            title: Url
            type: string
          title:
            title: Title
            type: string
          description:
            title: Description
            type: string
          html:
            title: Html
            type: string
          headers:
            title: Headers
            type: array
            items:
              type: string
          custom_attributes:
            title: Custom Attributes
            type: object
            additionalProperties:
              anyOf:
                - type: boolean
                - type: integer
                - type: number
                - type: string
                - type: array
                  items:
                    type: number
                - type: array
                  items:
                    type: string
                - type: object
                  additionalProperties:
                    anyOf:
                      - type: string
                      - type: number
                      - type: integer
                      - type: boolean
                - type: array
                  items:
                    type: object
                    additionalProperties:
                      anyOf:
                        - type: string
                        - type: number
                        - type: integer
                        - type: boolean
      Click:
        title: click
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - click
            type: string
            description: >

              Used when user clicked on something, and does not belong to any
              other interaction type.
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      Complete:
        title: complete
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - complete
            type: string
            description: >

              Used when a user "complete" a product (e.g. complete a course or a
              video).
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      Completion:
        title: Completion
        required:
          - text
          - text_with_markups
          - text_with_inverted_markups
        type: object
        properties:
          text:
            title: Text
            minLength: 1
            type: string
            example: Japanese Shiba Inu Dog Eating Miso Soup T-Shirt
          text_with_markups:
            title: Text With Markups
            minLength: 1
            type: string
            example: Japanese<mark> Shiba Inu Dog Eating Miso Soup T-Shirt</mark>
          text_with_inverted_markups:
            title: Text With Inverted Markups
            minLength: 1
            type: string
            example: <mark>Japanese</mark> Shiba Inu Dog Eating Miso Soup T-Shirt
        description: 'basic completion response only has `text` '
      CreateResponse:
        title: CreateResponse
        required:
          - message
          - data
        type: object
        properties:
          message:
            title: Message
            type: string
            description: Human-readable message
            example: success
          data:
            $ref: '#/components/schemas/TaskId'
      Custom:
        title: custom
        required:
          - type
          - custom_action_name
        type: object
        properties:
          type:
            title: Type
            enum:
              - custom
            type: string
            description: >

              Used when you want to record any other kinds of interactions between
              users and products.
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
          custom_action_name:
            title: Custom Action Name
            type: string
            description: |

              The name of the custom interaction that you have defined.
        additionalProperties: false
      DeleteResponse:
        title: DeleteResponse
        required:
          - message
          - data
        type: object
        properties:
          message:
            title: Message
            type: string
            description: Human-readable message
            example: success
          data:
            $ref: '#/components/schemas/TaskId'
      Dislike:
        title: dislike
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - dislike
            type: string
            description: >

              Used when a user indicates a `dislike` for a product or indicates

              they would like to not be recommended content or products like this
              in the future.
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      DiversifyField:
        title: DiversifyField
        type: object
        properties:
          minimum_distance:
            title: Minimum Distance
            type: integer
            description: Minimum distance between two products that have the same value
            default: 1
          always_together:
            title: Always Together
            type: boolean
            description: >-
              If always_together=true, all the products that have the same value
              for this field, will be put side-by-side.
            default: false
      EngineAPIRequest:
        title: EngineAPIRequest
        required:
          - api_name
          - body
        type: object
        properties:
          api_name:
            title: Api Name
            type: string
            description: >

              The name of the API. An API name should contain one slash. For
              example: `search/search` or `recommendation/user_to_products`
          body:
            title: Body
            type: object
            description: |

              The request body to the API.
        description: Engine API request
      ExperimentRequest:
        title: ExperimentRequest
        type: object
        properties:
          user_id:
            title: User Id
            type: string
            description: Identifies the signed-in user who performed the interaction.
            example: '2179873'
          anonymous_id:
            title: Anonymous Id
            type: string
            description: A pseudo-unique substitute for the User Id
            example: 403fb18e-98ff-434d-8585-726fabf5ed37
          variant_name:
            title: Variant Name
            type: string
            description: >-
              Set the variant_name if you want to assign a user to a specific
              variant. Most of the time, you don't need to pass this field.
              Instead, the system will automatically assign a variant for this
              user.
            example: Treatment_Group
          timestamp:
            title: Timestamp
            type: string
            description: >-
              The time the user is assigned to the variant group. If not set,
              current time will be used.
            format: date-time
            example: '2022-01-23T12:34:56-08:00'
      FacetCounts:
        title: FacetCounts
        type: object
        properties:
          facet_fields:
            title: Facet Fields
            type: object
            additionalProperties:
              type: array
              items:
                type: array
                items:
                  - type: string
                  - type: integer
            description: Facet counts of each facet field
            default: {}
      FacetDefinition:
        title: FacetDefinition
        required:
          - field
        type: object
        properties:
          field:
            title: Field
            type: string
            description: >+

              The field name to create a facet against. For example, the following
              query will create a facet against

              the `custom_attributes.director` field, and return the ten most
              common facet values of this field

              (for Products that match the search query):

              ```

              {
                  "field": "custom_attributes.director",
                  "size": 10
              }

              ```

          size:
            title: Size
            type: integer
            description: >

              Number of facet values to return. The facet values are sort
              descendingly by the number of Products

              that have these values (and match the search query).
            default: 10
          include:
            title: Include
            type: string
            description: >

              Filter facet values based on a regular expression. For example, the
              following query will return only the facet

              values that start with `Steven` (case-sensitive):

              ```

              {
                  "field": "custom_attributes.director",
                  "size": 10,
                  "include": "Steven.*"
              }

              ```

              You can escape a special character with a preceding backslash `\` or
              surround it with double quotes.

              For example, the following query will only return the facet values
              starting with `St.`:


              ```

              {
                  "field": "custom_attributes.place_name",
                  "size": 10,
                  "include": "\"St.\".*"
              }

              ```


              Note that, the `include` parameter will only affect the facet
              values, and will not affect the search result itself.
          ranges:
            title: Ranges
            type: array
            items:
              $ref: '#/components/schemas/RangeRequireKey'
            description: >

              Facet ranges for numeric fields or date-like string fields. For
              example, the following query groups the products

              into fours buckets against on their `original_price` ranges, each of
              which has a user-friendly "key":

              ```

              {
                  "field": "original_price",
                  "ranges": [
                      {"to": 10, "key": "Less than 10 dollars"},
                      {"from": 10, "to": 100, "key": "10 to 100 dollars"},
                      {"from": 100, "to": 1000, "key": "100 to 1,000 dollars"},
                      {"from": 1000, "key": "More than 1,000 dollars"}
                  ]
              }

              ```


              For each range object, you need to at least specify one of the `to`
              or `from` values (or both). `from`

              is always **inclusive**, and `to` is always **exclusive**. In the
              response, Miso refers to each bucket by their `key`.

              For example, the above request will have the following response:

              ```

              {
                "facet_counts": {
                  "facet_fields": {
                    "original_price": [
                      [
                        "Less than 10 dollars", 1987
                      ],
                      [
                        "10 to 100 dollars", 109
                      ],
                      [
                        "100 to 1,000 dollars", 123
                      ],
                      [
                        "More than 1,000 dollars", 5
                      ]
                    ]
                  }
                }
              }

              ```
          queries:
            title: Queries
            type: array
            items:
              $ref: '#/components/schemas/QueryFilterRequireKey'
            description: >

              Facet queries that support facet counts for any arbitrary Lucene
              queries,

              each of which is labeled by a user-friendly "key":

              ```

              {
                  "field": "my_custom_facet",
                  "queries": [
                      {
                          "query": "price: [* TO 10] AND size:"Small"",
                          "key": "Less than 10 dollars / Small size"
                      },
                      {
                          "query": "price: [10 TO 100] AND size:"Medium"",
                          "key": "10 to 100 dollars / Medium size"
                      },
                      {
                          "query": "price: [100 TO *] AND size:"Large"",
                          "key": "More than 100 dollars / Large size"
                      }
                  ]
              }

              ```


              In the response, Miso refers to the query result by their `key`.

              For example, the above request will have the following response:

              ```

              {
                "facet_counts": {
                  "facet_fields": {
                    "my_custom_facet": [
                      [
                        "Less than 10 dollars / Small size", 1987
                      ],
                      [
                        "10 to 100 dollars / Medium size", 109
                      ],
                      [
                        "More than 100 dollars / Large size", 123
                      ]
                    ]
                  }
                }
              }

              ```
      Feedback:
        title: feedback
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - feedback
            type: string
            description: |

              Used when a user sends feedback on provided results.
          question_id:
            title: Question Id
            maxLength: 512
            type: string
            description: >

              A unique identifier representing the specific question for which
              feedback is being provided.
            example: question_123
          result_type:
            title: Result Type
            type: string
            description: >

              Indicates the type of result the provided feedback is associated
              with, e.g., an answer or a suggestion.
            example: answer
          value:
            title: Value
            type: string
            description: >

              Specifies the user's perspective on the provided result, with
              possible values being helpful, not helpful,

              or unselected if the user has not provided any feedback.
            example: helpful
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      Filter:
        title: Filter
        type: object
        properties:
          terms:
            title: Terms
            type: array
            items:
              type: string
          ranges:
            title: Ranges
            type: array
            items:
              $ref: '#/components/schemas/Range'
          queries:
            title: Queries
            type: array
            items:
              $ref: '#/components/schemas/QueryFilter'
      FilterQueryItem:
        title: FilterQueryItem
        required:
          - option
          - query
        type: object
        properties:
          option:
            title: Option
            enum:
              - overlap_with
            type: string
            description: The filter query option of the boosting rule.
          query:
            title: Query
            type: string
            description: The filter query of the boosting rule.
      GeneralBody:
        title: GeneralBody
        type: object
        properties: {}
        description: 'Allow any json body '
      GeoDistanceQuery:
        title: GeoDistanceQuery
        required:
          - lat
          - lon
          - distance
        type: object
        properties:
          lat:
            title: Lat
            maximum: 90
            minimum: -90
            type: number
            description: Latitude of the center point, should between 90 and -90
          lon:
            title: Lon
            maximum: 180
            minimum: -180
            type: number
            description: Longitude of the center point, should between 180 and -180
          field:
            title: Field
            type: string
            description: >-
              Name of the field in product data that holds geographic coordinate.
              Defaults to `location`
            default: location
          distance:
            title: Distance
            type: number
            description: >-
              Distance to center point, in kilometer or mile (according to
              `distance_unit`)
          distance_unit:
            title: Distance Unit
            enum:
              - km
              - mile
            description: Unit of distance(`km` or `mile`). Defaults to `mile`
            default: mile
      GeoDistanceQueryBoost:
        title: GeoDistanceQueryBoost
        required:
          - lat
          - lon
          - distance
        type: object
        properties:
          lat:
            title: Lat
            maximum: 90
            minimum: -90
            type: number
            description: Latitude of the center point, should between 90 and -90
          lon:
            title: Lon
            maximum: 180
            minimum: -180
            type: number
            description: Longitude of the center point, should between 180 and -180
          field:
            title: Field
            type: string
            description: >-
              Name of the field in product data that holds geographic coordinate.
              Defaults to `location`
            default: location
          distance:
            title: Distance
            type: number
            description: >-
              Distance to center point, in kilometer or mile (according to
              `distance_unit`)
          distance_unit:
            title: Distance Unit
            enum:
              - km
              - mile
            description: Unit of distance(`km` or `mile`). Defaults to `mile`
            default: mile
          boost_positions:
            title: Boost Positions
            type: array
            items:
              type: integer
            description: |2-

                      Defines a list of 0-based positions you want to place the boosted products at.

                      If `boost_positions` is not specified (which is the default behavior), all the boosted products will be ranked
                      higher than the rest of the products.
                      
      GeoQuery:
        title: GeoQuery
        type: object
        properties:
          filter:
            title: Filter
            type: array
            items:
              $ref: '#/components/schemas/GeoDistanceQuery'
            description: >-
              When set, filter result to include only products within certain
              geographic range from given point.
            default: []
          boost:
            title: Boost
            type: array
            items:
              $ref: '#/components/schemas/GeoDistanceQueryBoost'
            description: >-
              When set, boost products within certain geographic range from given
              point.
            default: []
      HTTPValidationError:
        title: HTTPValidationError
        type: object
        properties:
          detail:
            title: Detail
            type: array
            items:
              $ref: '#/components/schemas/ValidationError'
      HomePageView:
        title: home_page_view
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - home_page_view
            type: string
            description: |

              Used when a user views your home page.
          duration:
            title: Duration
            type: number
            description: >

              How long (in seconds) the user stayed on this page, or consumed
              (listened, read, or watched) a product. This field is

              optional, but it's very important in scenarios where consumption
              duration matters, including

              `product_detail_page_view`, `category_page_view`, `watch`, `listen`,
              and `read`. For example, if a user only

              views or consumes a product for less than 5 seconds, that user is
              probably not interested in the product. On

              the other hand, if a user stays on a page for a while, it usually
              means they are seriously engaging with or

              considering the product. When `duration` is absent, we will use the
              timestamp of the next interaction to

              infer a rough duration value.


              Example:

              ```

              {"duration": 61.5}

              ```
            example: 61.5
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      Impression:
        title: impression
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - impression
            type: string
            description: >-

              Used to record when a user saw or was presented with a product or
              content asset.

              An impression does not mean a user is interested: for example, if
              there is an impression for a

              certain product, but no further interaction occurs with that
              product, we assume the user is probably not

              interested in it.


              For an impression that was generated by Miso's search results or
              recommendations results, it is important to

              include the `miso_id` associated with the results so that we know
              the impression is from Miso
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      InteractionBulkIn:
        title: InteractionBulkIn
        required:
          - data
        type: object
        properties:
          data:
            title: Data
            type: array
            items:
              anyOf:
                - $ref: '#/components/schemas/ProductDetailPageView'
                - $ref: '#/components/schemas/Search'
                - $ref: '#/components/schemas/AddToCart'
                - $ref: '#/components/schemas/RemoveFromCart'
                - $ref: '#/components/schemas/Checkout'
                - $ref: '#/components/schemas/Refund'
                - $ref: '#/components/schemas/Subscribe'
                - $ref: '#/components/schemas/AddToCollection'
                - $ref: '#/components/schemas/RemoveFromCollection'
                - $ref: '#/components/schemas/Read'
                - $ref: '#/components/schemas/Watch'
                - $ref: '#/components/schemas/Listen'
                - $ref: '#/components/schemas/Like'
                - $ref: '#/components/schemas/Dislike'
                - $ref: '#/components/schemas/Share'
                - $ref: '#/components/schemas/Rate'
                - $ref: '#/components/schemas/Bookmark'
                - $ref: '#/components/schemas/Complete'
                - $ref: '#/components/schemas/Feedback'
                - $ref: '#/components/schemas/Impression'
                - $ref: '#/components/schemas/ViewableImpression'
                - $ref: '#/components/schemas/Click'
                - $ref: '#/components/schemas/HomePageView'
                - $ref: '#/components/schemas/CategoryPageView'
                - $ref: '#/components/schemas/PromoPageView'
                - $ref: '#/components/schemas/ProductImageView'
                - $ref: '#/components/schemas/Custom'
      InteractionCreateOut:
        title: InteractionCreateOut
        required:
          - message
        type: object
        properties:
          message:
            title: Message
            type: string
            description: Human-readable message
            example: success
      InteractionDeleteIn:
        title: InteractionDeleteIn
        required:
          - user_ids
        type: object
        properties:
          user_ids:
            title: User Ids
            type: array
            items:
              type: string
      InteractionDeleteOut:
        title: InteractionDeleteOut
        required:
          - message
        type: object
        properties:
          message:
            title: Message
            type: string
            description: Human-readable message
            example: success
      Like:
        title: like
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - like
            type: string
            description: |

              Used to record when a user indicates a `like` for a product.
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      Listen:
        title: listen
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - listen
            type: string
            description: >

              Used to record when and for how long a user listens to content that
              is of an audio format.
          duration:
            title: Duration
            type: number
            description: >

              How long (in seconds) the user stayed on this page, or consumed
              (listened, read, or watched) a product. This field is

              optional, but it's very important in scenarios where consumption
              duration matters, including

              `product_detail_page_view`, `category_page_view`, `watch`, `listen`,
              and `read`. For example, if a user only

              views or consumes a product for less than 5 seconds, that user is
              probably not interested in the product. On

              the other hand, if a user stays on a page for a while, it usually
              means they are seriously engaging with or

              considering the product. When `duration` is absent, we will use the
              timestamp of the next interaction to

              infer a rough duration value.


              Example:

              ```

              {"duration": 61.5}

              ```
            example: 61.5
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      LocationInformation:
        title: LocationInformation
        required:
          - lat
          - lon
        type: object
        properties:
          lat:
            title: Lat
            type: number
            example: 40.74844
          lon:
            title: Lon
            type: number
            example: -73.985664
      MultipleGetRequest:
        title: MultipleGetRequest
        required:
          - product_ids
        type: object
        properties:
          engine_id:
            title: Engine Id
            type: string
            description: >

              The engine you want to get results from. When you have more than one
              engine, you can use this parameter to

              specify the specific engine you want to get results from. If not
              specified, the default engine will be used.
          user_id:
            title: User Id
            type: string
            description: >

              The user who made the query and for whom Miso will personalize the
              results. For an anonymous visitor, use `anonymous_id` instead.
          anonymous_id:
            title: Anonymous Id
            type: string
            description: >-
              The anonymous visitor who made the query and for whom Miso will
              personalize the results. Either
                      `user_id` or `anonymous_id` needs to be specified for personalization to work. 
          user_hash:
            title: User Hash
            type: string
            description: >

              The hash of `user_id` (or `anonymous_id`) encrypted by your [Secret
              API Key](https://api.askmiso.com).

              `user_hash` is required to prevent unauthorized API access if you
              are

              making API calls with a [Publishable API
              Key](https://api.askmiso.com).


              You should generate the user_hash via HMAC scheme: you encrypt the
              desired user_id (or anonymous_id) with your

              [Secret API Key](https://api.askmiso.com) on your backend server,

              and then let the front-end code send the generated user_hash to Miso
              APIs to

              verify the identity of the API caller.


              As long as the [Secret API Key](https://api.askmiso.com)
               is kept secret, the user_hash prevents a malicious attacker from making unauthorized
              API calls or impersonating any of your users.


              Miso APIs accept the case-incentive "hex digest" of user hash, a
              sample Python 3 code to generate it on your backend server

              is as follow:


              ```python

              import hashlib

              import hmac


              YOUR_MISO_SECRET_API_KEY = "039c501ac8dfcac91"

              key_bytes = YOUR_MISO_SECRET_API_KEY.encode()

              user_id = "USER_123" # or anonymous_id

              user_id_bytes = user_id.encode()

              user_hash = hmac.new(
                  key_bytes,
                  user_id_bytes,
                  hashlib.sha256).hexdigest()
              # user_hash is "7eb04da5e..."

              ```


              You can find more examples for other languages in this [Github
              Gist](https://gist.github.com/thewheat/7342c76ade46e7322c3e)
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
            description: >

              List of product_ids to retrieve. Products will be returned in the
              same order as they are given in this list.
          fl:
            title: Fl
            type: array
            items:
              type: string
            description: >

              List of fields to retrieve. For example, the following request
              retrieves only the `title` field of each product
               along with the `product_id`, which is always returned.

              ```

              {"fl": ["title"]}

              ```


              You can also match field names by using `*` as a wildcard. For
              example, the query below retrieves the `title`

              and any custom attributes under the `attributes` dictionary.


              ```

              {"fl": ["title", "attributes.*"]}

              ```


              The following retrieves all the available fields  (which is the
              default):


              ```

              {"fl": ["*"]}

              ```


              For the lowest latency, use an empty array to retrieve just the
              `product_id` field.

              ```

              {"fl": []}

              ```
            default:
              - '*'
      MultipleGetResponse:
        title: MultipleGetResponse
        required:
          - data
        type: object
        properties:
          message:
            title: Message
            type: string
            default: success
          data:
            $ref: '#/components/schemas/MultipleGetResponseBody'
      MultipleGetResponseBody:
        title: MultipleGetResponseBody
        required:
          - products
        type: object
        properties:
          took:
            title: Took
            type: integer
            description: Number of milliseconds Miso took to retrieve the results.
            default: 0
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            default: 00000000-0000-0000-0000-000000000000
            example: 123e4567-e89b-12d3-a456-426614174000
          products:
            title: Products
            type: array
            items:
              $ref: '#/components/schemas/RecordWithFound'
        description: >-
          Return a list of Product records. Some or all of them are potentially
          not found
      OrderByDefinition:
        title: OrderByDefinition
        required:
          - field
        type: object
        properties:
          field:
            title: Field
            type: string
            description: >+

              Name of the field to order by. You can sort by any numeric and
              boolean fields in your Product catalog, or use one of any special
               fields:
              * **_personalization_score**: the score that rates the degree of
              affinity between

              a pair of user and product from Miso's personalization algorithm.

              * **_search_score**: the score that rates the degree of search
              keyword matches to a product's catalog.

              * **_boosting_score**: the score that rates the degree a Product is
              boosted by your boosting query.

          tie_breaker:
            title: Tie Breaker
            allOf:
              - $ref: '#/components/schemas/TieBreakDefinition'
            default:
              type: relative_difference
              threshold: 0
          default_value:
            title: Default Value
            type: number
            description: The default value to use when the scores do not exist for a Product
            default: 0
          geo:
            title: Geo
            allOf:
              - $ref: '#/components/schemas/BaseGeo'
            description: >-
              The geo point to compute the `_geo_distance` variable against. This
              is only required if
                      `_geo_distance` is present in the formula.
          order:
            title: Order
            enum:
              - desc
              - asc
            default: desc
      Page:
        title: Page
        required:
          - url
        type: object
        properties:
          url:
            title: Url
            type: string
            description: Url of the page
            example: https://example.com/miso-tshirt-123ABC
          referrer:
            title: Referrer
            type: string
            description: Url of the referrer page
            example: https://example.com/
          title:
            title: Title
            type: string
            description: Title of the page
            example: My Product Page
      PartialMatchedRecord:
        title: PartialMatchedRecord
        required:
          - product_id
        type: object
        properties:
          product_id:
            title: Product Id
            maxLength: 512
            type: string
            description: |2-

                      The unique identifier for the product.
                      
            example: 123ABC-S-Black
      PollAnswerResponse:
        title: PollAnswerResponse
        required:
          - data
        type: object
        properties:
          message:
            title: Message
            type: string
            description: >-
              The status of the API response ('success' or other human readable
              api status).
            default: success
          data:
            title: Data
            allOf:
              - $ref: '#/components/schemas/AnswerData'
            description: >-
              The answer data containing the latest answer, sources, and related
              resources.
      PostQuestionRequest:
        title: PostQuestionRequest
        required:
          - data
        type: object
        properties:
          data:
            title: Data
            type: array
            items:
              $ref: '#/components/schemas/app__schemas__engine_api__request__Question'
        description: Post questions request
      ProductBulkDeleteIn:
        title: ProductBulkDeleteIn
        required:
          - data
        type: object
        properties:
          data:
            $ref: '#/components/schemas/ProductIdList'
      ProductBulkIn:
        title: ProductBulkIn
        required:
          - data
        type: object
        properties:
          data:
            title: Data
            type: array
            items:
              $ref: '#/components/schemas/ProductRecord'
      ProductDetailPageView:
        title: product_detail_page_view
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - product_detail_page_view
            type: string
            description: >-
              Used when a user views the detail page of a product. Viewing a
              product
                      detail page usually indicates a user is interested in the product to certain degree, especially,
                      when the `duration` of the page view is long. When `duration` of the page view is very short (< 5 seconds),
                      `product_detail_page_view` may indicate neural or negative interest in the product. 
          duration:
            title: Duration
            type: number
            description: >

              How long (in seconds) the user stayed on this page, or consumed
              (listened, read, or watched) a product. This field is

              optional, but it's very important in scenarios where consumption
              duration matters, including

              `product_detail_page_view`, `category_page_view`, `watch`, `listen`,
              and `read`. For example, if a user only

              views or consumes a product for less than 5 seconds, that user is
              probably not interested in the product. On

              the other hand, if a user stays on a page for a while, it usually
              means they are seriously engaging with or

              considering the product. When `duration` is absent, we will use the
              timestamp of the next interaction to

              infer a rough duration value.


              Example:

              ```

              {"duration": 61.5}

              ```
            example: 61.5
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      ProductIdList:
        title: ProductIdList
        required:
          - product_ids
        type: object
        properties:
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
      ProductIds:
        title: ProductIds
        required:
          - ids
        type: object
        properties:
          ids:
            title: Ids
            type: array
            items:
              type: string
      ProductImageView:
        title: product_image_view
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - product_image_view
            type: string
            description: >

              Used when a user views the image of a product (e.g. to enlarge a
              product photo).
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      ProductListOut:
        title: ProductListOut
        required:
          - message
          - data
        type: object
        properties:
          message:
            title: Message
            type: string
          data:
            $ref: '#/components/schemas/ProductIds'
        additionalProperties: false
      ProductReadOut:
        title: ProductReadOut
        required:
          - message
          - data
        type: object
        properties:
          message:
            title: Message
            type: string
          data:
            $ref: '#/components/schemas/ProductRecord'
        additionalProperties: false
      ProductRecord:
        title: ProductRecord
        required:
          - product_id
        type: object
        properties:
          product_id:
            title: Product Id
            maxLength: 512
            minLength: 1
            type: string
            description: >

              The unique identifier for this product. The Id can be in any format
              you use in your product 

              database (e.g. the product's SKU, UPC, or UUID or serial number). We
              will use this Id to track how users 

              interact with products and content in the Interactions records you
              upload to Miso. It is important to keep the Id 

              consistent between two datasets. For products that have multiple
              variants, you should have a unique 

              `product_id` for each variant, and use `product_group_id` to group
              them together.


              For example, for a T-shirt with SKU `123ABC` that comes in 4 sizes:
              `S`, `M`, `L`, `XL`, we should create four different 

              products:


              ```

              { 
                "product_id": "123ABC-S",
                "product_group_id" "123ABC"
              }

              { 
                "product_id": "123ABC-M",
                "product_group_id" "123ABC"
              }

              { 
                "product_id": "123ABC-L",
                "product_group_id" "123ABC"
              }

              { 
                "product_id": "123ABC-XL",
                "product_group_id" "123ABC"
              }

              ```   

               * Constraints
                  * Can't contain `,`
                  * Can't start with `_`
                  * Length <= 512
            example: 123ABC-S-Black
          product_group_id:
            title: Product Group Id
            type: string
            description: >

              The `product_group_id` is used to prevent the same product (but a
              different variant) from showing multiple 

              times in the search or recommendation results. When one product has
              multiple variants (for example, different 

              sizes, colors, or materials), you should assign a unique product_id
              to each variant, but assign the same 

              `product_group_id` to all of them. If `product_group_id` is not
              given, we default to the value of `product_id`. 
            example: 123ABC
          parent_id:
            title: Parent Id
            type: string
            description: >+

              The `parent_id` is used to declare a parent-child relationship
              between two "Products". 

              Such relationships are common in marketplaces and content media
              sites with user generated contents. 

              For example, an E-commerce marketplace (such as E-bay or Amazon) 

              may have "Shops" (as parents) and "Merchandises" 

              (as children), and a social streaming site, such as YouTube, may
              have "Channel" (as parents) and "Video" (as children). In these
              sites, both entities can be modeled as "Products", and can both be
              returned in Search and Recommendation APIs.


              Declaring the parent-child relationships allows Miso to
              automatically propagate interactions from one product to the other.

              For example, when a user "watch" a 

              Video, Miso will propagate this signal to the 

              Channel which publishes this Video, even if users do not directly
              interact with the Channel page. Such implicit 

              interactions

              are particularly useful when making recommendations for Channel
              because it gives Miso much more information 

              about users' interests to different Channels than solely relying on
              users' direct interactions with the 

              them, which happens less often. 


              `parent_id` needs to be a non-empty string referring to the
              `product_id` of the parent product. 

              The parent product can be uploaded in a separate batch, and does not
              need to exist before its children products.


              The implicit interactions will only exist during Miso's training
              process, and will not show up in the 

              Interaction dataset.

            example: Nike_Shop_123
          related_ids:
            title: Related Ids
            type: array
            items:
              type: string
            description: >-
              The product_id or product_group_id of other products that are
              related to this Product
          type:
            title: Type
            type: string
            description: >

              The `type` of product. This is for sites that have more than one
              type of product or content that they want their users 

              to interact with. If your site has only one type of product, you can
              leave this field out. 

              A classic example is travel sites, which have both *hotel* and
              *flight* sales. It is also useful for sites that let 

              users interact with products as well as *product bundles*. For
              example, on YouTube, each video is a product that users 

              can watch, while each channel, containing multiple videos, is also a
              product that users can subscribe to.


              For model quality, it is preferable to model all these distinct
              product types in the same data set, so that a user's 

              interests for one type of product can inform their interests in
              another type of products. The `type` field helps Miso 

              make these distinctions.
            example: clothes
          title:
            title: Title
            type: string
            description: >

              The title of the product. During a search, Miso will put predictive
              weight behind the title, 

              because it is often the main way users identify a product.
            example: Japanese Shiba Inu Dog Eating Miso Soup T-Shirt
          description:
            title: Description
            type: string
            description: >

              The `description` text of the product. Miso assumes `description`
              contains longer textual content than other 

              string-based fields. For example, term frequency matters more here
              than in a field like the title. Miso’s 

              semantic understanding can extract a lot of valuable information
              from having a product description that is 

              plain-spoken and detailed. 
            example: >-
              This cute Shiba inu dog eating Miso soup is perfect for those who
              love Japanese culture.
          language:
            title: Language
            minLength: 2
            type: string
            description: >

              The `language` of the product description and content in [two-letter
              ISO 639-1 code](

              https://en.wikipedia.org/wiki/ISO_639-1). For example, English =
              `en`, Chinese = `zh`. 

              Miso will use this field to determine the proper way to index the
              product description. If this field is not specified, 

              we will determine the language automatically. 


              We also use the language field to determine users’ interests in
              content of different languages. This is particularly 

              important for content media sites that have different languages of
              content. 


              * Constraints:
                  * [Two-letter ISO 639-1 code](https://en.wikipedia.org/wiki/ISO_639-1). 
                  For example, English = `en`, Chinese = `zh`.
            example: en
          created_at:
            title: Created At
            anyOf:
              - type: string
                format: date-time
              - type: string
                format: date
            description: >

              The time when the product was first created or became available on
              your site as an ISO-8601 date or datetime string.  
          published_at:
            title: Published At
            anyOf:
              - type: string
                format: date-time
              - type: string
                format: date
            description: >

              The time when the product was published as an ISO-8601 date or
              datetime string. 
          updated_at:
            title: Updated At
            anyOf:
              - type: string
                format: date-time
              - type: string
                format: date
            description: >

              The time when the product was updated as an ISO-8601 date or
              datetime string. 
          categories:
            title: Categories
            type: array
            items:
              type: array
              items:
                type: string
            description: >

              In Miso, you describe a product or content category as a
              hierarchical list of strings from broad to narrow, 

              called a `category`. (See the `category_page_view` interaction.) 


              Use the `categories` field of products to specify the hierarchical
              category or categories that the product 

              belongs to. A product may belong to only a single `category`, or
              multiple. 


              For example, a product could be in both:
               * *Toys & Games > Toys > Dolls, Playsets & Toy Figures > Stuffed Animals*, and
               * *Arts & Entertainment > Hobbies & Creative Arts > Collectibles*. 

               This field should be a list of a list of strings, where category levels go from broad to narrow, such as: 

              ```

              {"categories":
                  [
                      // the first category the product belongs to
                      ["TOYS & GAMES", "TOYS", "DOLLS, PLAYSETS & TOY FIGURES", "STUFFED ANIMALS"],
                      // the second category the product belongs to
                      ["ARTS & ENTERTAINMENT", "HOBBIES & CREATIVE ARTS", "COLLECTIBLES"]
                  ]
              }

              ```


              If your product taxonomy has only one single level, that is not an
              issue:

              ```

              {"categories":
                  [
                      // the first category the product belongs to
                      ["Toys"],
                      // the second category the product belongs to
                      ["Collectibles"]
                  ]
              }

              ```


              The categories are optional, but very important for profiling the
              products and tracking users' preferences. 

              (See also the `category_page_view` interaction)
            example:
              - - Clothing, Shoes & Jewelry
                - Women
                - T-Shirts
              - - Novelty
                - Tops & Tees
                - T-Shirts
          tags:
            title: Tags
            type: array
            items:
              type: string
            description: |

              The tags that have been associated with the product.

              For example:
              ```
              {"tags": ["TAG_1", "TAG_2", ...]}
              ```
            example:
              - cute
              - anime
              - dogs
              - t-shirt
          url:
            title: Url
            maxLength: 65536
            minLength: 1
            type: string
            description: >

              Url to the product detail page. This is for displaying the product
              in your Dojo Sandboxes and is not used for Engine training. 

              It is optional, but strongly recommended for a better Sandbox
              experience.
            format: uri
            example: https://example.com/miso-tshirt-123ABC
          cover_image:
            title: Cover Image
            maxLength: 65536
            minLength: 1
            type: string
            description: >

              The URL of the cover image  of the product. This is for displaying
              the product in your Dojo Sandboxes and 

              is not used for Engine training. It is optional, but strongly
              recommended for a better Sandbox experience. 
            format: uri
            example: https://example.com/miso-tshirt-123ABC.jpg
          original_price:
            title: Original Price
            type: number
            description: >

              The (original) price of the product. We only use this number to
              calculate the amount of discount, and use that

              to profile user behaviors.


              * Constraints:
                  * Need to be a number, but no constraint on the range of the number
            example: 20
          sale_price:
            title: Sale Price
            type: number
            description: |

              The sale price of the product. 

              * Constraints:
                  * Need to be a number, but no constraint on the range of the number
            example: 15
          margin:
            title: Margin
            type: number
            description: >

              The margin of the product. Note that for our margin optimization
              algorithm to work, the margin you specify here
               does not need to be the actual dollar amount, but it needs to be something in proportion to that. 

              * Constraints:
                  * Need to be a number, but no constraint on the range of the number
            example: 15
          size:
            title: Size
            type: string
            description: >

              The size of the product. For example, for an eCommerce site that
              sells T-shirts, each T-shirt might come in

              several different sizes. In this case, we recommend that you should
              create one product entry for 

              each size variant. When Miso generate search or recommendation
              results, we use the `product_group_id` to remove 

              different variants of the same product, and only show the variant
              that the user is most likely to buy. 
            example: S
          color:
            title: Color
            type: string
            description: >

              The color of the products. Similarly to `size`, when `color` of the
              products matters, it is recommended to create 

              one product for each color variant of a product. When Miso generate
              search or recommendation results, 

              we use the `product_group_id` to remove variants of the same
              product, and only show the 

              variant that the user is most likely to buy. 
            example: Black
          material:
            title: Material
            type: string
            description: >

              The material of the products. Similarly to `size` and `color`, if
              `material` of the product matters and there 

              are multiple material variants, we should create one product for
              each material variant. When Miso generates search or 

              recommendation results, we use the `product_group_id` to remove
              variants of the same product, and only show the 

              variant that the user is most likely to buy. 
            example: Cotton
          condition:
            title: Condition
            enum:
              - NEW
              - USED
              - REFURBISHED
            type: string
            description: >

              The condition of the product. By default, we assume `condition`=
              `NEW`
            default: NEW
          brand:
            title: Brand
            type: string
            description: |

              The brand of the product.
            example: Miso Corp.
          authors:
            title: Authors
            type: array
            items:
              type: string
            description: >

              The author(s) of the product or content asset. This field needs to
              be an array of strings.
            example:
              - Andy Hsieh
          publishers:
            title: Publishers
            type: array
            items:
              type: string
            description: >

              The publisher(s) of the product or content asset. This field needs
              to be an array of strings.
            example:
              - O'Reilly Media
          collections:
            title: Collections
            type: array
            items:
              type: string
            description: |

              The collection(s) the product belongs to.
            example:
              - Anime T-Shirt Collection
              - Superhero T-Shirt Collection
          availability:
            title: Availability
            enum:
              - IN_STOCK
              - OUT_OF_STOCK
              - PRE_ORDER
            type: string
            description: >

              The availability of the product. Miso mainly uses `availability` to
              filter `OUT_OF_STOCK` items out of its recommendations.

              As a default, we assume the product is `IN_STOCK`.
          location:
            title: Location
            anyOf:
              - type: array
                items:
                  $ref: '#/components/schemas/LocationInformation'
              - allOf:
                  - $ref: '#/components/schemas/LocationInformation'
            description: >

              The location information of the product (e.g. for hotels or
              restaurants). We support geolocation filtering 

              and sorting when creating search and recommendation results if
              location information is given. 
          rating:
            title: Rating
            type: number
            description: >

              The overall rating of the product in the range of [0, 5]. If you use
              a different rating scale, please convert it

              to the range of [0, 5].
            example: 5
          html:
            title: Html
            type: string
            description: >

              The HTML content of the product. Miso will search against this field
              and apply semantic understanding in a way that is

              similar to the `description` field, but with HTML tags removed. 
          subtitle:
            title: Subtitle
            type: string
            description: |

              The subtitle of the product (usually for contents).
          headers:
            title: Headers
            type: array
            items:
              type: string
            description: >

              The headers in the content. This usually corresponds to `<h1>`,
              `<h2>`, `<h3>` ... tags in HTML. This field need to be an array of
              strings 
          paragraphs:
            title: Paragraphs
            type: array
            items:
              type: string
            description: >

              The text paragraphs in the content. This usually corresponds to
              `<p>` tags in HTML. This field need to be an array of strings 
          anchors:
            title: Anchors
            type: array
            items:
              type: string
            description: >

              The anchor texts paragraphs in the content. This usually corresponds
              to `<a>` tags in HTML. This field need to be an array of strings 
          children:
            title: Children
            type: array
            items:
              $ref: '#/components/schemas/ChildrenObject'
            description: >

              Children objects of the product, such as chapters of a book, or
              sections of a podcast.

              Children are only useful for long-form contents, and are only used
              for snippet extraction purpose.
          enable_question_answering:
            title: Enable Question Answering
            type: boolean
            description: >

              Whether to enable question answering capability against the `html`
              field.
            default: false
          custom_attributes:
            title: Custom Attributes
            type: object
            additionalProperties:
              anyOf:
                - type: boolean
                - type: integer
                - type: number
                - type: string
                - type: array
                  items:
                    type: number
                - type: array
                  items:
                    type: string
                - type: object
                  additionalProperties:
                    anyOf:
                      - type: string
                      - type: number
                      - type: integer
                      - type: boolean
                - type: array
                  items:
                    type: object
                    additionalProperties:
                      anyOf:
                        - type: string
                        - type: number
                        - type: integer
                        - type: boolean
                        - type: array
                          items:
                            type: string
                        - type: array
                          items:
                            type: number
            description: >

              Dictionary of custom attributes for the product. You can specify
              attributes specific to your business 

              in a `{"KEY":VALUE}` format, where `KEY` must be a string, and
              `VALUE` can be:

              * a `bool`

              * a `string` or an `array of string`

              * a `number` or an `array of numbers`

              * an `array of objects`

              * `null` 




              For example, a video streaming site using Miso may have the movie
              *Jumanji* with the following custom attributes: 


              ```

              {
                "custom_attributes": {
                  "cast": [
                    "Robin Williams", "Jonathan Hyde", ...
                  ],
                  "director": "Joe Johnston",
                  "genres": [
                    "Adventure", "Fantasy", "Family"
                  ],
                  "filming_locations": [
                     {"country": "USA", "state": "New Hampshire", "city": "Keene"},
                     {"country": "Canada", "state": "British Columbia", "city": "Vancouver"}
                  ],
                  "popularity": 7.439,
                  "adult": false
                }
              }

              ```


              **The custom attribute types need to be consistent across every
              record in the dataset**. 

              For instance, in the example above, the **cast** attribute needs to
              be a `string` or `an array of string` or `null` 

              for every record in the dataset that specify **cast** attribute.



              Similarly, the popularity attribute needs to be a `number`, `an
              array of numbers`, or `null` for every record in the 

              dataset that specifies the popularity attribute. If you try to
              insert a record with an incompatible data type, the 

              insertion for that record will fail. 
            example:
              cast:
                - Robin Williams
                - Jonathan Hyde
              director: Joe Johnston
              genres:
                - Adventure
                - Fantasy
                - Family
              popularity: 7.439
              adult: false
        additionalProperties: false
      ProductToProductsResponse:
        title: ProductToProductsResponse
        required:
          - data
        type: object
        properties:
          message:
            title: Message
            type: string
            default: success
          data:
            $ref: '#/components/schemas/ProductToProductsResponseBody'
      ProductToProductsResponseBody:
        title: ProductToProductsResponseBody
        required:
          - products
        type: object
        properties:
          took:
            title: Took
            type: integer
            description: Number of milliseconds Miso took to retrieve the results.
            default: 0
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            default: 00000000-0000-0000-0000-000000000000
            example: 123e4567-e89b-12d3-a456-426614174000
          products:
            title: Products
            type: array
            items:
              $ref: '#/components/schemas/Record'
            description: Product recommendation results.
      PromoPageView:
        title: promo_page_view
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - promo_page_view
            type: string
            description: >

              Used when a user views a specific promotional or curated marketing
              page about certain products or content.
          duration:
            title: Duration
            type: number
            description: >

              How long (in seconds) the user stayed on this page, or consumed
              (listened, read, or watched) a product. This field is

              optional, but it's very important in scenarios where consumption
              duration matters, including

              `product_detail_page_view`, `category_page_view`, `watch`, `listen`,
              and `read`. For example, if a user only

              views or consumes a product for less than 5 seconds, that user is
              probably not interested in the product. On

              the other hand, if a user stays on a page for a while, it usually
              means they are seriously engaging with or

              considering the product. When `duration` is absent, we will use the
              timestamp of the next interaction to

              infer a rough duration value.


              Example:

              ```

              {"duration": 61.5}

              ```
            example: 61.5
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      QAAutocompleteResponse:
        title: QAAutocompleteResponse
        required:
          - data
        type: object
        properties:
          message:
            title: Message
            type: string
            default: success
          data:
            $ref: '#/components/schemas/QAAutocompleteResponseBody'
        description: Autocomplete Response
      QAAutocompleteResponseBody:
        title: QAAutocompleteResponseBody
        required:
          - completions
        type: object
        properties:
          took:
            title: Took
            type: integer
            description: Number of milliseconds Miso took to retrieve the results.
            default: 0
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            default: 00000000-0000-0000-0000-000000000000
            example: 123e4567-e89b-12d3-a456-426614174000
          completions:
            title: Completions
            type: array
            items:
              $ref: '#/components/schemas/app__schemas__engine_api__response__Question'
        description: Autocomplete Response
      QAResponse:
        title: QAResponse
        required:
          - data
        type: object
        properties:
          message:
            title: Message
            type: string
            default: success
          data:
            $ref: '#/components/schemas/QAResponseBody'
      QAResponseBody:
        title: QAResponseBody
        required:
          - total
          - spellcheck
          - answers
        type: object
        properties:
          took:
            title: Took
            type: integer
            description: Number of milliseconds Miso took to retrieve the results.
            default: 0
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            default: 00000000-0000-0000-0000-000000000000
            example: 123e4567-e89b-12d3-a456-426614174000
          total:
            title: Total
            type: integer
            description: Total number of Question-Answer hits.
            example: 1000
          spellcheck:
            title: Spellcheck
            allOf:
              - $ref: '#/components/schemas/SpellCheckResponse'
            description: >-
              Spellcheck results. You can use the information in this object to
              prompt users with the correct spelling.
          answers:
            title: Answers
            type: array
            items:
              $ref: '#/components/schemas/RecordWithAnswer'
            description: The Question-Answer results.
      QueryFilter:
        title: QueryFilter
        required:
          - query
        type: object
        properties:
          query:
            title: Query
            type: string
            description: Query in Lucene syntax
          key:
            title: Key
            type: string
            description: User friendly label of the query result
      QueryFilterRequireKey:
        title: QueryFilterRequireKey
        required:
          - query
          - key
        type: object
        properties:
          query:
            title: Query
            type: string
            description: Query in Lucene syntax
          key:
            title: Key
            type: string
            description: User friendly label of the query result
      QuestionAnsweringRequest:
        title: QuestionAnsweringRequest
        required:
          - q
          - min_probability
        type: object
        properties:
          version:
            title: Version
            enum:
              - v1.2
              - v1.3
            description: >

              The model version to use.

              * **v1.2**: First stable version

              * **v1.3**: Improve keyword extraction that make answers more
              precise
            default: v1.2
            example: v1.2
          q:
            title: Q
            minLength: 1
            type: string
            description: The question user has entered.
            example: what is gradient descent
          min_probability:
            title: Min Probability
            maximum: 1
            minimum: 0
            type: number
            description: >

              Minimum acceptable probability (between 0.0 and 1.0). The answers
              whose probability is lower than this number will be excluded

              from the response.
            example: 0.7
          rows:
            title: Rows
            type: integer
            description: Number of search results to return.
            default: 1
          fl:
            title: Fl
            type: array
            items:
              type: string
            description: >

              List of fields to retrieve. Each Q&A response, by default, return
              two fields `answer` and `product_id`, where

              `answer` is an object with the information about the answer
              paragraph while

              `product_id` identifies the *Product* from which the answer is
              extracted.


              For example, the following is a sample response from the API:

              ```

              {
               "product_id": "ABC-123",
               "answer":
                {
                 "html": "<p>Python is an interpreted programming language</p>",
                 "text": "Python is an interpreted programming language",
                 "css_selector": ":root > div:nth-child(1) > p:nth-child(2)",
                 "probability": 0.99
                }
              }

              ```


              You can use `fl` parameter to retrieve additional product fields.
              For example, the following request

              additionally retrieves the `title` field for each product along

              with the `product_id` and `answer`, which are always returned.


              ```

              {"fl": ["title"]}

              ```


              You can also match field names by using `*` as a wildcard. For
              example, the query below retrieves the `title`

              and all the `custom_attributes` fields.


              ```

              {"fl": ["title", "custom_attributes.*"]}

              ```


              The following request retrieves all the available product fields:


              ```

              {"fl": ["*"]}

              ```


              For the lowest latency, use an empty array (which is the default) to
              retrieve just the `product_id` and `answer` fields.

              ```

              {"fl": []}

              ```
            default: []
          spellcheck:
            title: Spellcheck
            allOf:
              - $ref: '#/components/schemas/SpellCheckRequest'
            description: Spellcheck configuration
            default:
              enable_auto_spelling_correction: true
          enable_answer_html:
            title: Enable Answer Html
            type: boolean
            description: >-
              Whether to return HTML of the answer paragraph. If you don't need
              the HTML content of the
                      answer paragraph, setting this parameter to `false` will reduce the response size and lower the
                       response latency.
            default: false
          enable_answer_block:
            title: Enable Answer Block
            type: boolean
            description: >

              Whether to return *answer block*.

              In addition to answer paragraph, Miso can additionally return
              *answer block*.

              Answer block is an ancestor HTML node of the answer paragraph that
              contains the relevant context.

              The answer block is particularly useful for applications that not
              only want to show

              the answer itself but also the **context** surrounding the answer.


              Answer block is the smallest HTML element that contains the relevant
              context. However, not all the content

              inside this node is relevant. You can use the returned
              `relevant_children_slice` field

              to identify a portion of this node that is relevant to the answer.
            default: false
          fq:
            title: Fq
            type: string
            description: >


              Defines a query in Solr syntax that can be used to restrict the
              superset of

              products to return, without influencing the overall ranking. `fq`
              can enable users to drill down to products

              with specific features based on different product attributes


              For example, the query below limits the search results to only show
              products whose size is either `M` or `S` and

              brand is `Nike`:


              ```

              {"fq": "size:(\"M\" OR \"S\") AND brand:\"Nike\""}

              ```


              You can use `fq` to apply filters against your custom attributes as
              well. For example, the query below limits the

              search results to only products whose `designer` attribute is
              `Calvin Klein`


              ```

              {"fq": "attributes.designer:\"Calvin Klein\""}

              ```


              `fq` can also limit search results by numerical range. For example,
              the following query limits the results to

              products that have `rating >= 4`.


              ```

              {"fq": "rating:[4 TO *]"}

              ```
          boost_fq:
            title: Boost Fq
            type: string
            description: >

              Defines a query in Solr syntax that can be used to boost a subset of
              products to the top of the ranking, or to

              specific *boost positions* (See `boost_positions` parameter below.)

              For example, the query below will promote all the relevant products
              whose brand is `Nike` to the top of

              recommendation list:


              ```

              {
                  "boost_fq": "brand:\"Nike\""
              }

              ```


              For a slightly more complex example, the query below will promote
              the Nike products which have also been tagged

              as `ON SALE` to the top of the ranking:

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\""
              }

              ```

              It is worth mentioning that, Miso will only boost products that are
              relevant and have high likelihood to convert,

              and will not boost a low performance product only because it matches
              the boosting query.


              Depending on your boosting rules, in certain cases, you would like
              to prevent recommendation results from being

              too monotone due to boosting. With Miso, you have two tools to do
              so.


              First, you can specify `boost_positions` to place promoted products
              at specific positions in the ranking. For

              example, the query below will place boosted products only at the
              first and fourth places in the ranking

              (positions are 0-based), and place the remaining products in their
              original ranking, skipping these two positions.

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
                 "boost_positions": [0, 3]
              }

              ```


              The second tool is `diversification`. `diversification` parameter,
              on a best-effort basis, will try to

              maintain a minimum distance between products that have the same
              attributes. For example, the following query

              will place products made by the same brand apart from each other.

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
                 "diversification": {
                     "brand": {"minimum_distance": 1}
                  }
              }

              ```
          boost_positions:
            title: Boost Positions
            type: array
            items:
              type: integer
            description: >

              Defines a list of 0-based positions you want to place the boosted
              products at.


              For example, the query below will promote products whose brand is
              `Nike` as the top and second recommendations:

              ```

              {
                  "boost_fq": "brand:\"Nike\"",
                  "boost_positions": [0, 1]
              }

              ```

              If `boost_positions` is not specified (which is the default
              behavior), all the boosted products will be ranked

              higher than the rest of the products.
          boost_rules:
            title: Boost Rules
            type: array
            items:
              $ref: '#/components/schemas/BoostingFilterBase'
            description: >

              Define a list of boosting rules that will be applied to the search
              or recommendation results simultaneously. `boost_rules`

              parameter is particularly useful when you want to boost more than
              one sets of products, and promote each of them to different

              positions. For example, the query below will promote products whose
              brand is `Nike` to the top

              and second results, and products whose brand is `Adidas` to the
              third and fourth results:

              ```

              {
                  "boost_rules": [
                      {
                          "boost_fq": "brand:\"Nike\"",
                          "boost_positions": [0, 1]
                      },
                      {
                          "boost_fq": "brand:\"Adidas\"",
                          "boost_positions": [2, 3]
                      }
                  ]
              }

              ```
            default: []
          geo:
            title: Geo
            allOf:
              - $ref: '#/components/schemas/GeoQuery'
            description: >

              When set, filter result to include only products within certain
              geographic range from given point will be returned,

              or to boost product within the same range.


              Product should have a field that holds the location of the product,
              `location` is used by default,

              but other field can also be used.


              Distance can be in miles or kilometers. If `distance_unit` is not
              set, `mile` will be used.


              For example, to limit results to products within 100 miles of New
              York city:

              ```

              {
                  "geo": {
                      "filter": [{
                          "lat": 40.73061,
                          "lon": -73.93524,
                          "distance": 100
                      }]
                  }
              }

              ```


              To boost products within 2 kilometers around Alcatraz Island
              according to `loc` field:

              ```

              {
                  "geo": {
                      "boost": [{
                          "field": "loc",
                          "lat": 37.82667,
                          "lon": -122.42278,
                          "distance": 2,
                          "distance_unit": "km"
                      }]
                  }
              }

              ```
          boost_probability_threshold:
            title: Boost Probability Threshold
            type: number
            description: >

              Minimum probability required for an answer to be boosted. If not
              specified, the `min_probability` will be used.
      QuestionAutocompleteRequest:
        title: QuestionAutocompleteRequest
        required:
          - q
        type: object
        properties:
          q:
            title: Q
            minLength: 1
            type: string
            description: The query user has entered so far
            example: what is g
          rows:
            title: Rows
            type: integer
            description: Number of autocomplete results to return.
            default: 5
        description: Post question autocomplete request
      QuestionRequest:
        title: QuestionRequest
        required:
          - question
        type: object
        properties:
          user_id:
            title: User Id
            type: string
            description: >-
              The user who made the query. For an anonymous visitor, use
              `anonymous_id` instead.
          anonymous_id:
            title: Anonymous Id
            type: string
            description: The anonymous visitor who made this query.
          fq:
            title: Fq
            type: string
            description: >


              Defines a query in Solr syntax that can be used to restrict the
              superset of

              products to return, without influencing the overall ranking. `fq`
              can enable users to drill down to products

              with specific features based on different product attributes


              For example, the query below limits the search results to only show
              products whose size is either `M` or `S` and

              brand is `Nike`:


              ```

              {"fq": "size:(\"M\" OR \"S\") AND brand:\"Nike\""}

              ```


              You can use `fq` to apply filters against your custom attributes as
              well. For example, the query below limits the

              search results to only products whose `designer` attribute is
              `Calvin Klein`


              ```

              {"fq": "attributes.designer:\"Calvin Klein\""}

              ```


              `fq` can also limit search results by numerical range. For example,
              the following query limits the results to

              products that have `rating >= 4`.


              ```

              {"fq": "rating:[4 TO *]"}

              ```
          question:
            title: Question
            type: string
            description: The question for which an answer is requested.
          parent_question_id:
            title: Parent Question Id
            type: string
            description: >-
              The UUID of the parent question if the current question is a
              follow-up to a previous question.
            format: uuid
          yearly_decay:
            title: Yearly Decay
            type: number
            description: The yearly decay rate for the answer score.
            default: 0.93
          source_fl:
            title: Source Fl
            type: array
            items:
              type: string
            description: >+

              A list of fields to be returned for the `sources`. Any fields in
              uploaded product can be assigned, including fields in
              `custom_attributes`.


              If specificed field does not exist, that field will not be included
              in the result.

              If you use different schema for `custom_attributes` across different
              products, it is possible that not all returned sources has the some
              fields.


              For example, if you include `published_at` and `custom_attributes`
              in `source_fl`:


              ```json

              {
                  "question":"Explain Python GIL",
                  "source_fl":["published_at", "custom_attributes.rating"]
              }

              ```


              The answer will contain `published_at` field for each source:


              ```json

              {
                  "message": "success",
                  "data": {
                      "question": "Explain Python GIL",
                      "question_id": "57aeb083-b943-43b1-86ab-b6108788dd50",
                      "parent_question_id": null,
                      "answer_stage": "Generating summary",
                      "finished": true,
                      "answer": "# Explain Python GIL\n\n## Why do we need the GIL? [1]\n\nThe GIL is currently an essential part of the CPython...[omitted for simplicity]",
                      "sources": [
                          {
                              "published_at": "2022-05-20T00:00:00+00:00",
                              "custom_attributes": {
                                  "rating": 4.7
                              },
                              "product_id": "9781800207721",
                              "title": "Multiprocessing – When a Single CPU Core Is Not Enough",
                              "child_title": "Multiprocessing – When a Single CPU Core Is Not Enough",
                              "child_id": "16",
                              "snippet": "Remember the segmentation faults we saw in Chapter 11, ...[omitted]"
                          },
                          {
                              "published_at": "2015-02-26T00:00:00+00:00",
                              "custom_attributes": {
                                  "rating": 4.3
                              },
                              "product_id": "9780134034416",
                              "title": "5. Concurrency and Parallelism",
                              "child_title": "5. Concurrency and Parallelism",
                              "child_id": "12",
                              "snippet": "<mark>Click here to view code image\n...[omitted]</mark>"
                          },
                          {
                              "published_at": "2020-04-30T00:00:00+00:00",
                              "custom_attributes": {
                                  "rating": 3.5
                              },
                              "product_id": "9781492055013",
                              "title": "1. Understanding Performant Python",
                              "child_title": "1. Understanding Performant Python",
                              "child_id": "2",
                              "snippet": "<mark>Although it still locks Python into running ...[omitted]</mark>"
                          },
                          {
                              "published_at": "2019-11-15T00:00:00+00:00",
                              "custom_attributes": {
                                  "rating": 4.2
                              },
                              "product_id": "9780134854717",
                              "title": "7. Concurrency and Parallelism",
                              "child_title": "7. Concurrency and Parallelism",
                              "child_id": "16",
                              "snippet": "<mark>Although Python supports multiple threads of execution...[omitted]</mark>"
                          }
                      ],
                      "related_resources": []
                  }
              }

              ```

            default:
              - title
          related_resource_fl:
            title: Related Resource Fl
            type: array
            items:
              type: string
            description: >-
              A list of fields to be returned for the `related_resources`.
              Example: `['title', 'url']`.
            default:
              - title
          cite_start:
            title: Cite Start
            type: string
            description: 'The citation start marker. Example: `[` or `{`'
          cite_end:
            title: Cite End
            type: string
            description: 'The citation end marker. Example: `]` or `}`'
      QuestionResponse:
        title: QuestionResponse
        required:
          - data
        type: object
        properties:
          data:
            title: Data
            allOf:
              - $ref: '#/components/schemas/QuestionResponseData'
            description: Question response data.
          message:
            title: Message
            type: string
            description: Human-readable message.
            default: success
      QuestionResponseData:
        title: QuestionResponseData
        required:
          - question_id
        type: object
        properties:
          question_id:
            title: Question Id
            type: string
            description: The UUID for the submitted question.
            format: uuid
      Range:
        title: Range
        type: object
        properties:
          to:
            title: To
            anyOf:
              - type: string
              - type: number
            description: End of the range (exclusive).
          from:
            title: From
            anyOf:
              - type: string
              - type: number
            description: Start of the range (inclusive).
          key:
            title: Key
            type: string
            description: User friendly label of the range
      RangeRequireKey:
        title: RangeRequireKey
        required:
          - key
        type: object
        properties:
          to:
            title: To
            anyOf:
              - type: string
              - type: number
            description: End of the range (exclusive).
          from:
            title: From
            anyOf:
              - type: string
              - type: number
            description: Start of the range (inclusive).
          key:
            title: Key
            type: string
            description: User friendly label of the range
      Rate:
        title: rate
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - rate
            type: string
            description: |

              Used when a user gives a rating to a product or piece of content.
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
          rating:
            title: Rating
            type: number
            description: >

              The rating the user gave in the range of [0, 5]. This field is only
              required by the `rate` interaction. As a

              convention in the RecSys community, a rating >= 3.5 is considered
              positive, a rating <= 2 is negative,

              and otherwise a rating is neutral. If you use any other rating
              scale, please normalize it to a [0, 5] scale.
            example: 5
        additionalProperties: false
      Read:
        title: read
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - read
            type: string
            description: >

              Used to record when and for how long a user reads a piece of written
              content.
          duration:
            title: Duration
            type: number
            description: >

              How long (in seconds) the user stayed on this page, or consumed
              (listened, read, or watched) a product. This field is

              optional, but it's very important in scenarios where consumption
              duration matters, including

              `product_detail_page_view`, `category_page_view`, `watch`, `listen`,
              and `read`. For example, if a user only

              views or consumes a product for less than 5 seconds, that user is
              probably not interested in the product. On

              the other hand, if a user stays on a page for a while, it usually
              means they are seriously engaging with or

              considering the product. When `duration` is absent, we will use the
              timestamp of the next interaction to

              infer a rough duration value.


              Example:

              ```

              {"duration": 61.5}

              ```
            example: 61.5
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      RecResponse:
        title: RecResponse
        required:
          - data
        type: object
        properties:
          message:
            title: Message
            type: string
            default: success
          data:
            $ref: '#/components/schemas/BaseResponseBody'
      Record:
        title: Record
        required:
          - product_id
        type: object
        properties:
          product_id:
            title: Product Id
            maxLength: 512
            type: string
            description: |2-

                      The unique identifier for the product.
                      
            example: 123ABC-S-Black
      RecordWithAnswer:
        title: RecordWithAnswer
        required:
          - product_id
          - answer
        type: object
        properties:
          product_id:
            title: Product Id
            maxLength: 512
            type: string
            description: >-
              The unique identifier of the product whose content contains the
              answer.
          answer:
            title: Answer
            allOf:
              - $ref: '#/components/schemas/Answer'
            description: >-
              The answer paragraph (i.e. a `<p>` node) whose text content can
              answer users' question.
          answer_block:
            title: Answer Block
            allOf:
              - $ref: '#/components/schemas/AnswerBlock'
            description: |2-

                      In addition to the answer paragraph, we also return the **answer block**.
                      Answer block is the ancestor node of the answer paragraph that cover not only the answer, but also the relevant
                      context. This is particularly useful for applications that want to show
                      the answer itself but also the relevant context surrounding the answer.

                      Answer block is the smallest HTML element that contains the relevant context. However, not all the content
                      inside this node is relevant. You can use the `relevant_children_slice` to identify a portion inside this
                      block that is relevant to the answer.
                      
      RecordWithFound:
        title: RecordWithFound
        required:
          - product_id
        type: object
        properties:
          product_id:
            title: Product Id
            maxLength: 512
            type: string
            description: |2-

                      The unique identifier for the product.
                      
            example: 123ABC-S-Black
        description: >-
          Product record but support `_found=true / false` field. When
          _found=false,

          the product_id will not be available.
      Refund:
        title: refund
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - refund
            type: string
            description: |

              Used when a user requests a refund of products they bought.
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      RemoveFromCart:
        title: remove_from_cart
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - remove_from_cart
            type: string
            description: |

              Used when a user removes a product from their shopping cart.
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      RemoveFromCollection:
        title: remove_from_collection
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - remove_from_collection
            type: string
            description: |

              Used when a user removes a product from their personal collection.
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      Search:
        title: search
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - search
            type: string
            description: >

              Used to record a search event with the keywords and filters the user
              used. What a user searches for

              is a very powerful signal about their interests and what they will
              eventually buy or consume, so it is important

              to capture this information with high fidelity.
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
          search:
            title: Search
            allOf:
              - $ref: '#/components/schemas/SearchInformation'
            description: >

              The search keywords and filters the user uses. This is only required
              by `search` interaction.
        additionalProperties: false
      SearchInformation:
        title: SearchInformation
        type: object
        properties:
          keywords:
            title: Keywords
            type: string
            description: >

              The search keywords user use. Search keywords are strong signals to
              users' interests.
            default: ''
          filters:
            title: Filters
            type: object
            additionalProperties:
              type: array
              items:
                type: string
            description: >

              Dictionary of filters users apply to the search results in the
              following format:
               `{"FIELD": ["SELECTION_1", "SELECTION_2"]}`.
      SearchRequest:
        title: SearchRequest
        type: object
        properties:
          engine_id:
            title: Engine Id
            type: string
            description: >

              The engine you want to get results from. When you have more than one
              engine, you can use this parameter to

              specify the specific engine you want to get results from. If not
              specified, the default engine will be used.
          user_id:
            title: User Id
            type: string
            description: >

              The user who made the query and for whom Miso will personalize the
              results. For an anonymous visitor, use `anonymous_id` instead.
          anonymous_id:
            title: Anonymous Id
            type: string
            description: >-
              The anonymous visitor who made the query and for whom Miso will
              personalize the results. Either
                      `user_id` or `anonymous_id` needs to be specified for personalization to work. 
          user_hash:
            title: User Hash
            type: string
            description: >

              The hash of `user_id` (or `anonymous_id`) encrypted by your [Secret
              API Key](https://api.askmiso.com).

              `user_hash` is required to prevent unauthorized API access if you
              are

              making API calls with a [Publishable API
              Key](https://api.askmiso.com).


              You should generate the user_hash via HMAC scheme: you encrypt the
              desired user_id (or anonymous_id) with your

              [Secret API Key](https://api.askmiso.com) on your backend server,

              and then let the front-end code send the generated user_hash to Miso
              APIs to

              verify the identity of the API caller.


              As long as the [Secret API Key](https://api.askmiso.com)
               is kept secret, the user_hash prevents a malicious attacker from making unauthorized
              API calls or impersonating any of your users.


              Miso APIs accept the case-incentive "hex digest" of user hash, a
              sample Python 3 code to generate it on your backend server

              is as follow:


              ```python

              import hashlib

              import hmac


              YOUR_MISO_SECRET_API_KEY = "039c501ac8dfcac91"

              key_bytes = YOUR_MISO_SECRET_API_KEY.encode()

              user_id = "USER_123" # or anonymous_id

              user_id_bytes = user_id.encode()

              user_hash = hmac.new(
                  key_bytes,
                  user_id_bytes,
                  hashlib.sha256).hexdigest()
              # user_hash is "7eb04da5e..."

              ```


              You can find more examples for other languages in this [Github
              Gist](https://gist.github.com/thewheat/7342c76ade46e7322c3e)
          user_cohort:
            title: User Cohort
            type: object
            additionalProperties:
              anyOf:
                - type: boolean
                - type: string
            description: >

              The user cohort you want to cold-start the recommendation with. For
              example, the following query will make

              recommendations based on the preferences of the users whose
              `country="United States"`, and `gender="Female"`

              in the User Profile dataset.

              ```

              {
                  "user_cohort": {
                      "country": "United States",
                      "gender": "Female"
                  }
              }

              ```
          rows:
            title: Rows
            type: integer
            description: Number of search results to return.
            default: 5
          type:
            title: Type
            type: string
            description: >

              The type of products to return. Use this parameter to make the API
              return only

              a certain type of products (see [Product
              APIs](https://api.askmiso.com)).


              This is particularly useful for sites that have multiple types of
              products:

              For example, on a marketplace site, YOu may model *merchandise* and
              *store* as two types of *products*. You can

              then use type parameter to limit the recommendation or search
              results to return only one kind of them.


              For instance, the following query will return only *store* products:
               ```
              {"type": "store"}
               ```

              For another example, on a travel website, you might have: *hotel*,
              *thing to do*, and *restaurant*,

              three kinds

              of products. You can use `type` parameter to limit results to one
              kind of them. For instance, the following

              query will limit the results to only *hotels* product:
               ```
              {"type": "hotel"}
               ```
          dedupe_product_group_id:
            title: Dedupe Product Group Id
            type: boolean
            description: >

              Whether to dedupe product based on `product_group_id`. If
              `dedupe_product_group_id=true`,

              Miso will prevent products with the same `product_group_id` from
              showing multiple

              times in the search or recommendation results.



              This is particular useful when one product has multiple variants
              (for example, different

              sizes, colors, or materials), and you only want to show this product
              only once in the search or recommendation

              results. Miso will then return the variant that is most likely to be
              of the user's interest.
            default: true
          additional_interactions:
            title: Additional Interactions
            type: array
            items:
              anyOf:
                - $ref: '#/components/schemas/ProductDetailPageView'
                - $ref: '#/components/schemas/Search'
                - $ref: '#/components/schemas/AddToCart'
                - $ref: '#/components/schemas/RemoveFromCart'
                - $ref: '#/components/schemas/Checkout'
                - $ref: '#/components/schemas/Refund'
                - $ref: '#/components/schemas/Subscribe'
                - $ref: '#/components/schemas/AddToCollection'
                - $ref: '#/components/schemas/RemoveFromCollection'
                - $ref: '#/components/schemas/Read'
                - $ref: '#/components/schemas/Watch'
                - $ref: '#/components/schemas/Listen'
                - $ref: '#/components/schemas/Like'
                - $ref: '#/components/schemas/Dislike'
                - $ref: '#/components/schemas/Share'
                - $ref: '#/components/schemas/Rate'
                - $ref: '#/components/schemas/Bookmark'
                - $ref: '#/components/schemas/Complete'
                - $ref: '#/components/schemas/Feedback'
                - $ref: '#/components/schemas/Impression'
                - $ref: '#/components/schemas/ViewableImpression'
                - $ref: '#/components/schemas/Click'
                - $ref: '#/components/schemas/HomePageView'
                - $ref: '#/components/schemas/CategoryPageView'
                - $ref: '#/components/schemas/PromoPageView'
                - $ref: '#/components/schemas/ProductImageView'
                - $ref: '#/components/schemas/Custom'
            description: >

              A list of additional interaction records. You can use this fields to
              simulate user interactions without

              actually writing them to the interaction dataset.
            default: []
          fl:
            title: Fl
            type: array
            items:
              type: string
            description: >

              List of fields to retrieve. For example, the following request
              retrieves only the `title` field of each product along

              with the `product_id`, which is always returned.


              ```

              {"fl": ["title"]}

              ```


              You can also match field names by using `*` as a wildcard. For
              example, the query below retrieves the `title`

              and any custom attributes under the `attributes` dictionary.


              ```

              {"fl": ["title", "attributes.*"]}

              ```


              The following retrieves all the available fields:


              ```

              {"fl": ["*"]}

              ```


              For the lowest latency, use an empty array to retrieve just the
              `product_id` field (which is the default).

              ```

              {"fl": []}

              ```
            default: []
          exclude:
            title: Exclude
            type: array
            items:
              type: string
            description: >-
              An array of `product_ids` of products you want to *exclude* from
              search results.
          q:
            title: Q
            minLength: 1
            type: string
            description: >

              The search query the user has entered. Miso will perform full-text
              search and find any Products

              that contain every word in this query. You can also set `q="*"` to
              match all Products, which is commonly used along

              with Product filtering query `fq` to implement Category Pages.


              *(to make a search request, You need to specify either `q` or
              `advanced_q`)*
          advanced_q:
            title: Advanced Q
            minLength: 1
            type: string
            description: >

              Like Google's Advanced Search, the `advanced_q` parameter let you
              define query beyond simple full-text

              search. For one, you can use double-quotes to indicate a phrase
              search.


              For example, the following query will

              only match Products that contain the *phrase* "Toy Story 4", and
              will not match Products like "4 Toy Story"

              (because the word order is not the same as the given query).

              ```

              {"advanced_q": "full_text:\"Toy Story 4\""}

              ```


              If you don't want phrase search, you can enclose the search terms
              with parenthesis to indicate regular full-text query.

              For example:

              ```

              {"advanced_q": "full_text:(Toy Story 4)"}

              ```


              You can also use AND/OR boolean operators to combine multiple
              full-text queries. For example, the following query will match

              Products with phrases "Toy Story 4" and Products with phrases "Toy
              Story 3", and will not match "Toy Story 2" or "Toy Story 1":

              ```

              {"advanced_q":

              "full_text:\"Toy Story 4\" OR full_text:\"Toy Story 3\""}

              ```


              Finally, you can use AND/OR boolean operators to combine full-text
              search with metadata filtering.

              For example, the following example will find Products with phrase
              "Toy Story" OR Products which have Tom Hanks as an actor.

              ```

              {"advanced_q":

              "full_text:\"Toy Story\" OR
               custom_attributes.actors:\"Tom Hanks\""}
              ```


              *(to make a search request, You need to specify either `q` or
              `advanced_q`)*
          boosting_tags:
            title: Boosting Tags
            type: array
            items:
              type: string
            description: >

              When `boosting_tags` is given, and there are pre-defined boost rules
              have the same tag(s),

              those boost rules will be matched, regardless if the criteria is met
              or not.


              Useful when want to force trigger specific boost campaign.
            default: []
            example:
              - tag-1
              - quetag-2
          enable_boosting_campaigns:
            title: Enable Boosting Campaigns
            type: boolean
            description: >

              When set to true, enable user defined boosting campaigns.


              By default boosting campaigns are enabled. But you can explicitly
              set this to false to disable

              boosting campaigns.
            default: true
          custom_context:
            title: Custom Context
            type: object
            description: >

              Dictionary of custom context variables for the current browsing
              session. You can specify context variables

              specific to your websites or apps in a `{"KEY":VALUE}` format, where
              `KEY` must be a string, and `VALUE` can be:

              * a `bool`

              * a `string` or an `array of string`

              * a `number` or an `array of numbers`

              * an `array of objects`

              * `null`


              Miso will take these variables into account when generating
              recommendations.
            example:
              session_variable_1:
                - value_1
                - value_2
          language:
            title: Language
            type: string
            description: >

              Two-letter (639-1) language code of the search query. This parameter
              is useful when you have a multilingual
               product catalog that contains product metadata in different languages.
               If given, the search results will prioritize the products that have that specific language and match the search
                query. Example query:
              ```

              {"language": "fr"}

              ```


              If not given, Miso will search against all the languages in the
              catalog.
          like:
            title: Like
            type: string
            description: >-
              The text snippet that we want to find products that are similar to
              it
          category:
            title: Category
            type: array
            items:
              type: string
            description: >

              `category` parameter limits the search results to a particular
              category or sub-category.

              This is particularly suitable for implementing Category Pages where

              you want to show personalized ranking of Products under a specific
              category. Other filters, such as `q`,

              `fq`, `boost_fq` will be applied on top of the category filter.


              A category is represented by a list of strings that correspond to
              its category hierarchy.

              For example, the following query returns Products under `Snacks`
              category:

              ```

              {
                  "q": "*",
                  "category": ["Snacks"]
              }

              ```

              And the following request returns Products under `Snacks -> Chips`
              subcategory:

              ```

              {
                  "q": "*",
                  "category": ["Snacks", "Chips"]
              }

              ```
          spellcheck:
            title: Spellcheck
            allOf:
              - $ref: '#/components/schemas/SpellCheckRequest'
            description: Spellcheck configuration
            default:
              enable_auto_spelling_correction: true
          start:
            title: Start
            type: integer
            description: >

              Specifies an offset from which Miso will begin returning results.


              The default value is `0`.  Setting the start parameter to some other
              number, such as 3, causes Miso to skip over the

              preceding products and start from the product identified by the
              offset.
            default: 0
          order_by:
            title: Order By
            type: array
            items:
              $ref: '#/components/schemas/OrderByDefinition'
            description: >

              A list of fields that Miso should use to sort the result, instead of
              Miso's default ranking order.


              For example, the following query returns all the Products (because
              `q=*`), ranked by the `_personalization_score`

              first, and then by the values in the
              `custom_attributes.promote_score` field in the Product catalog, then
              the

              distance between the product and New York city.

              ```

              {
                  "q": "*",
                  "order_by": [
                      {
                          "field": "_personalization_score",
                          "tie_breaker": {
                              "type": "relative_difference",
                              "threshold": "0.05"
                          },
                          "order": "desc"
                      },
                      {
                          "field": "custom_attributes.promote_score",
                          "order": "desc"
                      },
                      {
                          "field": "_geo_distance",
                          "geo": {
                              "lat": 40.711967,
                              "lon": -74.006076,
                          }
                          "order": "asc"
                      }
                  ]
              }

              ```
            default: []
          facets:
            title: Facets
            type: array
            items:
              anyOf:
                - $ref: '#/components/schemas/FacetDefinition'
                - type: string
            description: >

              Specifies a list of fields to create facet search against. You can
              specify `facets` in a string array.

              For example, the following query return the facet counts for
              `categories`, `tags`, and `custom_attributes.director`:

              ```

              {
                "facets": [
                  "categories",
                  "tags",
                  "custom_attributes.director"
                ]
              }

              ```


              The response will be like:

              ```

              {
                "facet_counts": {
                  "facet_fields": {
                    "categories": [
                      [
                        "Drama", 20
                      ],
                      [
                        "Action", 10
                      ], ...
                    ],
                    "tags": [
                      [
                        "based on novel or book", 5
                      ],
                      [
                        "android", 4
                      ], ...
                    ],
                    "custom_attributes.director": [
                      [
                        "Ridley Scott", 26
                      ],
                      [
                        "Andrew Abbott", 1
                      ], ...
                  }
                }
              ```


              You can also specify `facets` with an object array to configure each
              facet individually.

              For example, the following query will return 20 most common facet
              values for `tags`

              and `custom_attributes.director` fields,

              and only the directors whose names start with `Ridley` will be
              included in the director facet results.

              ```

              {
                "facets": [
                  {
                    "field": "tags",
                    "size": 20
                  },
                  {
                    "field": "custom_attributes.director",
                    "size": 20,
                    "include": "Ridley.*"
                  }
                ]
              }

              ```
            default: []
          facet_filters:
            title: Facet Filters
            type: object
            additionalProperties:
              $ref: '#/components/schemas/Filter'
            description: >+

              Specifies filters to the search results based on users' selections
              in a faceted search UI.


              For example, assume you have two facets in your faceted search UI:
              `genres` and `custom_attributes.director`.

              When the user selects two options in the
              `custom_attributes.director` facet, you should send the following
              query to

              filter the search results for those two options (i.e. `Ridley Scott`
              or `Denis Villeneuve`).


              ```

              {
                "facets": [
                  {
                    "field": "genres",
                    "size": 5
                  },
                  {
                    "field": "custom_attributes.director",
                    "size": 20
                  }
                ],
                "facet_filters": {
                  "custom_attributes.director": {
                    "terms": [
                      "Ridley Scott",
                      "Denis Villeneuve"
                    ]
                  }
                },
              }

              ```


              While you can use `fq` parameter to achieve the same filtering
              capability,

              you should use `facet_filters` to get the correct facet counts.


              In a typical faceted search UI, the facet counts reflect the search
              result after applying

              filters from **all but the current facets**. For example, in the
              query below,

              the  *directors* facet counts
               should reflect the search result after applying the filter from the *genres* facet, i.e. `genres:Sci-Fi`.
               Similarly, *genres* facet counts should reflect the search result after applying the filter from the *directors* facet.

              `facet_filters` will make the resulting `facet_counts` follow this
              *all but except itself* convention, which is rather
               tricky to implement with `fq`.
              ```
                "facets": [
                  {
                    "field": "genres",
                    "size": 5
                  },
                  {
                    "field": "custom_attributes.director",
                    "size": 20
                  }
                ],
                "facet_filters": {
                  "custom_attributes.director": {
                    "terms": [
                      "Ridley Scott",
                      "Denis Villeneuve"
                    ]
                  }
                },
              }

              ```

            default: {}
          anchoring_settings:
            title: Anchoring Settings
            type: array
            items:
              $ref: '#/components/schemas/AnchoringEntry'
            description: >

              Promote a product to a position relative to the highest-ranked
              anchor product.


              A common use-case is promoting a private-label good by anchoring it
              to a name-brand counterpart. When the name-brand good (the anchor)
              appears in a search result, the private-label good also appears in
              the result (at a specified distance from the anchor product).


              The `anchoring_settings` object has the following fields:

              * **product_id** - The `product_id` of the product you want to
              promote.

              * **anchor_ids** - The array of `product_ids` that act as the
              anchors.

              * **relative_position** *(optional)* - The position that the
              promoted product will be returned in the search results, relative to
              the highest-ranked anchor product. For example, setting this
              parameter to `1` will place the promoted product directly after the
              anchor product. The default value is `-1`, which will place the
              promoted product directly before the anchor product.

              * **start_time** *(optional)* - An ISO-8601 timestamp indicating
              when to start the product anchoring. Ex: `2022-01-29T00:00:00Z`

              * **end_time** *(optional)* - An ISO-8601 timestamp indicating when
              to end the product anchoring. Ex: `2022-05-31T23:59:59Z`


              For example, if a user searches for "cookies", the API request might
              look like this:


              ```

              POST v1/search/search

              {
                  "q":"cookies",
                  "anchoring_settings": [
                   {
                       "product_id": "private_label_cookies",
                       "anchor_ids": [
                           "name_brand_cookies_1",
                           "name_brand_cookies_2"
                       ],
                       "relative_position": -1,
                       "start_time": "2022-01-01T00:00:00Z",
                       "end_time": "2022-12-31T23:59:59Z"
                       }
                   }
                  ]
              }

              ```
            default: []
          enable_partial_match:
            title: Enable Partial Match
            type: boolean
            description: >

              Enable *partial match* to return products that match only *some* of
              the keywords in a user's search query. By default,

              Miso's Search API only returns products that contain *all* the
              keywords in the search query (i.e. an AND operator over

              keywords). This strategy usually leads to highly relevant results.
              However, when we don't have enough search results to

              return to the users, enabling partial match allows the Search API to
              relax the criteria and return products that match

              only some of the keywords.


              This strategy is particularly useful to prevent users from seeing an
              empty search result page and abandoning their

              search.


              For example, let's consider the query request below:

              ```

              {
                "query": "Toy story 5",
                "enable_partial_match": true
              }

              ```

              Since there is no movie called "Toy story 5", we have zero products
              to return by default. However, because we set `enable_partial_match`
              to `true`, we will return other products that partially match the
              query:

              ```

              {

              "data": {
                  "products": [
                      {
                          "title": "Toy Story",
                          "_missing_keywords": ["5"]
                       },
                      {
                          "title": "Toy story 2",
                          "_missing_keywords": ["5"]
                      },
                      ...
                  ],
                  "total": 4
              }

              }

              ```

              As you can see from the result above, when we don't have the exact
              product that the user is looking for, enabling partial match is a
              helpful strategy to let users know what alternatives are available,
              and prevent them from seeing an empty search result page.
            default: false
          partial_match_mode:
            title: Partial Match Mode
            enum:
              - blended
              - separated
            description: >

              Determine which partial match mode to enable:
                 * **blended** (default): When `partial_match_mode` is `blended`, keyword-matched items and semantically-matched items will
              be returned in the same, rank-sorted array.
                 * **separated**: When `partial_match_mode` is `separated`, keyword-matched items will be returned in the `products` array
              and partially-matched or semantically-matched items will be returned
              in the `partially_matched_products` array.
            default: blended
          enable_partial_match_threshold:
            title: Enable Partial Match Threshold
            type: integer
            description: >

              If `partial_match_mode=separated`, you need to provide a value for
              `enable_partial_match_threshold`.

              This parameter, which accepts an integer (*n*), creates a condition
              for Miso’s Search Engine to only provide partially

              matched results if there are *n* or fewer exact keyword matches. For
              example, if we set `enable_partial_match_threshold=3`,

              partially matched results will *only* be returned when there are
              three or fewer exact keyword matches.
          enable_semantic_search:
            title: Enable Semantic Search
            type: boolean
            description: >

              Enable *semantic search* to return products that are semantically
              relevant to the search query.

              Semantic search is a powerful tool that further improves the partial
              match results. It finds products that might not contain

              any of the search keywords, but are highly relevant to users' search
              intent.


              For example, consider the query: `rubbing alcohol`, which is a
              household cleaning product. When `enable_semantic_search=true`,

              even if we do not have any products that match `rubbing alcohol`,
              Miso is still able to return results like the

              following:

              ```

              {

              "data": {
                  "products": [],
                  "total": 0,
                  "partially_matched_products": [
                      {
                          "title": "Clorox Disinfecting Wipes Multi-Surface Cleaning",
                          "_missing_keywords": ["rubbing", "alcohol"]
                       },
                      {
                          "title": "Purell Advanced Hand Sanitizer Refreshing Gel",
                          "_missing_keywords": ["rubbing", "alcohol"]
                      },
                      ...
                  ]
              }

              }

              ```

              Note that, these two products from Clorox or Purell do not contain
              any of the search keywords,

              Miso's semantic search functionality, however, is still able to
              identify them as good matches based on their semantic

              relevancy to the query `rubbing alcohol`.


              Similarly, consider a single word search query: `aspirin`. Normally,
              a single-word query will lead to an empty search

              page if we don't have products containing that word. However, when
              `enable_semantic_search=true`,

              even if we do not directly have `aspirin` in the product catalog,
              Miso is still able to return results that are highly

              relevant to users' search intent, such as:

              ```

              {

              "data": {
                  "products": [],
                  "total": 0,
                  "partially_matched_products": [
                      {
                          "title": "Advil Pain Reliever and Fever Reducer",
                          "_missing_keywords": ["aspirin"]
                       },
                      {
                          "title": "Tylenol Extra Strength Caplets",
                          "_missing_keywords": ["aspirin"]
                      },
                      ...
                  ]
              }

              }

              ```
            default: false
          semantic_search_threshold:
            title: Semantic Search Threshold
            type: number
            description: >

              Determine the threshold for semantic search. Only the products with
              a semantic similarity score higher than the

              threshold will be returned. Setting this too low (e.g. < 0.3) will
              result in less relevant results being returned.
            default: 0.5
          enable_matched_fields:
            title: Enable Matched Fields
            type: boolean
            description: >+

              Determine whether to return `_matched_fields` in the search response
              (default: false).

              If `enable_matched_fields=true`,

              each returned product will have an `_matched_fields` array that
              shows which parts of the product catalog match
               the search query.

               For example, the following request will return `_matched_fields`:
              ```

              {
                  "q": "toy story",
                  "enable_matched_fields": true
              }

              ```

              The response will be like:

              ```

              {
                  "data": {
                      "products": [
                          {
                              "title": "Toy Story",
                              "_matched_fields": ["title", "metadata"]
                           },
                           ...
                      ]
                  }
              }

              ```

              Currently, `_matched_fields` only contain three kinds of fields:
                 * `title`
                 * `description`
                 * `metadata`, including all the fields beyond title or description in the product catalog.

            default: false
          query_product_existence:
            title: Query Product Existence
            allOf:
              - $ref: '#/components/schemas/CheckProductExistence'
            description: >-
              Additionally check if certain products will be in the search result
              at all (regardless of `start` and `rows` parameters)
          personalization_weight:
            title: Personalization Weight
            maximum: 5
            minimum: 0
            type: integer
            description: Determines how much personalization will affect the search ranking.
            default: 5
          fq:
            title: Fq
            type: string
            description: >


              Defines a query in Solr syntax that can be used to restrict the
              superset of

              products to return, without influencing the overall ranking. `fq`
              can enable users to drill down to products

              with specific features based on different product attributes


              For example, the query below limits the search results to only show
              products whose size is either `M` or `S` and

              brand is `Nike`:


              ```

              {"fq": "size:(\"M\" OR \"S\") AND brand:\"Nike\""}

              ```


              You can use `fq` to apply filters against your custom attributes as
              well. For example, the query below limits the

              search results to only products whose `designer` attribute is
              `Calvin Klein`


              ```

              {"fq": "attributes.designer:\"Calvin Klein\""}

              ```


              `fq` can also limit search results by numerical range. For example,
              the following query limits the results to

              products that have `rating >= 4`.


              ```

              {"fq": "rating:[4 TO *]"}

              ```
          boost_fq:
            title: Boost Fq
            type: string
            description: >

              Defines a query in Solr syntax that can be used to boost a subset of
              products to the top of the ranking, or to

              specific *boost positions* (See `boost_positions` parameter below.)

              For example, the query below will promote all the relevant products
              whose brand is `Nike` to the top of

              recommendation list:


              ```

              {
                  "boost_fq": "brand:\"Nike\""
              }

              ```


              For a slightly more complex example, the query below will promote
              the Nike products which have also been tagged

              as `ON SALE` to the top of the ranking:

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\""
              }

              ```

              It is worth mentioning that, Miso will only boost products that are
              relevant and have high likelihood to convert,

              and will not boost a low performance product only because it matches
              the boosting query.


              Depending on your boosting rules, in certain cases, you would like
              to prevent recommendation results from being

              too monotone due to boosting. With Miso, you have two tools to do
              so.


              First, you can specify `boost_positions` to place promoted products
              at specific positions in the ranking. For

              example, the query below will place boosted products only at the
              first and fourth places in the ranking

              (positions are 0-based), and place the remaining products in their
              original ranking, skipping these two positions.

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
                 "boost_positions": [0, 3]
              }

              ```


              The second tool is `diversification`. `diversification` parameter,
              on a best-effort basis, will try to

              maintain a minimum distance between products that have the same
              attributes. For example, the following query

              will place products made by the same brand apart from each other.

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
                 "diversification": {
                     "brand": {"minimum_distance": 1}
                  }
              }

              ```
          boost_positions:
            title: Boost Positions
            type: array
            items:
              type: integer
            description: >

              Defines a list of 0-based positions you want to place the boosted
              products at.


              For example, the query below will promote products whose brand is
              `Nike` as the top and second recommendations:

              ```

              {
                  "boost_fq": "brand:\"Nike\"",
                  "boost_positions": [0, 1]
              }

              ```

              If `boost_positions` is not specified (which is the default
              behavior), all the boosted products will be ranked

              higher than the rest of the products.
          boost_rules:
            title: Boost Rules
            type: array
            items:
              $ref: '#/components/schemas/BoostingFilterBase'
            description: >

              Define a list of boosting rules that will be applied to the search
              or recommendation results simultaneously. `boost_rules`

              parameter is particularly useful when you want to boost more than
              one sets of products, and promote each of them to different

              positions. For example, the query below will promote products whose
              brand is `Nike` to the top

              and second results, and products whose brand is `Adidas` to the
              third and fourth results:

              ```

              {
                  "boost_rules": [
                      {
                          "boost_fq": "brand:\"Nike\"",
                          "boost_positions": [0, 1]
                      },
                      {
                          "boost_fq": "brand:\"Adidas\"",
                          "boost_positions": [2, 3]
                      }
                  ]
              }

              ```
            default: []
          geo:
            title: Geo
            allOf:
              - $ref: '#/components/schemas/GeoQuery'
            description: >

              When set, filter result to include only products within certain
              geographic range from given point will be returned,

              or to boost product within the same range.


              Product should have a field that holds the location of the product,
              `location` is used by default,

              but other field can also be used.


              Distance can be in miles or kilometers. If `distance_unit` is not
              set, `mile` will be used.


              For example, to limit results to products within 100 miles of New
              York city:

              ```

              {
                  "geo": {
                      "filter": [{
                          "lat": 40.73061,
                          "lon": -73.93524,
                          "distance": 100
                      }]
                  }
              }

              ```


              To boost products within 2 kilometers around Alcatraz Island
              according to `loc` field:

              ```

              {
                  "geo": {
                      "boost": [{
                          "field": "loc",
                          "lat": 37.82667,
                          "lon": -122.42278,
                          "distance": 2,
                          "distance_unit": "km"
                      }]
                  }
              }

              ```
          diversification:
            title: Diversification
            type: object
            additionalProperties:
              $ref: '#/components/schemas/DiversifyField'
            description: >


              Defines diversification rules to prevent products with the same
              attributes (e.g. sneakers made by the same brand

              or books from the same authors) from showing up too close to each
              other in the results.


              For instance, customers who have purchased many of sneakers from
              Nike may happen to have recommendations or

              search results where all top-5 entries are sneakers made by Nike.
              Purely considering accuracy, these

              recommendations appear excellent since the user clearly appreciates
              Nike sneakers. However,

              such results might be considered too "plain" by the user, owing to
              its lack of diversity.


              `diversification` parameter allows you to avoid this problem by
              enforcing a desired *minimum distance* between

              products. For example, consider a list of four products whose
              `brand` are *Nike, Nike, Adidas,* and *PUMA*

              respectively. The query below will make sure there are at least one
              different product between two Nike

              products, e.g. the diversified ranking may become *Nike, Adidas,
              Nike,* and *PUMA* :

              ```

              {
                 "diversification": {"brand": {"minimum_distance": 1}}
              }

              ```


              You can also increase the minimum_distance to place products further
              apart. For example, the following query will

              make sure, for the two Nike products, there are at least *two* other
              products between them.

              As a result, the diversified ranking may become *Nike, Adidas,
              PUMA*, and *Nike*.:

              ```

              {
                 "diversification": {"brand": {"minimum_distance": 2}}
              }

              ```


              The diversification algorithm reranks the products on a best-effort
              basis. For example, for the product list

              described earlier, it is not possible to place two Nike product
              three places apart from each other. Therefore,

              the diversified ranking will still remain *Nike, Adidas, PUMA,* and
              Nike* even if we set `minimum_distance=3`.
        additionalProperties: false
      SearchResponse:
        title: SearchResponse
        required:
          - data
        type: object
        properties:
          message:
            title: Message
            type: string
            default: success
          data:
            $ref: '#/components/schemas/SearchResponseBody'
      SearchResponseBody:
        title: SearchResponseBody
        required:
          - products
          - total
          - start
          - spellcheck
        type: object
        properties:
          took:
            title: Took
            type: integer
            description: Number of milliseconds Miso took to retrieve the results.
            default: 0
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            default: 00000000-0000-0000-0000-000000000000
            example: 123e4567-e89b-12d3-a456-426614174000
          products:
            title: Products
            type: array
            items:
              $ref: '#/components/schemas/PartialMatchedRecord'
            description: The search results.
          total:
            title: Total
            type: integer
            description: Total number of search hits.
            example: 1000
          start:
            title: Start
            type: integer
            description: Starting offset of the search results.
            example: 0
          spellcheck:
            title: Spellcheck
            allOf:
              - $ref: '#/components/schemas/SpellCheckResponse'
            description: >-
              Spellcheck results. You can use the information in this object to
              prompt users with the correct spelling.
          product_existence:
            title: Product Existence
            type: object
            additionalProperties:
              type: boolean
            description: Product existence query result
          partially_matched_products:
            title: Partially Matched Products
            type: array
            items:
              $ref: '#/components/schemas/PartialMatchedRecord'
            description: The search results that only partially match the search query.
          facet_counts:
            title: Facet Counts
            allOf:
              - $ref: '#/components/schemas/FacetCounts'
            description: Facet counts
            default: {}
          custom_assets:
            title: Custom Assets
            type: array
            items:
              type: object
            description: Custom JSON assets uploaded in Dojo.
            default: []
      SendExperimentResponse:
        title: SendExperimentResponse
        required:
          - took
          - in_experiment
          - variant
        type: object
        properties:
          took:
            title: Took
            type: integer
            description: >-
              The amount of time (in milliseconds) Miso took to answer this
              request.
            example: 50
          in_experiment:
            title: In Experiment
            type: boolean
            description: To show whether the experiment is active or not.
          variant:
            $ref: '#/components/schemas/VariantObject'
      Share:
        title: share
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - share
            type: string
            description: |

              Used when a user shares a product or piece of content.
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      SpellCheckRequest:
        title: SpellCheckRequest
        type: object
        properties:
          enable_auto_spelling_correction:
            title: Enable Auto Spelling Correction
            type: boolean
            description: >

              This parameter controls whether to automatically correct a misspell
              search query.

              If set to `true`, when Miso detects spelling errors, the search
              results will be based on the
               **corrected** spelling suggested by Miso.

              You call tell if Miso made any correction to the search query by
              checking the

              `spellcheck.auto_spelling_correction` field in the

              API response. When this field is `true`, the search results are
              based on the suggested spelling

              as opposed to the users' original query.


              You can opt-out the spelling correction by setting this parameter to
              `false`. In such cases,

              Miso will still detect spelling errors,

              but the search results will be always based on users' original
              spelling.
            default: true
      SpellCheckResponse:
        title: SpellCheckResponse
        required:
          - spelling_errors
          - auto_spelling_correction
          - original_query
          - original_query_with_markups
          - corrected_query
          - corrected_query_with_markups
        type: object
        properties:
          spelling_errors:
            title: Spelling Errors
            type: boolean
            description: Whether Miso detects any spelling errors.
          auto_spelling_correction:
            title: Auto Spelling Correction
            type: boolean
            description: >-
              Whether Miso has automatically corrected the misspelled search
              query. When this field is `true`, the search result is based on the
              corrected spelling in the `corrected_query` field instead of users'
              original search query.
          original_query:
            title: Original Query
            type: string
            description: Original query string
            example: what is pythn
          original_query_with_markups:
            title: Original Query With Markups
            type: string
            description: >-
              Original query with the spelling errors (if any) surrounded by the
              <mark> tags
            example: what is <mark>pythn</mark>
          corrected_query:
            title: Corrected Query
            type: string
            description: >-
              The corrected spelling suggested by Miso. If no spelling error is
              detected, this will be the same as `original_query`
            example: what is python
          corrected_query_with_markups:
            title: Corrected Query With Markups
            type: string
            description: >-
              The corrected spelling suggested by Miso where the revised tokens
              are surrounded by the <mark> tags.
            example: what is <mark>python</mark>
      Subscribe:
        title: subscribe
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - subscribe
            type: string
            description: >

              Used when a user subscribes a product, for example to receive alerts
              when the product comes back in stock or if the price drops.
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      TaskId:
        title: TaskId
        required:
          - task_id
        type: object
        properties:
          task_id:
            title: Task Id
            type: string
      TieBreakDefinition:
        title: TieBreakDefinition
        type: object
        properties:
          type:
            title: Type
            enum:
              - relative_difference
            default: relative_difference
          threshold:
            title: Threshold
            type: number
            default: 0
      TitleCompletion:
        title: TitleCompletion
        required:
          - text
          - text_with_markups
          - text_with_inverted_markups
          - product
        type: object
        properties:
          text:
            title: Text
            minLength: 1
            type: string
            example: Japanese Shiba Inu Dog Eating Miso Soup T-Shirt
          text_with_markups:
            title: Text With Markups
            minLength: 1
            type: string
            example: Japanese<mark> Shiba Inu Dog Eating Miso Soup T-Shirt</mark>
          text_with_inverted_markups:
            title: Text With Inverted Markups
            minLength: 1
            type: string
            example: <mark>Japanese</mark> Shiba Inu Dog Eating Miso Soup T-Shirt
          product:
            title: Product
            allOf:
              - $ref: '#/components/schemas/Record'
            example:
              product_id: 123ABC-S-Black
        description: title completion additionally has the `product` the title belongs to.
      TrendRecResponse:
        title: TrendRecResponse
        required:
          - data
        type: object
        properties:
          message:
            title: Message
            type: string
            default: success
          data:
            $ref: '#/components/schemas/TrendResponseBody'
      TrendResponseBody:
        title: TrendResponseBody
        required:
          - products
        type: object
        properties:
          took:
            title: Took
            type: integer
            description: Number of milliseconds Miso took to retrieve the results.
            default: 0
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            default: 00000000-0000-0000-0000-000000000000
            example: 123e4567-e89b-12d3-a456-426614174000
          products:
            title: Products
            type: array
            items:
              $ref: '#/components/schemas/Record'
            description: Trending product results.
      UserBulkDeleteIn:
        title: UserBulkDeleteIn
        required:
          - data
        type: object
        properties:
          data:
            $ref: '#/components/schemas/UserIdList'
      UserBulkIn:
        title: UserBulkIn
        required:
          - data
        type: object
        properties:
          data:
            title: Data
            type: array
            items:
              $ref: '#/components/schemas/UserRecord'
      UserIdList:
        title: UserIdList
        required:
          - user_ids
        type: object
        properties:
          user_ids:
            title: User Ids
            type: array
            items:
              type: string
      UserReadOut:
        title: UserReadOut
        required:
          - message
          - data
        type: object
        properties:
          message:
            title: Message
            type: string
            description: Human-readable message
            example: success
          data:
            $ref: '#/components/schemas/UserRecord'
      UserRecord:
        title: UserRecord
        required:
          - user_id
        type: object
        properties:
          user_id:
            title: User Id
            maxLength: 512
            minLength: 1
            type: string
            description: >

              Unique identifier for a user who has signed in. `user_id` can be in
              any format (e.g. users' email, internal user

              UUID or serial ID). The only restriction is that the first character
              must not be an underline `_`. Miso will use 

              this id to cross-reference your User records with your Interaction
              records.
            example: user_1234
          created_at:
            title: Created At
            anyOf:
              - type: string
                format: date-time
              - type: string
                format: date
            description: >

              The date the user’s account was created as an ISO-8601 date or
              datetime string. 
          updated_at:
            title: Updated At
            anyOf:
              - type: string
                format: date-time
              - type: string
                format: date
            description: >

              The date the user’s account was updated as an ISO-8601 date or
              datetime string. 
          name:
            title: Name
            type: string
            description: The user's full name.
            example: John Doe
          profile_image:
            title: Profile Image
            maxLength: 65536
            minLength: 1
            type: string
            description: URL to the profile image of the user.
            format: uri
          age:
            title: Age
            type: integer
            description: Age of the user. We will internally convert it to year of birth.
            example: 33
          gender:
            title: Gender
            type: string
            description: The user's gender.
            example: M
          city:
            title: City
            type: string
            description: City or zipcode the user is based in.
            example: Mountain View
          state:
            title: State
            type: string
            description: State the user is based in.
            example: California
          country:
            title: Country
            type: string
            description: Country the user is based in.
            example: US
          group_id:
            title: Group Id
            type: string
            description: >

              Group or Account ID from your CRM. This is useful in B2B scenarios.
              For example, you can use `group_id` to 

              associate a user with their company or account. We will use this
              information to infer the user's interests and 

              fine-tune their personalization and search results. For example,
              users from the same group might have similar 

              interests on the site, and we can improve their user experience
              accordingly
            example: Northwind Corp
          description:
            title: Description
            type: string
            description: >

              Text description of the user. This can be the user's own bio or the
              internal notes about the user. If available,

              Miso will analyze this description to better profile a user.  
            example: Engineer from Northwind Corp
          custom_attributes:
            title: Custom Attributes
            type: object
            additionalProperties:
              anyOf:
                - type: boolean
                - type: integer
                - type: number
                - type: string
                - type: array
                  items:
                    type: number
                - type: array
                  items:
                    type: string
                - type: array
                  items:
                    type: object
                    additionalProperties:
                      anyOf:
                        - type: string
                        - type: number
                        - type: integer
                        - type: boolean
            description: >

              Dictionary of custom attributes about the user. As with the [Product
              API](#operation/content_write_api_v1_products_post

              ), you can specify attributes specific to your business in a `{"KEY"
              : VALUE}` format, where `KEY` must be a string, and
               `VALUE` can be:
              * a `string` or `an array of strings`

              * a `number` or `an array of numbers`

              * an `array of objects`

              * a `bool`

              * `null` 


              * Example:

              ```

              {
                  "custom_attributes": {
                      "acquisition_channel": "Facebook Campaign 2020",
                      "declared_interests": ["Drama", "Romance"]
                  }
              }

              ```

              These custom attributes types must be consistent across all User
              records in your data set. 

              Records with inconsistent types will fail to be inserted.
            example:
              acquisition_channel: Facebook Campaign 2020
              declared_interests:
                - Drama
                - Romance
        additionalProperties: false
      UserToAttributes:
        title: UserToAttributes
        required:
          - field
        type: object
        properties:
          boosting_tags:
            title: Boosting Tags
            type: array
            items:
              type: string
            description: >

              When `boosting_tags` is given, and there are pre-defined boost rules
              have the same tag(s),

              those boost rules will be matched, regardless if the criteria is met
              or not.


              Useful when want to force trigger specific boost campaign.
            default: []
            example:
              - tag-1
              - quetag-2
          field:
            title: Field
            type: string
            description: >


              The attribute you want to make recommendations for. For example, the
              following

              query will recommend values from the `brand` field that Miso thinks
              the user will be interested in:


              ```

              {"field": "brand"}

              ```


              This API also works for custom attributes you define. For example,

              if you provide a `designer` custom attribute, then, you can make
              `designer` recommendations with the following query.

              ```

              {"field": "custom_attributes.designer"}

              ```
          boost_attributes:
            title: Boost Attributes
            type: array
            items:
              type: string
            description: |+


              The attributes to boost to the top of the recommendations

            default: []
          exclude_attributes:
            title: Exclude Attributes
            type: array
            items:
              type: string
            description: |+


              The attributes to remove from the recommendations

            default: []
          rows:
            title: Rows
            type: integer
            description: Number of product recommendations to return
            default: 5
          products_per_attribute:
            title: Products Per Attribute
            type: integer
            description: >

              Number of personalized product recommendations to make for **each**
              recommended attribute. For example, the following

              query will return 5 products for each *brand* we recommend:

              ```

              {
                  "field": "brand",
                  "products_per_attribute": 2
              }

              ```


              Note that a large number of `products_per_attribute` will increase
              latency slightly because we need to

              perform more computation for each of the recommended attributes. If
              you only need attribute

              recommendations, you can set

              `products_per_attribute=0` to reduce latency.
            default: 2
          engine_id:
            title: Engine Id
            type: string
            description: >

              The engine you want to get results from. When you have more than one
              engine, you can use this parameter to

              specify the specific engine you want to get results from. If not
              specified, the default engine will be used.
          user_id:
            title: User Id
            type: string
            description: >

              The user who made the query and for whom Miso will personalize the
              results. For an anonymous visitor, use `anonymous_id` instead.
          anonymous_id:
            title: Anonymous Id
            type: string
            description: >-
              The anonymous visitor who made the query and for whom Miso will
              personalize the results. Either
                      `user_id` or `anonymous_id` needs to be specified for personalization to work. 
          user_hash:
            title: User Hash
            type: string
            description: >

              The hash of `user_id` (or `anonymous_id`) encrypted by your [Secret
              API Key](https://api.askmiso.com).

              `user_hash` is required to prevent unauthorized API access if you
              are

              making API calls with a [Publishable API
              Key](https://api.askmiso.com).


              You should generate the user_hash via HMAC scheme: you encrypt the
              desired user_id (or anonymous_id) with your

              [Secret API Key](https://api.askmiso.com) on your backend server,

              and then let the front-end code send the generated user_hash to Miso
              APIs to

              verify the identity of the API caller.


              As long as the [Secret API Key](https://api.askmiso.com)
               is kept secret, the user_hash prevents a malicious attacker from making unauthorized
              API calls or impersonating any of your users.


              Miso APIs accept the case-incentive "hex digest" of user hash, a
              sample Python 3 code to generate it on your backend server

              is as follow:


              ```python

              import hashlib

              import hmac


              YOUR_MISO_SECRET_API_KEY = "039c501ac8dfcac91"

              key_bytes = YOUR_MISO_SECRET_API_KEY.encode()

              user_id = "USER_123" # or anonymous_id

              user_id_bytes = user_id.encode()

              user_hash = hmac.new(
                  key_bytes,
                  user_id_bytes,
                  hashlib.sha256).hexdigest()
              # user_hash is "7eb04da5e..."

              ```


              You can find more examples for other languages in this [Github
              Gist](https://gist.github.com/thewheat/7342c76ade46e7322c3e)
          user_cohort:
            title: User Cohort
            type: object
            additionalProperties:
              anyOf:
                - type: boolean
                - type: string
            description: >

              The user cohort you want to cold-start the recommendation with. For
              example, the following query will make

              recommendations based on the preferences of the users whose
              `country="United States"`, and `gender="Female"`

              in the User Profile dataset.

              ```

              {
                  "user_cohort": {
                      "country": "United States",
                      "gender": "Female"
                  }
              }

              ```
          type:
            title: Type
            type: string
            description: >

              The type of products to return. Use this parameter to make the API
              return only

              a certain type of products (see [Product
              APIs](https://api.askmiso.com)).


              This is particularly useful for sites that have multiple types of
              products:

              For example, on a marketplace site, YOu may model *merchandise* and
              *store* as two types of *products*. You can

              then use type parameter to limit the recommendation or search
              results to return only one kind of them.


              For instance, the following query will return only *store* products:
               ```
              {"type": "store"}
               ```

              For another example, on a travel website, you might have: *hotel*,
              *thing to do*, and *restaurant*,

              three kinds

              of products. You can use `type` parameter to limit results to one
              kind of them. For instance, the following

              query will limit the results to only *hotels* product:
               ```
              {"type": "hotel"}
               ```
          dedupe_product_group_id:
            title: Dedupe Product Group Id
            type: boolean
            description: >

              Whether to dedupe product based on `product_group_id`. If
              `dedupe_product_group_id=true`,

              Miso will prevent products with the same `product_group_id` from
              showing multiple

              times in the search or recommendation results.



              This is particular useful when one product has multiple variants
              (for example, different

              sizes, colors, or materials), and you only want to show this product
              only once in the search or recommendation

              results. Miso will then return the variant that is most likely to be
              of the user's interest.
            default: true
          additional_interactions:
            title: Additional Interactions
            type: array
            items:
              anyOf:
                - $ref: '#/components/schemas/ProductDetailPageView'
                - $ref: '#/components/schemas/Search'
                - $ref: '#/components/schemas/AddToCart'
                - $ref: '#/components/schemas/RemoveFromCart'
                - $ref: '#/components/schemas/Checkout'
                - $ref: '#/components/schemas/Refund'
                - $ref: '#/components/schemas/Subscribe'
                - $ref: '#/components/schemas/AddToCollection'
                - $ref: '#/components/schemas/RemoveFromCollection'
                - $ref: '#/components/schemas/Read'
                - $ref: '#/components/schemas/Watch'
                - $ref: '#/components/schemas/Listen'
                - $ref: '#/components/schemas/Like'
                - $ref: '#/components/schemas/Dislike'
                - $ref: '#/components/schemas/Share'
                - $ref: '#/components/schemas/Rate'
                - $ref: '#/components/schemas/Bookmark'
                - $ref: '#/components/schemas/Complete'
                - $ref: '#/components/schemas/Feedback'
                - $ref: '#/components/schemas/Impression'
                - $ref: '#/components/schemas/ViewableImpression'
                - $ref: '#/components/schemas/Click'
                - $ref: '#/components/schemas/HomePageView'
                - $ref: '#/components/schemas/CategoryPageView'
                - $ref: '#/components/schemas/PromoPageView'
                - $ref: '#/components/schemas/ProductImageView'
                - $ref: '#/components/schemas/Custom'
            description: >

              A list of additional interaction records. You can use this fields to
              simulate user interactions without

              actually writing them to the interaction dataset.
            default: []
          fl:
            title: Fl
            type: array
            items:
              type: string
            description: >

              List of fields to retrieve. For example, the following request
              retrieves only the `title` field of each product along

              with the `product_id`, which is always returned.


              ```

              {"fl": ["title"]}

              ```


              You can also match field names by using `*` as a wildcard. For
              example, the query below retrieves the `title`

              and any custom attributes under the `attributes` dictionary.


              ```

              {"fl": ["title", "attributes.*"]}

              ```


              The following retrieves all the available fields:


              ```

              {"fl": ["*"]}

              ```


              For the lowest latency, use an empty array to retrieve just the
              `product_id` field (which is the default).

              ```

              {"fl": []}

              ```
            default: []
          exclude:
            title: Exclude
            type: array
            items:
              type: string
            description: >-
              An array of `product_ids` of products you want to *exclude* from
              search results.
          fq:
            title: Fq
            type: string
            description: >


              Defines a query in Solr syntax that can be used to restrict the
              superset of

              products to return, without influencing the overall ranking. `fq`
              can enable users to drill down to products

              with specific features based on different product attributes


              For example, the query below limits the search results to only show
              products whose size is either `M` or `S` and

              brand is `Nike`:


              ```

              {"fq": "size:(\"M\" OR \"S\") AND brand:\"Nike\""}

              ```


              You can use `fq` to apply filters against your custom attributes as
              well. For example, the query below limits the

              search results to only products whose `designer` attribute is
              `Calvin Klein`


              ```

              {"fq": "attributes.designer:\"Calvin Klein\""}

              ```


              `fq` can also limit search results by numerical range. For example,
              the following query limits the results to

              products that have `rating >= 4`.


              ```

              {"fq": "rating:[4 TO *]"}

              ```
          boost_fq:
            title: Boost Fq
            type: string
            description: >

              Defines a query in Solr syntax that can be used to boost a subset of
              products to the top of the ranking, or to

              specific *boost positions* (See `boost_positions` parameter below.)

              For example, the query below will promote all the relevant products
              whose brand is `Nike` to the top of

              recommendation list:


              ```

              {
                  "boost_fq": "brand:\"Nike\""
              }

              ```


              For a slightly more complex example, the query below will promote
              the Nike products which have also been tagged

              as `ON SALE` to the top of the ranking:

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\""
              }

              ```

              It is worth mentioning that, Miso will only boost products that are
              relevant and have high likelihood to convert,

              and will not boost a low performance product only because it matches
              the boosting query.


              Depending on your boosting rules, in certain cases, you would like
              to prevent recommendation results from being

              too monotone due to boosting. With Miso, you have two tools to do
              so.


              First, you can specify `boost_positions` to place promoted products
              at specific positions in the ranking. For

              example, the query below will place boosted products only at the
              first and fourth places in the ranking

              (positions are 0-based), and place the remaining products in their
              original ranking, skipping these two positions.

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
                 "boost_positions": [0, 3]
              }

              ```


              The second tool is `diversification`. `diversification` parameter,
              on a best-effort basis, will try to

              maintain a minimum distance between products that have the same
              attributes. For example, the following query

              will place products made by the same brand apart from each other.

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
                 "diversification": {
                     "brand": {"minimum_distance": 1}
                  }
              }

              ```
          boost_positions:
            title: Boost Positions
            type: array
            items:
              type: integer
            description: >

              Defines a list of 0-based positions you want to place the boosted
              products at.


              For example, the query below will promote products whose brand is
              `Nike` as the top and second recommendations:

              ```

              {
                  "boost_fq": "brand:\"Nike\"",
                  "boost_positions": [0, 1]
              }

              ```

              If `boost_positions` is not specified (which is the default
              behavior), all the boosted products will be ranked

              higher than the rest of the products.
          boost_rules:
            title: Boost Rules
            type: array
            items:
              $ref: '#/components/schemas/BoostingFilterBase'
            description: >

              Define a list of boosting rules that will be applied to the search
              or recommendation results simultaneously. `boost_rules`

              parameter is particularly useful when you want to boost more than
              one sets of products, and promote each of them to different

              positions. For example, the query below will promote products whose
              brand is `Nike` to the top

              and second results, and products whose brand is `Adidas` to the
              third and fourth results:

              ```

              {
                  "boost_rules": [
                      {
                          "boost_fq": "brand:\"Nike\"",
                          "boost_positions": [0, 1]
                      },
                      {
                          "boost_fq": "brand:\"Adidas\"",
                          "boost_positions": [2, 3]
                      }
                  ]
              }

              ```
            default: []
          geo:
            title: Geo
            allOf:
              - $ref: '#/components/schemas/GeoQuery'
            description: >

              When set, filter result to include only products within certain
              geographic range from given point will be returned,

              or to boost product within the same range.


              Product should have a field that holds the location of the product,
              `location` is used by default,

              but other field can also be used.


              Distance can be in miles or kilometers. If `distance_unit` is not
              set, `mile` will be used.


              For example, to limit results to products within 100 miles of New
              York city:

              ```

              {
                  "geo": {
                      "filter": [{
                          "lat": 40.73061,
                          "lon": -73.93524,
                          "distance": 100
                      }]
                  }
              }

              ```


              To boost products within 2 kilometers around Alcatraz Island
              according to `loc` field:

              ```

              {
                  "geo": {
                      "boost": [{
                          "field": "loc",
                          "lat": 37.82667,
                          "lon": -122.42278,
                          "distance": 2,
                          "distance_unit": "km"
                      }]
                  }
              }

              ```
        additionalProperties: false
        description: >-
          User to attributes recommendations. Given a user, recommend

          product attributes the user will be interested in as well as products in
          those attributes
      UserToCategories:
        title: UserToCategories
        type: object
        properties:
          engine_id:
            title: Engine Id
            type: string
            description: >

              The engine you want to get results from. When you have more than one
              engine, you can use this parameter to

              specify the specific engine you want to get results from. If not
              specified, the default engine will be used.
          user_id:
            title: User Id
            type: string
            description: >

              The user who made the query and for whom Miso will personalize the
              results. For an anonymous visitor, use `anonymous_id` instead.
          anonymous_id:
            title: Anonymous Id
            type: string
            description: >-
              The anonymous visitor who made the query and for whom Miso will
              personalize the results. Either
                      `user_id` or `anonymous_id` needs to be specified for personalization to work. 
          user_hash:
            title: User Hash
            type: string
            description: >

              The hash of `user_id` (or `anonymous_id`) encrypted by your [Secret
              API Key](https://api.askmiso.com).

              `user_hash` is required to prevent unauthorized API access if you
              are

              making API calls with a [Publishable API
              Key](https://api.askmiso.com).


              You should generate the user_hash via HMAC scheme: you encrypt the
              desired user_id (or anonymous_id) with your

              [Secret API Key](https://api.askmiso.com) on your backend server,

              and then let the front-end code send the generated user_hash to Miso
              APIs to

              verify the identity of the API caller.


              As long as the [Secret API Key](https://api.askmiso.com)
               is kept secret, the user_hash prevents a malicious attacker from making unauthorized
              API calls or impersonating any of your users.


              Miso APIs accept the case-incentive "hex digest" of user hash, a
              sample Python 3 code to generate it on your backend server

              is as follow:


              ```python

              import hashlib

              import hmac


              YOUR_MISO_SECRET_API_KEY = "039c501ac8dfcac91"

              key_bytes = YOUR_MISO_SECRET_API_KEY.encode()

              user_id = "USER_123" # or anonymous_id

              user_id_bytes = user_id.encode()

              user_hash = hmac.new(
                  key_bytes,
                  user_id_bytes,
                  hashlib.sha256).hexdigest()
              # user_hash is "7eb04da5e..."

              ```


              You can find more examples for other languages in this [Github
              Gist](https://gist.github.com/thewheat/7342c76ade46e7322c3e)
          user_cohort:
            title: User Cohort
            type: object
            additionalProperties:
              anyOf:
                - type: boolean
                - type: string
            description: >

              The user cohort you want to cold-start the recommendation with. For
              example, the following query will make

              recommendations based on the preferences of the users whose
              `country="United States"`, and `gender="Female"`

              in the User Profile dataset.

              ```

              {
                  "user_cohort": {
                      "country": "United States",
                      "gender": "Female"
                  }
              }

              ```
          rows:
            title: Rows
            type: integer
            description: Number of recommended categories to return
            default: 5
          type:
            title: Type
            type: string
            description: >

              The type of products to return. Use this parameter to make the API
              return only

              a certain type of products (see [Product
              APIs](https://api.askmiso.com)).


              This is particularly useful for sites that have multiple types of
              products:

              For example, on a marketplace site, YOu may model *merchandise* and
              *store* as two types of *products*. You can

              then use type parameter to limit the recommendation or search
              results to return only one kind of them.


              For instance, the following query will return only *store* products:
               ```
              {"type": "store"}
               ```

              For another example, on a travel website, you might have: *hotel*,
              *thing to do*, and *restaurant*,

              three kinds

              of products. You can use `type` parameter to limit results to one
              kind of them. For instance, the following

              query will limit the results to only *hotels* product:
               ```
              {"type": "hotel"}
               ```
          dedupe_product_group_id:
            title: Dedupe Product Group Id
            type: boolean
            description: >

              Whether to dedupe product based on `product_group_id`. If
              `dedupe_product_group_id=true`,

              Miso will prevent products with the same `product_group_id` from
              showing multiple

              times in the search or recommendation results.



              This is particular useful when one product has multiple variants
              (for example, different

              sizes, colors, or materials), and you only want to show this product
              only once in the search or recommendation

              results. Miso will then return the variant that is most likely to be
              of the user's interest.
            default: true
          additional_interactions:
            title: Additional Interactions
            type: array
            items:
              anyOf:
                - $ref: '#/components/schemas/ProductDetailPageView'
                - $ref: '#/components/schemas/Search'
                - $ref: '#/components/schemas/AddToCart'
                - $ref: '#/components/schemas/RemoveFromCart'
                - $ref: '#/components/schemas/Checkout'
                - $ref: '#/components/schemas/Refund'
                - $ref: '#/components/schemas/Subscribe'
                - $ref: '#/components/schemas/AddToCollection'
                - $ref: '#/components/schemas/RemoveFromCollection'
                - $ref: '#/components/schemas/Read'
                - $ref: '#/components/schemas/Watch'
                - $ref: '#/components/schemas/Listen'
                - $ref: '#/components/schemas/Like'
                - $ref: '#/components/schemas/Dislike'
                - $ref: '#/components/schemas/Share'
                - $ref: '#/components/schemas/Rate'
                - $ref: '#/components/schemas/Bookmark'
                - $ref: '#/components/schemas/Complete'
                - $ref: '#/components/schemas/Feedback'
                - $ref: '#/components/schemas/Impression'
                - $ref: '#/components/schemas/ViewableImpression'
                - $ref: '#/components/schemas/Click'
                - $ref: '#/components/schemas/HomePageView'
                - $ref: '#/components/schemas/CategoryPageView'
                - $ref: '#/components/schemas/PromoPageView'
                - $ref: '#/components/schemas/ProductImageView'
                - $ref: '#/components/schemas/Custom'
            description: >

              A list of additional interaction records. You can use this fields to
              simulate user interactions without

              actually writing them to the interaction dataset.
            default: []
          fl:
            title: Fl
            type: array
            items:
              type: string
            description: >

              List of fields to retrieve. For example, the following request
              retrieves only the `title` field of each product along

              with the `product_id`, which is always returned.


              ```

              {"fl": ["title"]}

              ```


              You can also match field names by using `*` as a wildcard. For
              example, the query below retrieves the `title`

              and any custom attributes under the `attributes` dictionary.


              ```

              {"fl": ["title", "attributes.*"]}

              ```


              The following retrieves all the available fields:


              ```

              {"fl": ["*"]}

              ```


              For the lowest latency, use an empty array to retrieve just the
              `product_id` field (which is the default).

              ```

              {"fl": []}

              ```
            default: []
          exclude:
            title: Exclude
            type: array
            items:
              type: string
            description: >-
              An array of `product_ids` of products you want to *exclude* from
              search results.
          boosting_tags:
            title: Boosting Tags
            type: array
            items:
              type: string
            description: >

              When `boosting_tags` is given, and there are pre-defined boost rules
              have the same tag(s),

              those boost rules will be matched, regardless if the criteria is met
              or not.


              Useful when want to force trigger specific boost campaign.
            default: []
            example:
              - tag-1
              - quetag-2
          products_per_category:
            title: Products Per Category
            type: integer
            description: >-


              Number of products to return for **each** category. For example, the
              following

              query will return 5 products for each category we recommend:

              ```

              {"products": 5}

              ```

              Note that, a large number of `products_per_category` (say >= 20)
              will increase query latency (up to around 200ms)

              because we need to perform more computation for each of the
              recommended categories. If you

              only need category recommendations, you should set
              `products_per_category` to 0 to reduce latency.
            default: 5
          root_category:
            title: Root Category
            type: array
            items:
              type: string
            description: >-

              If `root_category` is specified, we will only recommend categories
              that are direct children of each of the root

              category. For example, the following query will recommend the
              products of category that is under `["Clothes"]` category:

              ```

              {"root_category": ["Clothes"]}

              ```

              For another example, the following query will recommend the products
              of category that is under `["Clothes", "Dresses"]` category

              ```

              {"root_category": ["Clothes", "Dresses"]}

              ```

              If `root_category` is not specified, we will recommend the *top
              level* categories. 
            default: []
          fq:
            title: Fq
            type: string
            description: >


              Defines a query in Solr syntax that can be used to restrict the
              superset of

              products to return, without influencing the overall ranking. `fq`
              can enable users to drill down to products

              with specific features based on different product attributes


              For example, the query below limits the search results to only show
              products whose size is either `M` or `S` and

              brand is `Nike`:


              ```

              {"fq": "size:(\"M\" OR \"S\") AND brand:\"Nike\""}

              ```


              You can use `fq` to apply filters against your custom attributes as
              well. For example, the query below limits the

              search results to only products whose `designer` attribute is
              `Calvin Klein`


              ```

              {"fq": "attributes.designer:\"Calvin Klein\""}

              ```


              `fq` can also limit search results by numerical range. For example,
              the following query limits the results to

              products that have `rating >= 4`.


              ```

              {"fq": "rating:[4 TO *]"}

              ```
          boost_fq:
            title: Boost Fq
            type: string
            description: >

              Defines a query in Solr syntax that can be used to boost a subset of
              products to the top of the ranking, or to

              specific *boost positions* (See `boost_positions` parameter below.)

              For example, the query below will promote all the relevant products
              whose brand is `Nike` to the top of

              recommendation list:


              ```

              {
                  "boost_fq": "brand:\"Nike\""
              }

              ```


              For a slightly more complex example, the query below will promote
              the Nike products which have also been tagged

              as `ON SALE` to the top of the ranking:

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\""
              }

              ```

              It is worth mentioning that, Miso will only boost products that are
              relevant and have high likelihood to convert,

              and will not boost a low performance product only because it matches
              the boosting query.


              Depending on your boosting rules, in certain cases, you would like
              to prevent recommendation results from being

              too monotone due to boosting. With Miso, you have two tools to do
              so.


              First, you can specify `boost_positions` to place promoted products
              at specific positions in the ranking. For

              example, the query below will place boosted products only at the
              first and fourth places in the ranking

              (positions are 0-based), and place the remaining products in their
              original ranking, skipping these two positions.

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
                 "boost_positions": [0, 3]
              }

              ```


              The second tool is `diversification`. `diversification` parameter,
              on a best-effort basis, will try to

              maintain a minimum distance between products that have the same
              attributes. For example, the following query

              will place products made by the same brand apart from each other.

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
                 "diversification": {
                     "brand": {"minimum_distance": 1}
                  }
              }

              ```
          boost_positions:
            title: Boost Positions
            type: array
            items:
              type: integer
            description: >

              Defines a list of 0-based positions you want to place the boosted
              products at.


              For example, the query below will promote products whose brand is
              `Nike` as the top and second recommendations:

              ```

              {
                  "boost_fq": "brand:\"Nike\"",
                  "boost_positions": [0, 1]
              }

              ```

              If `boost_positions` is not specified (which is the default
              behavior), all the boosted products will be ranked

              higher than the rest of the products.
          boost_rules:
            title: Boost Rules
            type: array
            items:
              $ref: '#/components/schemas/BoostingFilterBase'
            description: >

              Define a list of boosting rules that will be applied to the search
              or recommendation results simultaneously. `boost_rules`

              parameter is particularly useful when you want to boost more than
              one sets of products, and promote each of them to different

              positions. For example, the query below will promote products whose
              brand is `Nike` to the top

              and second results, and products whose brand is `Adidas` to the
              third and fourth results:

              ```

              {
                  "boost_rules": [
                      {
                          "boost_fq": "brand:\"Nike\"",
                          "boost_positions": [0, 1]
                      },
                      {
                          "boost_fq": "brand:\"Adidas\"",
                          "boost_positions": [2, 3]
                      }
                  ]
              }

              ```
            default: []
          geo:
            title: Geo
            allOf:
              - $ref: '#/components/schemas/GeoQuery'
            description: >

              When set, filter result to include only products within certain
              geographic range from given point will be returned,

              or to boost product within the same range.


              Product should have a field that holds the location of the product,
              `location` is used by default,

              but other field can also be used.


              Distance can be in miles or kilometers. If `distance_unit` is not
              set, `mile` will be used.


              For example, to limit results to products within 100 miles of New
              York city:

              ```

              {
                  "geo": {
                      "filter": [{
                          "lat": 40.73061,
                          "lon": -73.93524,
                          "distance": 100
                      }]
                  }
              }

              ```


              To boost products within 2 kilometers around Alcatraz Island
              according to `loc` field:

              ```

              {
                  "geo": {
                      "boost": [{
                          "field": "loc",
                          "lat": 37.82667,
                          "lon": -122.42278,
                          "distance": 2,
                          "distance_unit": "km"
                      }]
                  }
              }

              ```
        additionalProperties: false
        description: Attributes for recommendation boosting
      UserToItemsRequest:
        title: UserToItemsRequest
        type: object
        properties:
          engine_id:
            title: Engine Id
            type: string
            description: >

              The engine you want to get results from. When you have more than one
              engine, you can use this parameter to

              specify the specific engine you want to get results from. If not
              specified, the default engine will be used.
          user_id:
            title: User Id
            type: string
            description: >

              The user who made the query and for whom Miso will personalize the
              results. For an anonymous visitor, use `anonymous_id` instead.
          anonymous_id:
            title: Anonymous Id
            type: string
            description: >-
              The anonymous visitor who made the query and for whom Miso will
              personalize the results. Either
                      `user_id` or `anonymous_id` needs to be specified for personalization to work. 
          user_hash:
            title: User Hash
            type: string
            description: >

              The hash of `user_id` (or `anonymous_id`) encrypted by your [Secret
              API Key](https://api.askmiso.com).

              `user_hash` is required to prevent unauthorized API access if you
              are

              making API calls with a [Publishable API
              Key](https://api.askmiso.com).


              You should generate the user_hash via HMAC scheme: you encrypt the
              desired user_id (or anonymous_id) with your

              [Secret API Key](https://api.askmiso.com) on your backend server,

              and then let the front-end code send the generated user_hash to Miso
              APIs to

              verify the identity of the API caller.


              As long as the [Secret API Key](https://api.askmiso.com)
               is kept secret, the user_hash prevents a malicious attacker from making unauthorized
              API calls or impersonating any of your users.


              Miso APIs accept the case-incentive "hex digest" of user hash, a
              sample Python 3 code to generate it on your backend server

              is as follow:


              ```python

              import hashlib

              import hmac


              YOUR_MISO_SECRET_API_KEY = "039c501ac8dfcac91"

              key_bytes = YOUR_MISO_SECRET_API_KEY.encode()

              user_id = "USER_123" # or anonymous_id

              user_id_bytes = user_id.encode()

              user_hash = hmac.new(
                  key_bytes,
                  user_id_bytes,
                  hashlib.sha256).hexdigest()
              # user_hash is "7eb04da5e..."

              ```


              You can find more examples for other languages in this [Github
              Gist](https://gist.github.com/thewheat/7342c76ade46e7322c3e)
          user_cohort:
            title: User Cohort
            type: object
            additionalProperties:
              anyOf:
                - type: boolean
                - type: string
            description: >

              The user cohort you want to cold-start the recommendation with. For
              example, the following query will make

              recommendations based on the preferences of the users whose
              `country="United States"`, and `gender="Female"`

              in the User Profile dataset.

              ```

              {
                  "user_cohort": {
                      "country": "United States",
                      "gender": "Female"
                  }
              }

              ```
          rows:
            title: Rows
            type: integer
            description: Number of product recommendations to return
            default: 5
          type:
            title: Type
            type: string
            description: >

              The type of products to return. Use this parameter to make the API
              return only

              a certain type of products (see [Product
              APIs](https://api.askmiso.com)).


              This is particularly useful for sites that have multiple types of
              products:

              For example, on a marketplace site, YOu may model *merchandise* and
              *store* as two types of *products*. You can

              then use type parameter to limit the recommendation or search
              results to return only one kind of them.


              For instance, the following query will return only *store* products:
               ```
              {"type": "store"}
               ```

              For another example, on a travel website, you might have: *hotel*,
              *thing to do*, and *restaurant*,

              three kinds

              of products. You can use `type` parameter to limit results to one
              kind of them. For instance, the following

              query will limit the results to only *hotels* product:
               ```
              {"type": "hotel"}
               ```
          dedupe_product_group_id:
            title: Dedupe Product Group Id
            type: boolean
            description: >

              Whether to dedupe product based on `product_group_id`. If
              `dedupe_product_group_id=true`,

              Miso will prevent products with the same `product_group_id` from
              showing multiple

              times in the search or recommendation results.



              This is particular useful when one product has multiple variants
              (for example, different

              sizes, colors, or materials), and you only want to show this product
              only once in the search or recommendation

              results. Miso will then return the variant that is most likely to be
              of the user's interest.
            default: true
          additional_interactions:
            title: Additional Interactions
            type: array
            items:
              anyOf:
                - $ref: '#/components/schemas/ProductDetailPageView'
                - $ref: '#/components/schemas/Search'
                - $ref: '#/components/schemas/AddToCart'
                - $ref: '#/components/schemas/RemoveFromCart'
                - $ref: '#/components/schemas/Checkout'
                - $ref: '#/components/schemas/Refund'
                - $ref: '#/components/schemas/Subscribe'
                - $ref: '#/components/schemas/AddToCollection'
                - $ref: '#/components/schemas/RemoveFromCollection'
                - $ref: '#/components/schemas/Read'
                - $ref: '#/components/schemas/Watch'
                - $ref: '#/components/schemas/Listen'
                - $ref: '#/components/schemas/Like'
                - $ref: '#/components/schemas/Dislike'
                - $ref: '#/components/schemas/Share'
                - $ref: '#/components/schemas/Rate'
                - $ref: '#/components/schemas/Bookmark'
                - $ref: '#/components/schemas/Complete'
                - $ref: '#/components/schemas/Feedback'
                - $ref: '#/components/schemas/Impression'
                - $ref: '#/components/schemas/ViewableImpression'
                - $ref: '#/components/schemas/Click'
                - $ref: '#/components/schemas/HomePageView'
                - $ref: '#/components/schemas/CategoryPageView'
                - $ref: '#/components/schemas/PromoPageView'
                - $ref: '#/components/schemas/ProductImageView'
                - $ref: '#/components/schemas/Custom'
            description: >

              A list of additional interaction records. You can use this fields to
              simulate user interactions without

              actually writing them to the interaction dataset.
            default: []
          fl:
            title: Fl
            type: array
            items:
              type: string
            description: >

              List of fields to retrieve. For example, the following request
              retrieves only the `title` field of each product along

              with the `product_id`, which is always returned.


              ```

              {"fl": ["title"]}

              ```


              You can also match field names by using `*` as a wildcard. For
              example, the query below retrieves the `title`

              and any custom attributes under the `attributes` dictionary.


              ```

              {"fl": ["title", "attributes.*"]}

              ```


              The following retrieves all the available fields:


              ```

              {"fl": ["*"]}

              ```


              For the lowest latency, use an empty array to retrieve just the
              `product_id` field (which is the default).

              ```

              {"fl": []}

              ```
            default: []
          exclude:
            title: Exclude
            type: array
            items:
              type: string
            description: >-
              An array of `product_ids` of products you want to *exclude* from
              search results.
          boosting_tags:
            title: Boosting Tags
            type: array
            items:
              type: string
            description: >

              When `boosting_tags` is given, and there are pre-defined boost rules
              have the same tag(s),

              those boost rules will be matched, regardless if the criteria is met
              or not.


              Useful when want to force trigger specific boost campaign.
            default: []
            example:
              - tag-1
              - quetag-2
          fq:
            title: Fq
            type: string
            description: >


              Defines a query in Solr syntax that can be used to restrict the
              superset of

              products to return, without influencing the overall ranking. `fq`
              can enable users to drill down to products

              with specific features based on different product attributes


              For example, the query below limits the search results to only show
              products whose size is either `M` or `S` and

              brand is `Nike`:


              ```

              {"fq": "size:(\"M\" OR \"S\") AND brand:\"Nike\""}

              ```


              You can use `fq` to apply filters against your custom attributes as
              well. For example, the query below limits the

              search results to only products whose `designer` attribute is
              `Calvin Klein`


              ```

              {"fq": "attributes.designer:\"Calvin Klein\""}

              ```


              `fq` can also limit search results by numerical range. For example,
              the following query limits the results to

              products that have `rating >= 4`.


              ```

              {"fq": "rating:[4 TO *]"}

              ```
          boost_fq:
            title: Boost Fq
            type: string
            description: >

              Defines a query in Solr syntax that can be used to boost a subset of
              products to the top of the ranking, or to

              specific *boost positions* (See `boost_positions` parameter below.)

              For example, the query below will promote all the relevant products
              whose brand is `Nike` to the top of

              recommendation list:


              ```

              {
                  "boost_fq": "brand:\"Nike\""
              }

              ```


              For a slightly more complex example, the query below will promote
              the Nike products which have also been tagged

              as `ON SALE` to the top of the ranking:

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\""
              }

              ```

              It is worth mentioning that, Miso will only boost products that are
              relevant and have high likelihood to convert,

              and will not boost a low performance product only because it matches
              the boosting query.


              Depending on your boosting rules, in certain cases, you would like
              to prevent recommendation results from being

              too monotone due to boosting. With Miso, you have two tools to do
              so.


              First, you can specify `boost_positions` to place promoted products
              at specific positions in the ranking. For

              example, the query below will place boosted products only at the
              first and fourth places in the ranking

              (positions are 0-based), and place the remaining products in their
              original ranking, skipping these two positions.

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
                 "boost_positions": [0, 3]
              }

              ```


              The second tool is `diversification`. `diversification` parameter,
              on a best-effort basis, will try to

              maintain a minimum distance between products that have the same
              attributes. For example, the following query

              will place products made by the same brand apart from each other.

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
                 "diversification": {
                     "brand": {"minimum_distance": 1}
                  }
              }

              ```
          boost_positions:
            title: Boost Positions
            type: array
            items:
              type: integer
            description: >

              Defines a list of 0-based positions you want to place the boosted
              products at.


              For example, the query below will promote products whose brand is
              `Nike` as the top and second recommendations:

              ```

              {
                  "boost_fq": "brand:\"Nike\"",
                  "boost_positions": [0, 1]
              }

              ```

              If `boost_positions` is not specified (which is the default
              behavior), all the boosted products will be ranked

              higher than the rest of the products.
          boost_rules:
            title: Boost Rules
            type: array
            items:
              $ref: '#/components/schemas/BoostingFilterBase'
            description: >

              Define a list of boosting rules that will be applied to the search
              or recommendation results simultaneously. `boost_rules`

              parameter is particularly useful when you want to boost more than
              one sets of products, and promote each of them to different

              positions. For example, the query below will promote products whose
              brand is `Nike` to the top

              and second results, and products whose brand is `Adidas` to the
              third and fourth results:

              ```

              {
                  "boost_rules": [
                      {
                          "boost_fq": "brand:\"Nike\"",
                          "boost_positions": [0, 1]
                      },
                      {
                          "boost_fq": "brand:\"Adidas\"",
                          "boost_positions": [2, 3]
                      }
                  ]
              }

              ```
            default: []
          geo:
            title: Geo
            allOf:
              - $ref: '#/components/schemas/GeoQuery'
            description: >

              When set, filter result to include only products within certain
              geographic range from given point will be returned,

              or to boost product within the same range.


              Product should have a field that holds the location of the product,
              `location` is used by default,

              but other field can also be used.


              Distance can be in miles or kilometers. If `distance_unit` is not
              set, `mile` will be used.


              For example, to limit results to products within 100 miles of New
              York city:

              ```

              {
                  "geo": {
                      "filter": [{
                          "lat": 40.73061,
                          "lon": -73.93524,
                          "distance": 100
                      }]
                  }
              }

              ```


              To boost products within 2 kilometers around Alcatraz Island
              according to `loc` field:

              ```

              {
                  "geo": {
                      "boost": [{
                          "field": "loc",
                          "lat": 37.82667,
                          "lon": -122.42278,
                          "distance": 2,
                          "distance_unit": "km"
                      }]
                  }
              }

              ```
          diversification:
            title: Diversification
            type: object
            additionalProperties:
              $ref: '#/components/schemas/DiversifyField'
            description: >


              Defines diversification rules to prevent products with the same
              attributes (e.g. sneakers made by the same brand

              or books from the same authors) from showing up too close to each
              other in the results.


              For instance, customers who have purchased many of sneakers from
              Nike may happen to have recommendations or

              search results where all top-5 entries are sneakers made by Nike.
              Purely considering accuracy, these

              recommendations appear excellent since the user clearly appreciates
              Nike sneakers. However,

              such results might be considered too "plain" by the user, owing to
              its lack of diversity.


              `diversification` parameter allows you to avoid this problem by
              enforcing a desired *minimum distance* between

              products. For example, consider a list of four products whose
              `brand` are *Nike, Nike, Adidas,* and *PUMA*

              respectively. The query below will make sure there are at least one
              different product between two Nike

              products, e.g. the diversified ranking may become *Nike, Adidas,
              Nike,* and *PUMA* :

              ```

              {
                 "diversification": {"brand": {"minimum_distance": 1}}
              }

              ```


              You can also increase the minimum_distance to place products further
              apart. For example, the following query will

              make sure, for the two Nike products, there are at least *two* other
              products between them.

              As a result, the diversified ranking may become *Nike, Adidas,
              PUMA*, and *Nike*.:

              ```

              {
                 "diversification": {"brand": {"minimum_distance": 2}}
              }

              ```


              The diversification algorithm reranks the products on a best-effort
              basis. For example, for the product list

              described earlier, it is not possible to place two Nike product
              three places apart from each other. Therefore,

              the diversified ranking will still remain *Nike, Adidas, PUMA,* and
              Nike* even if we set `minimum_distance=3`.
          pagination_id:
            title: Pagination Id
            maxLength: 512
            type: string
            description: >

              A unique identifier to enable pagination in Recommendation APIs. By
              default, Recommendation APIs do not support

              pagination because the results from Miso, by its natural, will
              change in real-time with new user interactions.

              `pagination_id` allows you to implement pagination more easily by
              memorize what products we have

              returned to the current user with the same `pagination_id`.


              To enable pagination, you generate a `pagination_id` and set it in
              the first and subsequent requests in the same browsing session

              where you want to enable pagination. With `pagination_id` set, you
              can access recommendations

              in different pages using the combination of `start` and `rows`
              parameters, and Miso will ensure that no duplicated

              recommendation will be returned in different pages.


              For example, assuming you are implementing an infinite scroll with
              Miso Recommendation APIs. Before you make the first request,

              you generate a `pagination_id` using the `current datetime` or
              `uuid` like the following:

              ```javascript

              // current datetime

              var my_pagination_id = Date.now().toString()

              // OR uuid

              const uuidv4 = require("uuid/v4")

              var my_pagination_id = uuidv4()

              ```

              You can then request the first page of results with
              `my_pagination_id` like the following:

              ```javascript

              {
                  "pagination_id": my_pagination_id,
                  "start": 0,
                  "rows": 10
              }

              ```

              Then, you can request the next page of results with the same
              `my_pagination_id`, and Miso will ensure

              that no duplicated result is returned:

              ```javascript

              {
                  "pagination_id": my_pagination_id,
                  "start": 10,
                  "rows": 10
              }

              ```


              Note that, a `pagination_id` will timeout if there is no further
              request associated with it for 30 minutes.

              Also, `pagination_id` is scoped by individual users: i.e. different
              users' results will not be affected

              even if they use the same `pagination_id`.
          start:
            title: Start
            type: integer
            description: >

              The start of the page you want to access. Combine this with `rows`
              to implement pagination. You can only set it when `pagination_id` is
              given.
            default: 0
        additionalProperties: false
        description: Attributes for recommendation boosting
      ValidationError:
        title: ValidationError
        required:
          - loc
          - msg
          - type
        type: object
        properties:
          loc:
            title: Location
            type: array
            items:
              type: string
          msg:
            title: Message
            type: string
          type:
            title: Error Type
            type: string
      VariantObject:
        title: VariantObject
        required:
          - id
          - name
          - slug
          - status
        type: object
        properties:
          id:
            title: Id
            type: string
            description: The UUID of this variant.
            example: 59769b89-5f1f-46d5-a4fa-a583ebd2f7fd
          name:
            title: Name
            type: string
            description: The name of this variant.
            example: Treatment_Group
          slug:
            title: Slug
            type: string
            description: The slug name of this variant.
            example: Treatment_Group
          configuration:
            title: Configuration
            anyOf:
              - type: object
              - type: array
                items: {}
              - type: string
            description: The configuration of this variant.
            example:
              model: A
          status:
            title: Status
            enum:
              - Draft
              - Scheduled
              - Active
              - Completed
              - Archived
            type: string
            description: The current status for this variant.
            example: Active
      ViewableImpression:
        title: viewable_impression
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - viewable_impression
            type: string
            description: >

              When a product or content asset is presented to the user, it is not
              guarantee that the user will see it.


              An viewable impression is an impression that is "viewable" by the
              user.

              Usually, content asset is considered viewable if more than 50% of
              its area is visible on screen.


              You can also use different definition for what is considered
              viewable.

              Miso will automatically find the best recommendation as long as the
              difference between

              viewable and non-viewable impression is consistant.
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      Watch:
        title: watch
        required:
          - type
        type: object
        properties:
          type:
            title: Type
            enum:
              - watch
            type: string
            description: >

              Used to record when and for how long a user watches content that is
              of a video format.
          duration:
            title: Duration
            type: number
            description: >

              How long (in seconds) the user stayed on this page, or consumed
              (listened, read, or watched) a product. This field is

              optional, but it's very important in scenarios where consumption
              duration matters, including

              `product_detail_page_view`, `category_page_view`, `watch`, `listen`,
              and `read`. For example, if a user only

              views or consumes a product for less than 5 seconds, that user is
              probably not interested in the product. On

              the other hand, if a user stays on a page for a while, it usually
              means they are seriously engaging with or

              considering the product. When `duration` is absent, we will use the
              timestamp of the next interaction to

              infer a rough duration value.


              Example:

              ```

              {"duration": 61.5}

              ```
            example: 61.5
          product_ids:
            title: Product Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              Products or content the user is interacting with. This field is
              required by

              almost all the interaction types. We use `product_ids` to refer to
              the product / content records that you upload to Miso.

              Therefore, it is important to keep this consistent between the two
              datasets.


              Example:

              ```

              {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

              ```
            default: []
            example:
              - 123ABC-BLACK
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
              maxLength: 512
            description: >

              The product groups the user is interacting with. You only need this
              field if you model product

              variants using `product_id` and `product_group_id` (see Product
              API). If so, you should use this field, when a

              user is interacting with a *product group* rather than a specific
              product variant, for example, when the user

              is viewing the master page of a T-shirt (i.e. a product group), but
              has not selected the specific size or

              color (i.e. a product variant) yet.


              In such situations, the `product_id` is not applicable because we
              only know the user is interested in

              this T-shirt (a product group), but don't know which particular
              product variant the user is interested in.

              Therefore, we use `product_group_ids` to capture such interactions
              in place of `product_ids`.


              In the situations where specific `product_ids` are available, for
              example, when user selected a particular size

              of the T-Shirt, use `product_ids` instead.



              Example:

              ```

              {"product_group_ids": ["123ABC"]}

              ```
            example:
              - 123ABC
          user_id:
            title: User Id
            maxLength: 512
            type: string
            description: >-
              Identifies the signed-in user who performed the interaction. We will
              use `user_id` to link Interaction records to your
                      User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                      not signed in, see `anonymous_id`.
            example: user_1234
          anonymous_id:
            title: Anonymous Id
            maxLength: 1024
            type: string
            description: >-
              A pseudo-unique substitute for the User Id. We use `anonymous_id` to
              identify a visitor who has not signed
                      in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                      is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                      in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                      along with the past interactions associated with it.
            example: 86D51273AD8BF84217E1567B6CBE7152D7034404
          timestamp:
            title: Timestamp
            type: string
            description: >

              The ISO-8601 timestamp specifying when the interaction occurred. If
              the interaction just happened, leave it out and we

              will default to the server's time. If you're importing data from the
              past, make sure you provide a

              timestamp. It is recommended to include milliseconds in the
              timestamp to provide a higher time resolution.


              Example:

              ```

              {"timestamp": "2018-11-07T00:25:00.073876Z"}

              ```
            format: date-time
          miso_id:
            title: Miso Id
            type: string
            description: >

              Miso-generated unique Id for each recommendation or search result.
              Maintaining this Id for

              subsequent page views is important to Miso's performance, as we use
              `miso_id` to track and fine-tune the

              performance of personalization and search results. When a user
              clicks on a recommendation or search result,

              you should pass the associated `miso_id` to the next page view, and
              associate the `miso_id` with the

              interactions that take place on the page (e.g.
              `product_detail_page_view`, `add_to_cart`,

              `add_to_collection`, `like`, etc.). In this way, Miso will learn
              which recommendations work and which didn't.


              Example:

              ```

              {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

              ```
            format: uuid
            example: 123e4567-e89b-12d3-a456-426614174000
          context:
            title: Context
            allOf:
              - $ref: '#/components/schemas/WebBasedContext'
            description: >

              Dictionary of extra information that provides useful context about
              an interaction. We use context

              information to make recommendations tailored not only for each user,
              but also for their current browsing context.

              For example, a user browsing on a desktop may have different
              browsing behavior than a user browsing on mobile

              phone. As another example, a user who gets to the site via a certain
              campaign you run on Facebook may have very

              different interests than a user who visits your site directly.


              Context information is also useful for personalization for entirely
              new visitors, as we can immediately

              personalize their experiences based on their context alone (e.g. the
              referrer or the campaign they clicked through).


              Example:

              ```

              {"context": {
                  "campaign":
                  {
                      "name": "spring_sale",
                      "source": "Google",
                      "medium": "cpc",
                      "term": "running+shoes",
                      "content": "textlink"
                  },
                  "truncated_ip": "1.1.1.0",
                  "locale": "en-US",
                  "region": "US East",
                  "page":
                      {
                          "url": "https://example.com/miso-tshirt-123ABC",
                          "referrer": "https://example.com/",
                          "title": "My Product Page"
                      },
                      "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                  },
                  "custom_context": {
                      "other_context_var_1": "value_1",
                      "other_context_var_2": "value_2"
                  }
              }

              ```
        additionalProperties: false
      WebBasedContext:
        title: WebBasedContext
        type: object
        properties:
          campaign:
            title: Campaign
            allOf:
              - $ref: '#/components/schemas/Campaign'
            description: >

              The campaign that resulted in the interaction. Campaign dictionary
              contains standard UTM parameters: `name`,

              `source`, `medium`, `term`, `content`. We use campaign information
              to infer users' interests and fine-tune the

              personalization and search results based on the current user's
              campaign information.
          truncated_ip:
            title: Truncated Ip
            type: string
            description: >

              User's truncated IP address. We use IP address to determine the
              country of the users.
            format: ipv4
            example: 1.1.1.0
          locale:
            title: Locale
            type: string
            description: Locale string of the current session, for example en-US.
            example: en-US
          region:
            title: Region
            type: string
            description: >

              The region/location of the site the user is visiting. This is for
              sites that serve different regions or

              markets. You can define your own region keywords, for example, `US
              East`, `Europe`, `LATM`, etc.
            example: US East
          page:
            title: Page
            allOf:
              - $ref: '#/components/schemas/Page'
            description: >-
              The current page in the browser. Page dictionary containing
              referrer, title and url. we will use page view
                      as a pseudo interaction to infer users' interest. 
          user_agent:
            title: User Agent
            type: string
            description: >

              User agent of the device making the request. We use this to
              determine if a user is browsing the site on

              mobile or desktop, and tailor the recommendations and search results
              accordingly.


              Example:

              ```

              {"user_agent":
                  "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0"}
              ```
            example: >-
              Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101
              Firefox/47.0
          custom_context:
            title: Custom Context
            type: object
            additionalProperties:
              anyOf:
                - type: boolean
                - type: integer
                - type: number
                - type: string
                - type: array
                  items:
                    type: number
                - type: array
                  items:
                    type: string
                - type: array
                  items:
                    type: object
                    additionalProperties:
                      anyOf:
                        - type: string
                        - type: number
                        - type: integer
                        - type: boolean
            description: >

              Dictionary of custom context variables for the current browsing
              session. You can specify context variables

              specific to your websites or apps in a `{"KEY":VALUE}` format, where
              `KEY` must be a string, and `VALUE` can be:

              * a `bool`

              * a `string` or an `array of string`

              * a `number` or an `array of numbers`

              * an `array of objects`

              * `null`


              Miso will take these variables into account when generating
              recommendations.
            example:
              session_variable_1:
                - value_1
                - value_2
      YMALRequest:
        title: YMALRequest
        type: object
        properties:
          product_id:
            title: Product Id
            minLength: 1
            type: string
            description: >

              The `product_id` of the *anchor* product. The returned
              recommendations will be

              the products that are similar or are liked by the same users who
              also like the anchor product.
          product_ids:
            title: Product Ids
            minLength: 1
            type: array
            items:
              type: string
              minLength: 1
            description: >

              The `product_ids` of a **list** of *anchor* products. The returned
              recommendations will be

              the products that are similar or are liked by the same users who
              also like these anchor products. For example,

              you can use the products in a user's shopping cart as the anchor
              products to make purchase recommendations

              for this user.
          product_group_id:
            title: Product Group Id
            minLength: 1
            type: string
            description: >

              The `product_group_id` of the *anchor* product group. The returned
              recommendations will be

              the products that are similar or are liked by the same users who
              also like the anchor *product group*.


              You should use `product_group_id` on a *product

              group* page, before users select a specific product variant. For
              example, you should use `product_group_id`

              on the product group page of a T-shirt, and use `product_id`, once
              user choose any specific size or color

              variants of the T-shirt.
          product_group_ids:
            title: Product Group Ids
            type: array
            items:
              type: string
            description: >

              The `product_group_ids` of the *anchor* product groups. The returned
              recommendations will be

              the products that are similar or are liked by the same users who
              also like the anchor *product groups*.


              You should use `product_group_ids` in pages you want to recommend
              products related to multiple product groups.
          buy_together:
            title: Buy Together
            type: boolean
            description: >+

              Whether to focus on the Products that are frequently *bought
              together*. `buy_together` parameter is by default `false`,

              which make the *Product To Products API* focus on Products that are
              related to the anchor products, e.g. the products

              with similar contents or frequently attract the interests of the
              same group of users.


              When `buy_together=true`, the ProductToProducts API will focus on
              the type of Products that are more frequently bought

              together along with the anchor product(s) in the same transactions
              or session.

            default: false
          engine_id:
            title: Engine Id
            type: string
            description: >

              The engine you want to get results from. When you have more than one
              engine, you can use this parameter to

              specify the specific engine you want to get results from. If not
              specified, the default engine will be used.
          user_id:
            title: User Id
            type: string
            description: >

              The user who made the query and for whom Miso will personalize the
              results. For an anonymous visitor, use `anonymous_id` instead.
          anonymous_id:
            title: Anonymous Id
            type: string
            description: >-
              The anonymous visitor who made the query and for whom Miso will
              personalize the results. Either
                      `user_id` or `anonymous_id` needs to be specified for personalization to work. 
          user_hash:
            title: User Hash
            type: string
            description: >

              The hash of `user_id` (or `anonymous_id`) encrypted by your [Secret
              API Key](https://api.askmiso.com).

              `user_hash` is required to prevent unauthorized API access if you
              are

              making API calls with a [Publishable API
              Key](https://api.askmiso.com).


              You should generate the user_hash via HMAC scheme: you encrypt the
              desired user_id (or anonymous_id) with your

              [Secret API Key](https://api.askmiso.com) on your backend server,

              and then let the front-end code send the generated user_hash to Miso
              APIs to

              verify the identity of the API caller.


              As long as the [Secret API Key](https://api.askmiso.com)
               is kept secret, the user_hash prevents a malicious attacker from making unauthorized
              API calls or impersonating any of your users.


              Miso APIs accept the case-incentive "hex digest" of user hash, a
              sample Python 3 code to generate it on your backend server

              is as follow:


              ```python

              import hashlib

              import hmac


              YOUR_MISO_SECRET_API_KEY = "039c501ac8dfcac91"

              key_bytes = YOUR_MISO_SECRET_API_KEY.encode()

              user_id = "USER_123" # or anonymous_id

              user_id_bytes = user_id.encode()

              user_hash = hmac.new(
                  key_bytes,
                  user_id_bytes,
                  hashlib.sha256).hexdigest()
              # user_hash is "7eb04da5e..."

              ```


              You can find more examples for other languages in this [Github
              Gist](https://gist.github.com/thewheat/7342c76ade46e7322c3e)
          user_cohort:
            title: User Cohort
            type: object
            additionalProperties:
              anyOf:
                - type: boolean
                - type: string
            description: >

              The user cohort you want to cold-start the recommendation with. For
              example, the following query will make

              recommendations based on the preferences of the users whose
              `country="United States"`, and `gender="Female"`

              in the User Profile dataset.

              ```

              {
                  "user_cohort": {
                      "country": "United States",
                      "gender": "Female"
                  }
              }

              ```
          rows:
            title: Rows
            type: integer
            description: Number of product recommendations to return
            default: 5
          type:
            title: Type
            type: string
            description: >

              The type of products to return. Use this parameter to make the API
              return only

              a certain type of products (see [Product
              APIs](https://api.askmiso.com)).


              This is particularly useful for sites that have multiple types of
              products:

              For example, on a marketplace site, YOu may model *merchandise* and
              *store* as two types of *products*. You can

              then use type parameter to limit the recommendation or search
              results to return only one kind of them.


              For instance, the following query will return only *store* products:
               ```
              {"type": "store"}
               ```

              For another example, on a travel website, you might have: *hotel*,
              *thing to do*, and *restaurant*,

              three kinds

              of products. You can use `type` parameter to limit results to one
              kind of them. For instance, the following

              query will limit the results to only *hotels* product:
               ```
              {"type": "hotel"}
               ```
          dedupe_product_group_id:
            title: Dedupe Product Group Id
            type: boolean
            description: >

              Whether to dedupe product based on `product_group_id`. If
              `dedupe_product_group_id=true`,

              Miso will prevent products with the same `product_group_id` from
              showing multiple

              times in the search or recommendation results.



              This is particular useful when one product has multiple variants
              (for example, different

              sizes, colors, or materials), and you only want to show this product
              only once in the search or recommendation

              results. Miso will then return the variant that is most likely to be
              of the user's interest.
            default: true
          additional_interactions:
            title: Additional Interactions
            type: array
            items:
              anyOf:
                - $ref: '#/components/schemas/ProductDetailPageView'
                - $ref: '#/components/schemas/Search'
                - $ref: '#/components/schemas/AddToCart'
                - $ref: '#/components/schemas/RemoveFromCart'
                - $ref: '#/components/schemas/Checkout'
                - $ref: '#/components/schemas/Refund'
                - $ref: '#/components/schemas/Subscribe'
                - $ref: '#/components/schemas/AddToCollection'
                - $ref: '#/components/schemas/RemoveFromCollection'
                - $ref: '#/components/schemas/Read'
                - $ref: '#/components/schemas/Watch'
                - $ref: '#/components/schemas/Listen'
                - $ref: '#/components/schemas/Like'
                - $ref: '#/components/schemas/Dislike'
                - $ref: '#/components/schemas/Share'
                - $ref: '#/components/schemas/Rate'
                - $ref: '#/components/schemas/Bookmark'
                - $ref: '#/components/schemas/Complete'
                - $ref: '#/components/schemas/Feedback'
                - $ref: '#/components/schemas/Impression'
                - $ref: '#/components/schemas/ViewableImpression'
                - $ref: '#/components/schemas/Click'
                - $ref: '#/components/schemas/HomePageView'
                - $ref: '#/components/schemas/CategoryPageView'
                - $ref: '#/components/schemas/PromoPageView'
                - $ref: '#/components/schemas/ProductImageView'
                - $ref: '#/components/schemas/Custom'
            description: >

              A list of additional interaction records. You can use this fields to
              simulate user interactions without

              actually writing them to the interaction dataset.
            default: []
          fl:
            title: Fl
            type: array
            items:
              type: string
            description: >

              List of fields to retrieve. For example, the following request
              retrieves only the `title` field of each product along

              with the `product_id`, which is always returned.


              ```

              {"fl": ["title"]}

              ```


              You can also match field names by using `*` as a wildcard. For
              example, the query below retrieves the `title`

              and any custom attributes under the `attributes` dictionary.


              ```

              {"fl": ["title", "attributes.*"]}

              ```


              The following retrieves all the available fields:


              ```

              {"fl": ["*"]}

              ```


              For the lowest latency, use an empty array to retrieve just the
              `product_id` field (which is the default).

              ```

              {"fl": []}

              ```
            default: []
          exclude:
            title: Exclude
            type: array
            items:
              type: string
            description: >-
              An array of `product_ids` of products you want to *exclude* from
              search results.
          boosting_tags:
            title: Boosting Tags
            type: array
            items:
              type: string
            description: >

              When `boosting_tags` is given, and there are pre-defined boost rules
              have the same tag(s),

              those boost rules will be matched, regardless if the criteria is met
              or not.


              Useful when want to force trigger specific boost campaign.
            default: []
            example:
              - tag-1
              - quetag-2
          fq:
            title: Fq
            type: string
            description: >


              Defines a query in Solr syntax that can be used to restrict the
              superset of

              products to return, without influencing the overall ranking. `fq`
              can enable users to drill down to products

              with specific features based on different product attributes


              For example, the query below limits the search results to only show
              products whose size is either `M` or `S` and

              brand is `Nike`:


              ```

              {"fq": "size:(\"M\" OR \"S\") AND brand:\"Nike\""}

              ```


              You can use `fq` to apply filters against your custom attributes as
              well. For example, the query below limits the

              search results to only products whose `designer` attribute is
              `Calvin Klein`


              ```

              {"fq": "attributes.designer:\"Calvin Klein\""}

              ```


              `fq` can also limit search results by numerical range. For example,
              the following query limits the results to

              products that have `rating >= 4`.


              ```

              {"fq": "rating:[4 TO *]"}

              ```
          boost_fq:
            title: Boost Fq
            type: string
            description: >

              Defines a query in Solr syntax that can be used to boost a subset of
              products to the top of the ranking, or to

              specific *boost positions* (See `boost_positions` parameter below.)

              For example, the query below will promote all the relevant products
              whose brand is `Nike` to the top of

              recommendation list:


              ```

              {
                  "boost_fq": "brand:\"Nike\""
              }

              ```


              For a slightly more complex example, the query below will promote
              the Nike products which have also been tagged

              as `ON SALE` to the top of the ranking:

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\""
              }

              ```

              It is worth mentioning that, Miso will only boost products that are
              relevant and have high likelihood to convert,

              and will not boost a low performance product only because it matches
              the boosting query.


              Depending on your boosting rules, in certain cases, you would like
              to prevent recommendation results from being

              too monotone due to boosting. With Miso, you have two tools to do
              so.


              First, you can specify `boost_positions` to place promoted products
              at specific positions in the ranking. For

              example, the query below will place boosted products only at the
              first and fourth places in the ranking

              (positions are 0-based), and place the remaining products in their
              original ranking, skipping these two positions.

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
                 "boost_positions": [0, 3]
              }

              ```


              The second tool is `diversification`. `diversification` parameter,
              on a best-effort basis, will try to

              maintain a minimum distance between products that have the same
              attributes. For example, the following query

              will place products made by the same brand apart from each other.

              ```

              {
                 "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
                 "diversification": {
                     "brand": {"minimum_distance": 1}
                  }
              }

              ```
          boost_positions:
            title: Boost Positions
            type: array
            items:
              type: integer
            description: >

              Defines a list of 0-based positions you want to place the boosted
              products at.


              For example, the query below will promote products whose brand is
              `Nike` as the top and second recommendations:

              ```

              {
                  "boost_fq": "brand:\"Nike\"",
                  "boost_positions": [0, 1]
              }

              ```

              If `boost_positions` is not specified (which is the default
              behavior), all the boosted products will be ranked

              higher than the rest of the products.
          boost_rules:
            title: Boost Rules
            type: array
            items:
              $ref: '#/components/schemas/BoostingFilterBase'
            description: >

              Define a list of boosting rules that will be applied to the search
              or recommendation results simultaneously. `boost_rules`

              parameter is particularly useful when you want to boost more than
              one sets of products, and promote each of them to different

              positions. For example, the query below will promote products whose
              brand is `Nike` to the top

              and second results, and products whose brand is `Adidas` to the
              third and fourth results:

              ```

              {
                  "boost_rules": [
                      {
                          "boost_fq": "brand:\"Nike\"",
                          "boost_positions": [0, 1]
                      },
                      {
                          "boost_fq": "brand:\"Adidas\"",
                          "boost_positions": [2, 3]
                      }
                  ]
              }

              ```
            default: []
          geo:
            title: Geo
            allOf:
              - $ref: '#/components/schemas/GeoQuery'
            description: >

              When set, filter result to include only products within certain
              geographic range from given point will be returned,

              or to boost product within the same range.


              Product should have a field that holds the location of the product,
              `location` is used by default,

              but other field can also be used.


              Distance can be in miles or kilometers. If `distance_unit` is not
              set, `mile` will be used.


              For example, to limit results to products within 100 miles of New
              York city:

              ```

              {
                  "geo": {
                      "filter": [{
                          "lat": 40.73061,
                          "lon": -73.93524,
                          "distance": 100
                      }]
                  }
              }

              ```


              To boost products within 2 kilometers around Alcatraz Island
              according to `loc` field:

              ```

              {
                  "geo": {
                      "boost": [{
                          "field": "loc",
                          "lat": 37.82667,
                          "lon": -122.42278,
                          "distance": 2,
                          "distance_unit": "km"
                      }]
                  }
              }

              ```
          diversification:
            title: Diversification
            type: object
            additionalProperties:
              $ref: '#/components/schemas/DiversifyField'
            description: >


              Defines diversification rules to prevent products with the same
              attributes (e.g. sneakers made by the same brand

              or books from the same authors) from showing up too close to each
              other in the results.


              For instance, customers who have purchased many of sneakers from
              Nike may happen to have recommendations or

              search results where all top-5 entries are sneakers made by Nike.
              Purely considering accuracy, these

              recommendations appear excellent since the user clearly appreciates
              Nike sneakers. However,

              such results might be considered too "plain" by the user, owing to
              its lack of diversity.


              `diversification` parameter allows you to avoid this problem by
              enforcing a desired *minimum distance* between

              products. For example, consider a list of four products whose
              `brand` are *Nike, Nike, Adidas,* and *PUMA*

              respectively. The query below will make sure there are at least one
              different product between two Nike

              products, e.g. the diversified ranking may become *Nike, Adidas,
              Nike,* and *PUMA* :

              ```

              {
                 "diversification": {"brand": {"minimum_distance": 1}}
              }

              ```


              You can also increase the minimum_distance to place products further
              apart. For example, the following query will

              make sure, for the two Nike products, there are at least *two* other
              products between them.

              As a result, the diversified ranking may become *Nike, Adidas,
              PUMA*, and *Nike*.:

              ```

              {
                 "diversification": {"brand": {"minimum_distance": 2}}
              }

              ```


              The diversification algorithm reranks the products on a best-effort
              basis. For example, for the product list

              described earlier, it is not possible to place two Nike product
              three places apart from each other. Therefore,

              the diversified ranking will still remain *Nike, Adidas, PUMA,* and
              Nike* even if we set `minimum_distance=3`.
          pagination_id:
            title: Pagination Id
            maxLength: 512
            type: string
            description: >

              A unique identifier to enable pagination in Recommendation APIs. By
              default, Recommendation APIs do not support

              pagination because the results from Miso, by its natural, will
              change in real-time with new user interactions.

              `pagination_id` allows you to implement pagination more easily by
              memorize what products we have

              returned to the current user with the same `pagination_id`.


              To enable pagination, you generate a `pagination_id` and set it in
              the first and subsequent requests in the same browsing session

              where you want to enable pagination. With `pagination_id` set, you
              can access recommendations

              in different pages using the combination of `start` and `rows`
              parameters, and Miso will ensure that no duplicated

              recommendation will be returned in different pages.


              For example, assuming you are implementing an infinite scroll with
              Miso Recommendation APIs. Before you make the first request,

              you generate a `pagination_id` using the `current datetime` or
              `uuid` like the following:

              ```javascript

              // current datetime

              var my_pagination_id = Date.now().toString()

              // OR uuid

              const uuidv4 = require("uuid/v4")

              var my_pagination_id = uuidv4()

              ```

              You can then request the first page of results with
              `my_pagination_id` like the following:

              ```javascript

              {
                  "pagination_id": my_pagination_id,
                  "start": 0,
                  "rows": 10
              }

              ```

              Then, you can request the next page of results with the same
              `my_pagination_id`, and Miso will ensure

              that no duplicated result is returned:

              ```javascript

              {
                  "pagination_id": my_pagination_id,
                  "start": 10,
                  "rows": 10
              }

              ```


              Note that, a `pagination_id` will timeout if there is no further
              request associated with it for 30 minutes.

              Also, `pagination_id` is scoped by individual users: i.e. different
              users' results will not be affected

              even if they use the same `pagination_id`.
          start:
            title: Start
            type: integer
            description: >

              The start of the page you want to access. Combine this with `rows`
              to implement pagination. You can only set it when `pagination_id` is
              given.
            default: 0
        additionalProperties: false
        description: Attributes for recommendation boosting
      app__schemas__engine_api__request__PreviewBoosting:
        title: PreviewBoosting
        required:
          - query_option
          - boost_match_type
          - boost
          - position
        type: object
        properties:
          query:
            title: Query
            type: string
            description: The boosting rule query.
          queries:
            title: Queries
            type: array
            items:
              type: string
            description: Multiple query of the boosting rule.
          query_option:
            title: Query Option
            enum:
              - contains
              - not_contain
              - is
              - is_not
            type: string
            description: >-
              The options of the query. Please fill this field with contains,
              not_contain, is, and is_not value.
          filter_query:
            title: Filter Query
            type: array
            items:
              $ref: '#/components/schemas/FilterQueryItem'
            description: The filter queries of the boosting rule.
          boost_match_type:
            title: Boost Match Type
            enum:
              - any
              - all
            type: string
            description: Type of the query. Please fill this field with any or all.
          boost:
            title: Boost
            type: array
            items:
              $ref: '#/components/schemas/BoostItem'
            description: The items of the boosting rule.
          position:
            title: Position
            type: array
            items:
              type: integer
            description: The position of the boosting rule should occur.
          json_asset:
            title: Json Asset
            type: string
            description: The boosting json asset.
            example:
              CO:
                - product-name: name
                  product-image-url: url
          boosting_tags:
            title: Boosting Tags
            type: array
            items:
              type: string
            description: The comma-separated boosting tags.
            example:
              - tag-1
              - tag-2
        description: Properties to receive on Boosting creation
      app__schemas__engine_api__request__Question:
        title: Question
        required:
          - question
        type: object
        properties:
          question:
            title: Question
            minLength: 1
            type: string
            description: The text of question.
          weight:
            title: Weight
            type: number
            description: The weight of question.
            default: 1
        description: Question object
      app__schemas__engine_api__response__Question:
        title: Question
        required:
          - question
        type: object
        properties:
          question:
            title: Question
            minLength: 1
            type: string
          weight:
            title: Weight
            type: number
            default: 1
        description: 'Question object '
      app__schemas__rec_boosting__PreviewBoosting:
        title: PreviewBoosting
        required:
          - api_names
          - boost_match_type
          - boost
          - position
        type: object
        properties:
          api_names:
            title: Api Names
            type: array
            items:
              type: string
            description: The api_names values
          anchor_products:
            title: Anchor Products
            type: array
            items:
              type: string
            description: The anchor products ids
            default: []
          module_names:
            title: Module Names
            type: array
            items:
              type: string
            description: The module name
          boost_match_type:
            title: Boost Match Type
            enum:
              - any
              - all
            type: string
            description: Type of the query. Please fill this field with any or all.
          boost:
            title: Boost
            type: array
            items:
              $ref: '#/components/schemas/BoostItem'
            description: The items of the boosting rule.
          position:
            title: Position
            type: array
            items:
              type: integer
            description: 1-based index of the position of the boosting rule should occur.
            example:
              - 1
              - 2
          boosting_tags:
            title: Boosting Tags
            type: array
            items:
              type: string
            description: The comma-separated boosting tags.
            example:
              - tag-1
              - tag-2
        description: Attributes of boosting
    securitySchemes:
      Secret API Key:
        type: apiKey
        description: >+

          Your secret API key is used to access every Miso API endpoint. You
          should secure this key and only use it on a backend 

          server. Never leave this key in your client-side JavaScript code. If the
          private key is compromised, you can revoke it 

          in [Dojo](https://dojo.askmiso.com/docs/api-browser) and get a new one.


          Specify your secret key in the `api_key` query parameter. For example:

          ```

          POST /v1/users?api_key=039c501ac8dfcac91c6f05601cee876e1cc07e17

          ```

        in: query
        name: api_key
      Publishable API Key:
        type: apiKey
        description: >

          Your publishable API key is used to call Miso's APIs from your front-end
          code. It can be used to stream interactions from the browser using
          Miso's Interactions Upload API or to access read-only search and
          recommendation results for a given user. When using the publishable API
          key, the requested user_id will need to be hashed to maintain the
          necessary security compliance. 


          Specify your publishable key in the `api_key` query parameter. For
          example:

          ```

          POST /v1/interactions?api_key=039c501ac8dfcac91c6f05601cee876e1cc07e17

          ```
        in: query
        name: api_key
  tags:
    - name: Experiment APIs
      description: >

        Miso's experiment APIs let you do the A/B testing of your current result
        with Miso.


        ### Start an experiment in Dojo.


        Login to the [dojo](https://dojo.askmiso.com) platform.

        Create an experiment event for you.


        ### Start running A/B testing in your environment.


        #### Implement A/B testing code.


        Here's an example in NodeJS. You can also use any programming language of
        you choice.

        ```nodejs

        const axios = require('axios');


        async function get_user_experiment_info(api_key, experiment_id, user_id) {
            data = {"user_id": user_id}
            endpoint = `https://api.askmiso.com/v1/experiments/${experiment_id}/events?api_key=${api_key}`
            return await axios.post(endpoint, data)
        }


        const api_key = '<YOUR_SECRET_API_KEY>'

        const experiment_id = "<EXPERIMENT_ID | EXPERIMENT_SLUG_NAME>"

        let user_id = 'user_1234'  // use to evaluate a treatment for


        const user_experiment_info = get_user_experiment_info(api_key,
        experiment_id, user_id)

        user_experiment_info.then((response) => {
            let variant = response.data['variant']
            if (variant['name'] == "treatment") {
                // insert code here to show "treatment" variant
            } else if (variant['name'] == "control") {
                // insert code here to show "control" variant
            } else {
                // unexpected variant name. raise error
                throw new Error(`Unexpected variant name ${variant["name"]}`)
            }
        })

        ```


        If you implement A/B testing code in FrontEnd, like JavaScript, and are
        also worried about exploding the secret api_key. You can choose to use
        anonymous_id with the public_api_key for this API. Here's an example.


        ```javascript

        const apiKey = '<YOUR_PUBLIC_API_KEY>';

        const experimentId = '<EXPERIMENT_ID | EXPERIMENT_SLUG_NAME>';

        const anonymous_id = 'user_1234';  // use to evaluate a treatment for


        function getUserExperimentInfo(apiKey, experimentId, anonymous_id) {
          const data = {
            user_id: anonymous_id
          };
          const url = `https://api.askmiso.com/v1/experiments/${experimentId}/events?api_key=${apiKey}`;
          const options = {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(data),
          };

          return window.fetch(url, options)
            .then((response) => response.json())
            .then((data) => {
              const variantName = data.variant.name;
              if (variantName === `${this.treatmentName}`) {
                // insert code here to show 'treatment' variant
              } else if (variantName === `${this.controlName}`) {
                // insert code here to show 'control' variant
              } else {
                // unexpected variant name, throw error
                throw new Error(`Unexpected variant name: ${variantName}`);
              }
            })
            .catch((error) => console.error(error));
        }


        getUserExperimentInfo(apiKey, experimentId, anonymous_id);

        ```
    - name: Interaction APIs
      description: >+

        Miso’s Interaction APIs let you manage your Interaction records stored
        with Miso.


        ### Interaction records

        Your Interaction records tell Miso about user interactions with products
        and content on your site or application.

        From these interactions, Miso understands how users move through your
        conversion funnels: which products or content

        assets attract the attention of each individual user, and which products
        or content ultimately will be purchased or

        consumed by each of them. With these insights, Miso makes real-time
        tailored recommendations for each user, and

        responds to each of their clicks and views on the site (even for anonymous
        users).


        Interaction records share some common attributes, but are distinguished by
        their type.

        Miso captures 23 different interaction types, divided into the following 6
        groups:


        #### Core click-streams

        * `product_detail_page_view`: a user viewed the detail page for a product

        * `search`: a user made a search request with keywords and (optionally)
        filters


        The above interactions are the core fuel for Miso's personalization
        Engines, because they happen in a much higher

        frequency than other interactions and provide an unbiased and
        high-fidelity view of users' interests on the site.

        The collection of these interactions is highly important for Miso's
        personalization performance. At the minimum,

        you should implement the `product_detail_page_view` interaction to start
        with.


        #### Conversion (eCommerce)

        * `add_to_cart`: a user added a product to the shopping cart

        * `remove_from_cart`: a user removed a product from the shopping cart

        * `checkout`: a user checked out and started the payment process

        * `refund`: a user refunded the product

        * `subscribe`: a user subscribed to a product


        The above interactions are the main revenue drivers for eCommerce sites.
        It’s important to collect them so that

        Miso can not only drive click-through rates, but actually improve the
        revenue in a targeted way. To start with,

        you should at least implement the `add_to_cart` interaction.


        #### Consumption (content media)

        * `read`, `watch`, and `listen` interactions capture how and for how long
        a user consumed a piece of content.

        * `add_to_collection`: a user added an product to their personal
        collection

        * `remove_from_collection`: a user removed an product from their personal
        collection


        If you are a content site, the above interactions are the main drivers to
        users' satisfaction on the site.

        Collecting these interactions allows Miso to drive consumption rates and
        consumption durations for the content on

        your site. If you run a content site, you should implement at least one of
        these interactions.


        #### Feedback signals

        * `like`, `dislike`, `share`, `rate`,  and `bookmark` are common ways 
        users express their interests.


        These are strong signals for Miso to understand each user's preferences
        regarding your products or content. You

        should send these signals to Miso if you have any of these UI patterns on
        your site.


        #### Performance Checking

        * `impression`: a user saw or was presented with a product or content
        asset (but didn't yet interact with it)

        * `viewable_impression`: the product or content presented is actually
        viewed by the user
          (for example, minimum of 50% of the pixels were in viewable space for at least one continuous second.)
        * `click`: a user clicked on something (for example, a product item)


        #### Additional click-streams

        * `home_page_view`: user viewed your home page

        * `category_page_view`: a user viewed the page for a specific “group” or
        “family” or products or content in your catalog

        * `promo_page_view`: user viewed the promotion pages about certain
        products

        * `product_image_view`: user clicked on or otherwise interacted with  the
        product image (e.g. enlarged the image)


        The above interactions are additional signals for Miso to understand
        users' behavior on the site.


        #### Custom

        * `custom` interaction types are reserved for you to define your own
        business-specific interaction types.


        Miso will analyze any custom interactions you define to infer users'
        interests and preferences.


    - name: Product / Content APIs
      description: >+

        Miso's Product / Content APIs let you upload, read, and delete Product /
        Content records that represent your site's

        catalog.


        ### Product / Content records

        Miso analyzes your Product / Content records to provide personalized
        search and recommendations that connect users

        with products or content on your site or application.


        Much of Miso's search and personalization capability relies on
        understanding your catalog in-depth and drawing

        correlations between your catalog and your users' consumption or
        purchasing behaviors. In other words, Miso

        discovers that, with high correlation, users who are interested in certain
        product attributes would also be

        interested in other products with similar or related attributes. (For
        simplicity, we will often overload the word

        "products" to mean items for purchase if you are an eCommerce business,
        and content to consume if you are a content

        marketplace.)


        To fully optimize your search and recommendations, it is important to
        provide Miso with Product / Content records

        that are complete and accurate. We define a set of common attributes that
        capture the basics of most eCommerce and

        content media products, such as `title`, `description`, `categories`,
        `tags`, `material`, `authors`, etc.


        If your products' characteristics cannot be fully captured by these
        fields, we recommend that you specify

        `custom_attributes`. For Miso, the more complete the product information
        is, the better its personalized search

        and recommendations become.

    - name: User APIs
      description: >+

        Miso’s User APIs let you upload, read, and delete User records that tell
        Miso about your site’s unique users and

        visitors.


        ### User records

        User records specify relatively static attributes for a given user, such
        as their `age`, `gender`, `city`, etc. As a

        rule of thumb, you should put information here that is not already
        captured in your

        [Interaction records](https://api.askmiso.com). For example,
        *last_bought_product* is probably not needed here because

        Miso already can tell that from the [Interaction
        records](https://api.askmiso.com).


        Miso will discover the correlations between a user's attributes and their
        behaviors on your site. For example, Miso

        might determine that users of a certain age group tend to be interested in
        certain products or a certain price

        range. These insights will be taken into account when predicting users'
        interests, in particular for new users who

        have not yet generated many interaction records.


        We define a set of common user attributes for e-Commerce and content media
        sites. Some of them, such as `name` are

        for display in the Dojo dashboard only. The rest are for model quality.
        Most attributes are optional and you don't

        need to specify them if you don't collect such data. On the other hand,
        you can specify your custom user attributes

        in the `custom_attributes` field. Miso will analyze custom user attributes
        to improve the model quality as well.

    - name: Bulk API
      description: >

        The Bulk API provides an efficient interface for making multiple Search /
        Recommendations / Q&A requests in one API

        call. These requests will be executed concurrently at the Miso side, and
        returned at once when all of them are finished.

        This API is particularly useful when you need to invoke multiple Miso APIs
        to respond to a user request.

        Using this API, you can batch multiple API calls into one, and
        significantly save the network round-trip times.


        ### Request schema

        The request schema for this API call is as follow:

        ```

        POST /v1/bulk

        {
          "requests": [
            {
              "api_name": "search/search",
              "body": { ... }
            },
            {
              "api_name": "recommendation/product_to_product",
              "body": { ... }
            },
            ...
          ]
        }

        ```

        Each request object should contain:

        * **api_name**: name of the API you want to access. The name should
        contain a slash `/`.

        For example, search/search for search requests, search/autocomplete for
        autocomplete requests, etc.

        * **body**: the complete request body as if you are making the API request
        individually.


        Any errors in one of the requests will be returned, and will not prevent
        other requests from being

        executed.


        ### Response Schema

        Bulk API endpoint will return the API responses in the same order as they
        appear in the request.

        For example, if the Bulk API request is like the following:

        ```

        POST /v1/bulk

        {
          "requests": [
            {... request 1 ...},
            {... request 2 ...}
          ]
        }

        ``` 


        The response will be like:

        ```

        {
          "data": [
            // response for request 1
            {
              "error": false,
              "status_code": 200,
              "body": { ... }
            },
            // response for request 2
            {
              "error": false,
              "status_code": 200,
              "body": { ... }
            }
          ]
        }

        ```


        Each response object will contain the following fields:

        * **error**: whether there was an error with the request. You should check
        this field to determine whether to

        perform error handling.

        * **status_code**: status code of the request.

        * **body**: the response body of the request (as if the request was sent
        individually).


        Let's see a complete example with MovieLens data. The following requests
        will issue two requests in one API call that 

        return the `Sci-Fi` movies directed by

        *Ridley Scott*, and *James Cameron* respectively in the first and second
        responses:

        ```

        POST /v1/bulk

        {
          "requests": [
            {
              "api_name": "search/search",
              "body": {
                "user_id": "test_user",
                "q": "sci-fi",
                "fq": "custom_attributes.director:\"Ridley Scott\""
              }
            },
            {
              "api_name": "search/search",
              "body": {
                "user_id": "test_user",
                "q": "sci-fi",
                "fq": "custom_attributes.director:\"James Cameron\""
              }
            }
          ]
        }

        ```

        The response will be like:

        ```

        {
          "data": [
            {
              "error": false,
              "status_code": 200,
              "body": {
                "data": {
                  "took": 136,
                  "miso_id": "19ab254c-5fb8-11ec-bd48-b20169940af9",
                  "products": [
                    {
                      "product_id": "blade-runner",
                      "title": "Blade Runner (1982)"
                    }
                  ],
                  "total": 6,
                  "start": 0
                }
              }
            },
            {
              "error": false,
              "status_code": 200,
              "body": {
                "data": {
                  "took": 116,
                  "miso_id": "19ab254c-5fb8-11ec-bd48-b20169940af9",
                  "products": [
                    {
                      "product_id": "avatar",
                      "title": "Avatar (2009)"
                    }
                  ],
                  "total": 10,
                  "start": 0
                }
              }
            }
          ]
        }

        ```
    - name: Ask APIs
      description: >+

        Miso's new Ask API is the next generation of question answering APIs.

        It is designed to provide accurate and concise answers to your questions

        based on your existing product documents.


        Ask API offers a seamless and effective way to address complex queries in

        a near-realtime fasion.


        Miso preprocesses your product documents, breaking them into segments.

        When a question is received, Miso finds the most related product and
        segments, then

        summarize to a concise and informative answer based on the identified
        segments,

        including products related to the question.


        Possible use case includes: knowledge base, documentation search, customer
        support, and more.


        To use the Ask API, you first submit a "question" you want to ask.

        Question can be any human-readable text. Then a question ID will returned,

        and the question will be processed in the background.


        After receving question ID, you can then use the question ID to get latest
        answer

        to the question as it is being compiled.


        ----


        For example:


        If you want to know about the inner workings of nginx:


        ```json

        {
            "question":"How nginx works internally?"
        }

        ```


        The API would response with a question id.

        ```json

        {
            "data": {
                "question_id": "ff4775fa-345e-4d28-91b0-8fb8bf095e6a"
            },
            "message": "success"
        }

        ```


        Then you can send a GET request to
        `/v1/ask/questions/{question_id}/answer`

        to get the latest answer as it is being compiled and summerized.

        You can use `answer_stage` and `finished` to check current answer status.


        Here's the response of answer API when data is fetched and being verified,
        before answer is summerized:

        ```json

        {
            "message": "success",
            "data": {
                "question": "How nginx works internally?",
                "question_id": "ff4775fa-345e-4d28-91b0-8fb8bf095e6a",
                "parent_question_id": null,
                "answer_stage": "Verifying possible answers",
                "finished": false,
                "answer": "Verifying possible answers ...",
                "sources": [],
                "related_resources": [],
                "followup_questions": []
            }
        }

        ```


        Here's the response when answer is fullly summerized:


        ```json

        {
            "message": "success",
            "data": {
                "question": "How nginx works internally?",
                "question_id": "ff4775fa-345e-4d28-91b0-8fb8bf095e6a",
                "parent_question_id": null,
                "answer_stage": "Generating summary",
                "finished": true,
                "answer": "# How does Nginx work internally?\n\n## Internal requests [1]\n\nNginx differentiates between external and internal requests. External requests...[omitted for simplicity]",
                "sources": [
                    {
                        "title": "Internal requests",
                        "product_id": "9781788623551",
                        "child_title": "Internal requests",
                        "child_id": "203",
                        "snippet": "<mark>Internal requests\nNginx differentiates external and internal requests.</mark>"
                    },
                    {
                        "title": "5. Nginx Core Architecture",
                        "product_id": "9781484216569",
                        "child_title": "5. Nginx Core Architecture",
                        "child_id": "5",
                        "snippet": "Checks if the client can access of the requested the resource.\n<mark>It is at this step that Nginx...[omitted]</mark>"
                    },
                    {
                        "title": "2. Managing Nginx",
                        "product_id": "9781785289538",
                        "child_title": "2. Managing Nginx",
                        "child_id": "14",
                        "snippet": "<mark>The Nginx connection processing architecture\nBefore you study...[omitted]</mark>"
                    },
                    {
                        "title": "3. Nginx Core Directives",
                        "product_id": "9781484216569",
                        "child_title": "3. Nginx Core Directives",
                        "child_id": "3",
                        "snippet": "<mark>Understanding the Default Configuration\nThe default configuration...[omitted]</mark>"
                    },
                    {
                        "title": "4. Nginx Modules",
                        "product_id": "9781484216569",
                        "child_title": "4. Nginx Modules",
                        "child_id": "4",
                        "snippet": "<mark>Based on the context like HTTP, MAIL, and STREAM, it creates a ...[omitted]</mark>"
                    }
                ],
                "related_resources": [],
                "followup_questions": [
                    "What are the steps involved in processing a request and generating a response in Nginx?",
                    "How do Nginx modules contribute to the internal workings of Nginx?"
                ]
            }
        }

        ```


        Related product IDs will be returned along with human-readable answer.
        Related text section in the product will also be quoted.


        If a product has any children, they will also be matched, `child_id` and
        `child_title` will be included for sources belonging to the product's
        children.


        You can use `fq` to limit the search scope, for example, to a specific
        product type or other condition.


        If you only want to search for books (no articles of videos), you can use
        `fq=type:book` like this:

        ```json

        {
            "question":"How nginx works internally?"
            "fq": "type:book"
        }

        ```


        If you want the answer to contain any other fields, set `source_fl` when
        submitting the question.

  x-tagGroups:
    - name: Data APIs
      tags:
        - Interaction APIs
        - Product / Content APIs
        - User APIs
    - name: Engine APIs
      tags:
        - Search APIs
        - Recommendation APIs
        - Ask APIs
        - Signal API
        - Bulk API
    - name: Experiment APIs
      tags:
        - Experiment APIs
    - name: Q&A API
      tags:
        - Q&A APIs
  servers:
    - url: https://api.askmiso.com
konfigCliVersion: 1.38.61
